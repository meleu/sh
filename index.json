[{"content":"Neste artigo eu ofere√ßo uma rela√ß√£o de conte√∫do em portugu√™s para que voc√™ comece DO ZERO e chegue a um n√≠vel razo√°vel de profici√™ncia em programa√ß√£o shell.\nEu reconhe√ßo que alguns artigos aqui do meleu.sh n√£o s√£o l√° t√£o focados no leitor que est√° iniciando suas aventuras no shell.\nConforme eu digo na p√°gina \u0026ldquo;sobre\u0026rdquo;, na se√ß√£o \u0026ldquo;Por que criei esse site?\u0026rdquo;:\n Meu objetivo √© conseguir difundir no mercado brasileiro a ado√ß√£o de boas pr√°ticas referentes a shell-script (principalmente bash). Deixar o c√≥digo mais leg√≠vel e de mais f√°cil manuten√ß√£o.\n Como podemos inferir, se o meu objetivo √© divulgar boas pr√°ticas de shell-script, est√° impl√≠cito que o leitor conhe√ßa o m√≠nimo do assunto para ent√£o aplicar estas pr√°ticas.\nEu pretendo manter o meleu.sh nessa mesma pegada, mas n√£o quero deixar de fora o pessoal que √© completamente iniciante. E para evitar \u0026ldquo;reinventar a roda\u0026rdquo; e escrever eu mesmo material voltado para iniciantes, vou listar aqui material que eu considero de √≥tima qualidade publicado em portugu√™s.\n(Curiosidade: em 2002 eu escrevi um material bastante extenso sobre bash em portugu√™s. Este sim, era voltado para iniciantes. Esse documento ainda existe, mas nesses 20 anos muita coisa boa j√° foi escrita em portugu√™s.)\nSou completamente iniciante Imaginando o cen√°rio em que voc√™ n√£o sabe nem o que √© vari√°vel, if, for, while, case, etc.\nSe voc√™ quer aprender essas coisas usando o shell. Eu recomendo fortemente que voc√™ confira a s√©rie de v√≠deos do Blau Ara√∫jo intitulada Curso B√°sico de Bash.\nO Blau tem uma did√°tica incr√≠vel, explica tudo com bastante paci√™ncia e vai progredindo devagarinho, adicionando novos conceitos s√≥ depois de ter explicado o anterior com detalhes.\nSe voc√™ acabou de chegar no universo Linux e quer come√ßar a se aventurar na telinha preta, essa s√©rie do Blau vai te ajudar muito!\nJ√° tenho uma no√ß√£o de programa√ß√£o/algoritmos Se voc√™ j√° conhece alguma coisa de algoritmos e programa√ß√£o, o que eu recomendo √© o Curso intensivo de programa√ß√£o em Bash, tamb√©m do Blau Ara√∫jo. Trata-se de uma s√©rie de v√≠deos onde ele j√° parte do princ√≠pio que voc√™ j√° tem alguma no√ß√£o b√°sica de programa√ß√£o e vai evoluindo de uma maneira um pouco mais r√°pida do que o Curso B√°sico.\nExiste ainda uma outra s√©rie de v√≠deos do Blau que eu achei bem legal, que √© a Cria√ß√£o de scripts em Bash. Onde ele vai escrevendo um script para o \u0026ldquo;jogo da adivinha√ß√£o\u0026rdquo; e no caminho vai explicando v√°rios conceitos de programa√ß√£o shell. Tamb√©m recomendo.\nLivros Para aqueles que, como eu, gostam de ter um material na forma escrita, o Blau (eita p*rr@! esse cara t√° em todas!) tamb√©m escreveu o Pequeno Manual do Programador Bash. Conte√∫do bastante valioso que pode ser baixado gratuitamente.\nOutro livro bastante valioso para se ter a m√£o √© o Programa√ß√£o Shell Linux: Refer√™ncia Definitiva da Linguagem Shell, do grande mestre J√∫lio Cezar Neves. Como o pr√≥prio t√≠tulo diz, este √© um livro de refer√™ncia. Excelente para ter ao alcance para tirar uma d√∫vida e/ou aprender algo que ainda n√£o esteja dominando. (Observa√ß√£o: esse livro foi originalmente publicado pela editora Brasport, mas em sua 12a. edi√ß√£o foi para a editora Novatec e est√° com uma diagrama√ß√£o mais caprichada).\nAp√≥s j√° ter come√ßado a n√£o s√≥ brincar com shell scripts, mas tamb√©m a escrever scripts mais s√©rios, o pr√≥ximo material que eu recomendo √© o Shell Script Profissional, do Aurelio Marinho Jargas. Aqui vamos sair do b√°sico e come√ßar a levar o shell script mais a s√©rio.\nCedo ou tarde voc√™ vai precisar se sentir confort√°vel com Express√µes Regulares, e na nossa l√≠ngua o melhor livro que existe nesse tema √© o Express√µes Regulares - Uma abordagem divertida, tamb√©m do Aurelio. Esse livro eu recomendo para qualquer profissional de TI, at√© mesmo se n√£o vai trabalhar com shell. Conte√∫do extremamente valioso.\nArtigos mais importantes do meleu.sh Eu uso a tag fundamentos para categorizar artigos que considero importantes para iniciantes. Tamb√©m uso a tag boas-praticas para artigos que mostram algumas t√©cnicas que podem at√© n√£o ser totalmente compreendidas por iniciantes, mas se um iniciante seguir, certamente evitar√° muitas dores de cabe√ßa.\nVou listar aqui, em ordem de import√¢ncia (o que vem primeiro √© o mais importante):\nO que o #! realmente faz? link\nO \u0026ldquo;shebang\u0026rdquo; √© a coisa mais fundamental de um script, pois √© onde voc√™ define quem vai interpretar os comandos que est√£o no arquivo. Portanto voc√™ precisa entender o que ele faz.\nPor que voc√™ deve usar aspas SEMPRE link\nResumindo a import√¢ncia desse artigo com uma cita√ß√£o: \u0026ldquo;uma vari√°vel em bash √© como uma granada, tire suas aspas e uma hora ela explodir√°\u0026rdquo;.\nDeixe o bash mais rigoroso com seu script e evite dores de cabe√ßa link\nCom essa t√©cnica o seu script ir√° falhar o mais r√°pido poss√≠vel. Desta forma voc√™ poder√° repar√°-lo enquanto ainda est√° trabalhando nele, com o contexto do problema ainda fresquinho na cabe√ßa.\nUse essa t√©cnica mesmo que voc√™ seja um iniciante!\nComo detectar precisamente onde seu script est√° quebrando link\nCom essa t√©cnica voc√™ ser√° capaz de evitar muita perda de tempo tentando encontrar onde seu script est√° bugando.\nNesse artigo falamos de trap, o que n√£o √© l√° um tema muito voltado para iniciantes. Mas recomendo que voc√™ fa√ßa um esforcinho para usar essa t√©cnica, pois tamb√©m √© uma coisa que vai te poupar muitas dores de cabe√ßa e perda de tempo.\nUse shellcheck e livre-se dos bugs no seu c√≥digo antes mesmo de execut√°-lo link\nIsso tamb√©m n√£o √© algo super-simples para uma pessoa que ainda est√° se iniciando na linha de comando. Pode requerer um pouquinho de esfor√ßo pra colocar o shellcheck no seu fluxo de trabalho. Mas acredite em mim: a quantidade de tempo que voc√™ vai economizar se voc√™ usar shellcheck, vai recompensar o seu esfor√ßo!\nO shellcheck √© capaz de te avisar que seu c√≥digo est√° perigoso e/ou bugado, antes mesmo de voc√™ execut√°-lo!\nO shellcheck vai te explicar o motivo que aquele c√≥digo √© considerado perigoso e ainda vai te ensinar alternativas mais seguras de alcan√ßar o mesmo resultado. Ou seja, o shellcheck √© tamb√©m uma excelente ferramenta de aprendizado! (observa√ß√£o: as mensagens do shellcheck s√£o em ingl√™s).\nConclus√£o Neste artigo listei os conte√∫dos em portugu√™s que considero mais relevantes para voc√™ come√ßar sua jornada de programador shell e atingir um n√≠vel de profici√™ncia bem r√°pido.\nN√£o se esque√ßa de praticar! Sem pr√°tica, todo esse conte√∫do e todas essas ferramentas s√£o praticamente in√∫teis!\n","permalink":"https://meleu.sh/comeco/","summary":"Neste artigo eu ofere√ßo uma rela√ß√£o de conte√∫do em portugu√™s para que voc√™ comece DO ZERO e chegue a um n√≠vel razo√°vel de profici√™ncia em programa√ß√£o shell.\nEu reconhe√ßo que alguns artigos aqui do meleu.sh n√£o s√£o l√° t√£o focados no leitor que est√° iniciando suas aventuras no shell.\nConforme eu digo na p√°gina \u0026ldquo;sobre\u0026rdquo;, na se√ß√£o \u0026ldquo;Por que criei esse site?\u0026rdquo;:\n Meu objetivo √© conseguir difundir no mercado brasileiro a ado√ß√£o de boas pr√°ticas referentes a shell-script (principalmente bash).","title":"Comece por aqui!"},{"content":"Neste artigo vamos conhecer o shfmt, uma ferramenta que vai te ajudar a manter seu c√≥digo com uma formata√ß√£o consistente, e tamb√©m para tornar leg√≠vel algum c√≥digo de outra pessoa que voc√™ queira examinar.\nVeremos aqui:\n o que √© o shfmt demonstra√ß√£o de como ele √© √∫til como instalar op√ß√µes de formata√ß√£o pontos de aten√ß√£o ao utilizar o shfmt como integrar o shfmt ao seu editor (VSCode e vim)  Demonstra√ß√£o S√≥ pra deixar claro, quando eu digo formata√ß√£o estou me referindo √† indenta√ß√£o, declara√ß√£o de fun√ß√µes, quebra de linhas de comandos longos\u0026hellip; Enfim, coisas extremamente b√°sicas mas que influenciam bastante na legibilidade do seu c√≥digo.\nVeja esse exemplo ilustrativo:\n#!/bin/bash    echo \u0026#39;linha com formata√ß√£o ruim\u0026#39;  echo \u0026#39;outra linha com indenta√ß√£o feiosa\u0026#39;   echo \u0026#39;voc√™ pode n√£o estar vendo...\u0026#39; echo \u0026#39;mas esta linha tem espa√ßos em branco no final \u0026gt; \u0026#39;  func(){ if [[ $# -eq 0 ]];then echo \u0026#34;sem argumentos\u0026#34;\u0026gt;\u0026amp;2;return 1;fi; echo \u0026#34;Hello, $1\u0026#34;; }  main() {  echo \u0026#39;mais espa√ßos desnecess√°rios\u0026#39;  echo \u0026#39;indenta√ß√£o exagerada\u0026#39;  }  main \u0026#34;$@\u0026#34; Com shfmt conseguimos converter aquilo üëÜ, nisso aqui üëá\n#!/bin/bash  echo \u0026#39;linha com formata√ß√£o ruim\u0026#39; echo \u0026#39;outra linha com indenta√ß√£o feiosa\u0026#39;  echo \u0026#39;voc√™ pode n√£o estar vendo...\u0026#39; echo \u0026#39;mas esta linha tem espa√ßos em branco no final \u0026gt; \u0026#39;  func() {  if [[ $# -eq 0 ]]; then  echo \u0026#34;sem argumentos\u0026#34; \u0026gt;\u0026amp;2  return 1  fi  echo \u0026#34;Hello, $1\u0026#34; }  main() {  echo \u0026#39;mais espa√ßos desnecess√°rios\u0026#39;  echo \u0026#39;indenta√ß√£o exagerada\u0026#39; }  main \u0026#34;$@\u0026#34; Vejamos agora um exemplo mais extremo. A ma√ßaroca de c√≥digo a seguir foi obtida em https://transfer.sh/ (caso n√£o conhe√ßa o servi√ßo, recomendo fortemente!):\ntransfer(){ if [ $# -eq 0 ];then echo \u0026#34;No arguments specified.\\nUsage:\\n transfer \u0026lt;file|directory\u0026gt;\\n ... | transfer \u0026lt;file_name\u0026gt;\u0026#34;\u0026gt;\u0026amp;2;return 1;fi;if tty -s;then file=\u0026#34;$1\u0026#34;;file_name=$(basename \u0026#34;$file\u0026#34;);if [ ! -e \u0026#34;$file\u0026#34; ];then echo \u0026#34;$file: No such file or directory\u0026#34;\u0026gt;\u0026amp;2;return 1;fi;if [ -d \u0026#34;$file\u0026#34; ];then file_name=\u0026#34;$file_name.zip\u0026#34; ,;(cd \u0026#34;$file\u0026#34;\u0026amp;\u0026amp;zip -r -q - .)|curl --progress-bar --upload-file \u0026#34;-\u0026#34; \u0026#34;https://transfer.sh/$file_name\u0026#34;|tee /dev/null,;else cat \u0026#34;$file\u0026#34;|curl --progress-bar --upload-file \u0026#34;-\u0026#34; \u0026#34;https://transfer.sh/$file_name\u0026#34;|tee /dev/null;fi;else file_name=$1;curl --progress-bar --upload-file \u0026#34;-\u0026#34; \u0026#34;https://transfer.sh/$file_name\u0026#34;|tee /dev/null;fi;} Ao passar esse üëÜ c√≥digo no shfmt, olha o resultado:\ntransfer() {  if [ $# -eq 0 ]; then  echo \u0026#34;No arguments specified.\\nUsage:\\n transfer \u0026lt;file|directory\u0026gt;\\n ... | transfer \u0026lt;file_name\u0026gt;\u0026#34; \u0026gt;\u0026amp;2  return 1  fi  if tty -s; then  file=\u0026#34;$1\u0026#34;  file_name=$(basename \u0026#34;$file\u0026#34;)  if [ ! -e \u0026#34;$file\u0026#34; ]; then  echo \u0026#34;$file: No such file or directory\u0026#34; \u0026gt;\u0026amp;2  return 1  fi  if [ -d \u0026#34;$file\u0026#34; ]; then  file_name=\u0026#34;$file_name.zip\u0026#34; ,  (cd \u0026#34;$file\u0026#34; \u0026amp;\u0026amp; zip -r -q - .) | curl --progress-bar --upload-file \u0026#34;-\u0026#34; \u0026#34;https://transfer.sh/$file_name\u0026#34; | tee /dev/null,  else cat \u0026#34;$file\u0026#34; | curl --progress-bar --upload-file \u0026#34;-\u0026#34; \u0026#34;https://transfer.sh/$file_name\u0026#34; | tee /dev/null; fi  else  file_name=$1  curl --progress-bar --upload-file \u0026#34;-\u0026#34; \u0026#34;https://transfer.sh/$file_name\u0026#34; | tee /dev/null  fi } Ainda podemos melhorar bastante essa formata√ß√£o (por exemplo, quebrando as linhas com |), mas a legibilidade de c√≥digo j√° ficou minimamente poss√≠vel.\nContexto pessoal Desde que conheci o shfmt eu o uso para manter o meu pr√≥prio c√≥digo com uma formata√ß√£o consistente e alinhada com o meu coding style. Mas aonde ele me deixa mais feliz √© quando preciso trabalhar num c√≥digo originalmente escrito por uma pessoa sem experi√™ncia com programa√ß√£o shell.\nSabe como √© n√©\u0026hellip; O shell √© uma linguagem muito poderosa e permissiva. A barreira de entrada √© bem pequena e devido ao poder do shell voc√™ consegue rapidamente resolver o que voc√™ precisa resolver. Por um lado isso √© bom (afinal, resolver problemas √© uma coisa boa!), mas em contrapartida acaba gerando muito c√≥digo bagun√ßado. Dif√≠cil de ler e de manter.\nPra agravar o cen√°rio, geralmente quem escreve shell scripts, s√£o SysAdmins. Historicamente um SysAdmin √© uma pessoa treinada para manter o sistema est√°vel, bem configurado e seguro. Focar em aprender t√©cnicas avan√ßadas de programa√ß√£o, Clean Code, e coisas do g√™nero normalmente n√£o √© uma prioridade para um SysAdmin.\nComo resultado, √© bastante comum encontrar por a√≠ c√≥digo bem dif√≠cil de ler/analisar/atualizar/refatorar.\nQuando me deparo com um cen√°rio desses, a primeir√≠ssima coisa que fa√ßo √© rodar o shfmt pra tornar o c√≥digo minimamente leg√≠vel (e na sequ√™ncia eu rodo shellcheck).\nInstala√ß√£o No README do projeto n√£o existe uma instru√ß√£o muito clara de como instalar o shfmt. Mas n√≥s vamos resolver isso bem r√°pido\u0026hellip;\nSe voc√™ usa uma distro baseada em Debian/Ubuntu, verifique se o programa est√° dispon√≠vel para voc√™ com sudo apt install shfmt.\nSe sua distro possui Snap, voc√™ pode instalar com snap install shfmt.\nUma outra maneira √© simplesmente baixar o bin√°rio na p√°gina de releases do projeto.\nEu particularmente gosto de instalar essas ferramentinhas que tem um desenvolvimento bem ativo, usando o asdf-vm, pois assim consigo facilmente experimentar vers√µes mais atuais das ferramentas sem ficar instalando-as globalmente no meu sistema.\nN√£o est√° no escopo desse artigo falar muito sobre o asdf-vm (fica pra um artigo futuro), mas se voc√™ tem ele a√≠, aqui est√° a receitinha de bolo pra instalar o shfmt:\n# disponibilizando o shfmt para ser instalado via asdf asdf plugin add shfmt  # instalando a vers√£o mais recente asdf install shfmt latest  # definindo a vers√£o que ser√° disponibilizada no PATH asdf global shfmt latest  # conferindo qual foi a vers√£o instalada shfmt --version  Observa√ß√£o: no momento da escrita desse artigo a vers√£o atual do shfmt √© 3.5.0\n Op√ß√µes de formata√ß√£o A primeira op√ß√£o que eu gostaria de mostrar, √© o -d/--diff. Simplesmente por ser uma op√ß√£o onde a gente consegue ver um \u0026ldquo;diff\u0026rdquo; entre o nosso c√≥digo original e o resultado ap√≥s passar pelo shfmt. Isso vai te mostrar claramente o que mudou.\nVejamos com esse codiguinho aqui:\n#!/bin/bash hello() { echo \u0026#34;Hello, $1\u0026#34; } hello \u0026#34;$@\u0026#34; Se a gente rodar o shfmt -d hello.sh, obteremos o seguinte diff (obs.: o arquivo original N√ÉO ser√° alterado):\n--- hello.sh.orig +++ hello.sh @@ -1,6 +1,6 @@  #!/bin/bash  hello() { -echo \u0026#34;Hello, $1\u0026#34; + echo \u0026#34;Hello, $1\u0026#34;  }  -hello \u0026#34;$@\u0026#34; +hello \u0026#34;$@\u0026#34; Podemos observar que o shfmt colocou uma indenta√ß√£o no echo dentro da fun√ß√£o hello, e tamb√©m tirou os espa√ßos desnecess√°rios na chamada da fun√ß√£o.\nA formata√ß√£o default ficou bacaninha, n√©? Mas vamos ver como customizar para um estilo que mais nos agrade.\nPor exemplo, eu n√£o curti muito aquela indenta√ß√£o com tab. Nos meus projetos eu costumo utilizar 2 espa√ßos para indenta√ß√£o.\nPara isso vamos utilizar a op√ß√£o -i/--indent (junto com o -d pra vermos o diff)\nshfmt -d -i 2 hello.sh No diff, a gente vai observar o seguinte:\n--- hello.sh.orig +++ hello.sh @@ -1,6 +1,6 @@  #!/bin/bash  hello() { -echo \u0026#34;Hello, $1\u0026#34; + echo \u0026#34;Hello, $1\u0026#34;  }  -hello \u0026#34;$@\u0026#34; +hello \u0026#34;$@\u0026#34; Ah\u0026hellip; Agora sim! Indenta√ß√£o com 2 espa√ßos. üôÇ\nN√£o vou ficar demonstrando aqui o que cada op√ß√£o faz (afinal, eu te mostrei o macetinho do --diff exatamente para voc√™ fazer suas experimenta√ß√µes a√≠). Mas vou listar aqui as op√ß√µes que eu costumo usar:\n -bn, --binary-next-line: para que os operadores bin√°rios \u0026amp;\u0026amp;, || e at√© o | sejam colocados no come√ßo da pr√≥xima linha.  # antes do \u0026#39;shfmt -bn\u0026#39; comando1 \u0026amp;\u0026amp;  comando2 \u0026amp;\u0026amp;  comando3  # depois do \u0026#39;shfmt -bn\u0026#39; comando1 \\  \u0026amp;\u0026amp; comando2 \\  \u0026amp;\u0026amp; comando3  -ci, --ci-indent: para adicionar indenta√ß√£o em cada op√ß√£o dentro de um case.  # antes do \u0026#39;shfmt -ci\u0026#39; case \u0026#34;${extension}\u0026#34; in .txt)  echo \u0026#34;texto\u0026#34;  ;; .mp3)  echo \u0026#34;m√∫sica\u0026#34;  ;; .md)  echo \u0026#34;markdown\u0026#34;  ;; *)  echo \u0026#34;outro formato\u0026#34;  ;; esac  # depois do \u0026#39;shfmt -ci\u0026#39; case \u0026#34;${extension}\u0026#34; in  .txt)  echo \u0026#34;texto\u0026#34;  ;;  .mp3)  echo \u0026#34;m√∫sica\u0026#34;  ;;  .md)  echo \u0026#34;markdown\u0026#34;  ;;  *)  echo \u0026#34;outro formato\u0026#34;  ;; esac  -sr, --space-redirects: operadores de redirecionamento ser√£o seguidos por um espa√ßo.  # antes do \u0026#39;shfmt -sr\u0026#39; grep meleu /etc/passwd \u0026gt;myInfo.txt  # depois do \u0026#39;shfmt -sr\u0026#39; grep meleu /etc/passwd \u0026gt; myInfo.txt As outras op√ß√µes de formata√ß√£o eu n√£o costumo usar, mas recomendo que voc√™ experimente um pouco e veja se faz sentido pra voc√™.\nUm detalhe: o shfmt te mostra a vers√£o formatada do seu c√≥digo mas ele n√£o altera o arquivo do seu c√≥digo, a menos que voc√™ explicitamente diga a ele que o fa√ßa.\nPara fazer o shfmt alterar o arquivo diretamente, use a op√ß√£o -w, --write.\nPontos de aten√ß√£o! Apesar de ser uma ferramenta extremamente √∫til, existem alguns casos onde precisamos ficar atento pois o shfmt n√£o √© capaz de lidar.\nIsso est√° listado no README do projeto e n√≥s vamos dar uma analisada aqui.\n√çndices de arrays associativos precisam de aspas Quando estiver usando um array associativo, o shfmt vai precisar que voc√™ coloque os √≠ndices entre aspas. Caso contr√°rio ele ter√° problemas para formatar √≠ndices com espa√ßos ou sinais aritm√©ticos.\nImagine um array desse tipo aqui:\n$ # para o bash isso aqui √© perfeitamente v√°lido $ declare -A array=([indice-1]=um [indice-2]=dois)  $ # passando esse c√≥digo para o shfmt $ echo \u0026#39;declare -A array=([indice-1]=um [indice-2]=dois)\u0026#39; \\  | shfmt declare -A array=([indice - 1]=um [indice - 2]=dois) $ # espa√ßos indevidos aqui üëÜ e aqui üëÜ O problema √© que o parser do shfmt acredita que ali dentro daqueles [colchetes] tem uma express√£o aritm√©tica, e a√≠ tenta formatar essa express√£o pra ficar bonitinha.\nInclusive, se o nosso √≠ndice tiver espa√ßos, o shfmt vai reclamar que n√£o estamos passando uma express√£o v√°lida:\n$ # express√£o v√°lida no bash $ declare -A array=([indice 1]=um)  $ # mas inv√°lida para o shfmt $ echo \u0026#39;declare -A array=([indice 1]=um)\u0026#39; | shfmt \u0026lt;standard input\u0026gt;:1:27: not a valid arithmetic operator: 1 Solu√ß√£o: basta usarmos aspas que o parser do shfmt vai saber que estamos passando uma string (e n√£o uma express√£o aritm√©tica):\n$ echo \u0026#39;declare -A array=([\u0026#34;indice 1\u0026#34;]=um [\u0026#34;indice-2\u0026#34;]=dois)\u0026#39; \\  | shfmt declare -A array=([\u0026#34;indice 1\u0026#34;]=um [\u0026#34;indice-2\u0026#34;]=dois) Ambiguidade entre $(( e (( Recapitulando aqui 3 features do bash:\n $((express√£o)): executa uma express√£o aritm√©tica.  ex.: echo \u0026quot;Voc√™ nasceu em $((thisYear - age))\u0026quot;   $(comando): executa o comando e devolve o output daquele comando.  ex.: echo \u0026quot;Voc√™ est√° no diret√≥rio $(pwd)\u0026quot;   (comando): executa um comando em subshell.  ex.: (cd /tmp; rm -f files*)    Se combinarmos a t√©cnica do item 2 com a do item 3, podemos ter uma situa√ß√£o do tipo\n# isso √© perfeitamente v√°lido em bash echo \u0026#34;output dos comandos: $((comando1); (comando2))\u0026#34; # o shfmt vai confundir isso üëÜ Como podemos notar, aquele comecinho ali com $(( vai confundir o shfmt.\n$ echo \u0026#39;$((comando1); (comando2))\u0026#39; | shfmt \u0026lt;standard input\u0026gt;:1:1: reached ) without matching $(( with )) De fato, essa nota√ß√£o √© apontada no pr√≥prio padr√£o POSIX como uma nota√ß√£o amb√≠gua. E recomenda que seja usado um espa√ßo para separar o $( e o (.\n$ # com espa√ßos, fica deboas üëç $ echo \u0026#39;$( (comando1); (comando2) )\u0026#39; | shfmt -i 2 $(  (comando1)  (comando2) ) Declara√ß√µes \u0026ldquo;ex√≥ticas\u0026rdquo; n√£o s√£o suportadas Em bash voc√™ consegue declarar duas vari√°veis e atribuir o mesmo valor a ambas em uma √∫nica linha, usando essa nota√ß√£o aqui:\ndeclare {var1,var2}=valor Essa nota√ß√£o n√£o √© suportada pelo shfmt, pois ele vai achar que voc√™ est√° querendo declarar uma vari√°vel chamada {var1,var2}:\n$ echo \u0026#39;declare {var1,var2}=valor\u0026#39; | shfmt \u0026lt;standard input\u0026gt;:1:9: invalid var name No meu caso isso n√£o se torna exatamente um problema, pois eu n√£o uso nem jamais usaria tal nota√ß√£o (pois acredito que o c√≥digo deve ser o mais claro e expl√≠cito poss√≠vel).\nA op√ß√£o --binary-next-line n√£o se aplica a [[ testes ]] Todos os \u0026ldquo;probleminhas\u0026rdquo; listados acima s√£o perfeitamente aceit√°veis pra mim. Tenho pra mim que eles at√© encorajam boas pr√°ticas. Mas esse aqui √© o √∫nico que me incomoda (mas nem por isso parei de usar o shfmt em TODOS os meus scripts).\nEsse problema n√£o est√° na lista de caveats do README, mas existe uma issue aberta sobre isso.\nO lance √© que a op√ß√£o -bn,--binary-next-line n√£o se aplica √†s express√µes dentro dos [[ colchetes ]].\nPor exemplo, se eu tenho uma express√£o grande dentro dos colchetes, eu costumo quebrar as linhas desta forma:\n# resultado que eu gostaria de ter if [[ -z \u0026#34;${foo}\u0026#34; \\  || -z \u0026#34;${bar}\u0026#34; \\  || -z \u0026#34;${baz}\u0026#34; ]]; then  echo \u0026#34;Hello world\u0026#34; fi  # o shfmt deixa desse jeito (que eu n√£o gosto): if [[ -z \u0026#34;${foo}\u0026#34; ||  -z \u0026#34;${bar}\u0026#34; ||  -z \u0026#34;${baz}\u0026#34; ]]; then  echo \u0026#34;Hello world\u0026#34; fi Uma maneira de contornar isso √© colocar cada teste nos seus pr√≥prios colchetes, resultando em um c√≥digo mais verboso:\n# cada teste nos seus pr√≥prios [[ colchetes ]] # formata do jeito que quero, por√©m √© mais verboso if [[ -z \u0026#34;${foo}\u0026#34; ]] \\  || [[ -z \u0026#34;${bar}\u0026#34; ]] \\  || [[ -z \u0026#34;${baz}\u0026#34; ]]; then  echo \u0026#34;Hello world\u0026#34; fi Repito, apesar de eu n√£o gostar desse problema do shfmt, ainda assim eu n√£o deixo de us√°-lo em absolutamente TODOS os meus scripts.\nE ainda tenho a esperan√ßa que o desenvolvedor da ferramenta resolve isso em algum momento (no momento da escrita desse artigo a issue ainda est√° aberta).\nInstale shfmt no seu editor Tanto no VSCode quanto no vim, espera-se que voc√™ j√° tenha o shfmt instalado (veja a se√ß√£o de instala√ß√£o acima)\nVSCode Basta instalar o plugin \u0026ldquo;shfmt\u0026rdquo; mantido pelo \u0026ldquo;Martin K√ºhl\u0026rdquo;: https://marketplace.visualstudio.com/items?itemName=mkhl.shfmt\nAp√≥s instalar o plugin, eu adicionei as seguintes configura√ß√µes no meu settings.json:\n{  // ...  \u0026#34;[shellscript]\u0026#34;: {  \u0026#34;editor.defaultFormatter\u0026#34;: \u0026#34;mkhl.shfmt\u0026#34;,  \u0026#34;editor.formatOnSave\u0026#34;: true,  },  \u0026#34;shfmt.executablePath\u0026#34;: \u0026#34;/home/meleu/.asdf/shims/shfmt\u0026#34;,  // esse path √© porque instalei o shfmt com o asdf-vm } Para acessar o seu settings.json, pressione ctrl-shift-p e comece digitando \u0026ldquo;preferences json\u0026rdquo;.\nvim Para ter o shfmt integrado ao vim eu uso o plugin z0mbix/vim-shfmt.\nComo costumo administrar meus plugins com o vim-plug, eu coloco isso no meu ~/.vimrc:\n\u0026#34; isso s√≥ vai funcionar se voc√™ tiver\u0026#34; o vim-plug devidamente instaladocall plug#begin()\u0026#34; ativa o vim-shfmt somente para arquivos .shPlug \u0026#39;z0mbix/vim-shfmt\u0026#39;, { \u0026#39;for\u0026#39;: \u0026#39;sh\u0026#39; }call plug#end()\u0026#34; aplica shfmt ao salvar o arquivolet g:shfmt_fmt_on_save = 1\u0026#34; 2 espa√ßos, binary next line, space redirects, case indentlet g:shfmt_extra_args = \u0026#39;-i 2 -bn -sr -ci\u0026#39;b√¥nus: EditorConfig Uma coisa bem bacana do shfmt √© que ele tamb√©m aceita configura√ß√µes presentes no arquivo .editorconfig. Desta forma voc√™ pode compartilhar a formata√ß√£o desejada com todos os colaboradores do projeto.\nPor exemplo, nos meus projetos eu costumo colocar esse conte√∫do no meu .editorconfig (que fica na raiz do projeto):\n[*] end_of_line = lf insert_final_newline = true [*.sh] indent_style = space indent_size = 2 # shfmt -i 2 binary_next_line = true # shfmt -bn space_redirects = true # shfmt -sr switch_case_indent = true # shfmt -ci Quando voc√™ executa o shfmt em um (sub)diret√≥rio onde tem o arquivo .editorconfig, estas op√ß√µes s√£o aplicadas mesmo que voc√™ n√£o passe par√¢metro algum para o shfmt.\n Para saber mais sobre o EditorConfig veja a p√°gina do projeto: https://editorconfig.org/\n Fontes  reposit√≥rio do shfmt no github: https://github.com/mvdan/sh exemplos de uso: https://github.com/mvdan/sh/blob/master/cmd/shfmt/shfmt.1.scd#examples plugin para vim: https://github.com/z0mbix/vim-shfmt plugin do VSCode: https://marketplace.visualstudio.com/items?itemName=mkhl.shfmt\u0026amp;ssr=false#overview EditorConfig: https://editorconfig.org/  ","permalink":"https://meleu.sh/shfmt/","summary":"Neste artigo vamos conhecer o shfmt, uma ferramenta que vai te ajudar a manter seu c√≥digo com uma formata√ß√£o consistente, e tamb√©m para tornar leg√≠vel algum c√≥digo de outra pessoa que voc√™ queira examinar.\nVeremos aqui:\n o que √© o shfmt demonstra√ß√£o de como ele √© √∫til como instalar op√ß√µes de formata√ß√£o pontos de aten√ß√£o ao utilizar o shfmt como integrar o shfmt ao seu editor (VSCode e vim)  Demonstra√ß√£o S√≥ pra deixar claro, quando eu digo formata√ß√£o estou me referindo √† indenta√ß√£o, declara√ß√£o de fun√ß√µes, quebra de linhas de comandos longos\u0026hellip; Enfim, coisas extremamente b√°sicas mas que influenciam bastante na legibilidade do seu c√≥digo.","title":"Mantenha a consist√™ncia na formata√ß√£o do seu c√≥digo com shfmt"},{"content":" Este artigo √© parte da s√©rie \u0026ldquo;Pr√°ticas de programa√ß√£o shell que mudar√£o sua vida\u0026rdquo;\nOs artigos da s√©rie s√£o:\n deixe seu bash mais rigoroso use um trap para saber exatamente onde seu script quebrou use o shellcheck   N√≥s amamos programar, n√£o √© mesmo? (se voc√™ est√° lendo esse blog, eu imagino que sim). Mas convenhamos, quando chegamos naquele ponto onde fazer uma simples altera√ß√£o envolve ficar continuamente alternando entre escrever-salvar-testar\u0026hellip; Tem hora que enche o saco!\nA ferramenta que vou mostrar neste artigo vai nos ajudar a minimizar essas constantes trocas de contexto, que quebram o ritmo da nossa escrita e racioc√≠nio.\nO shellcheck √© um linter para shell scripts. Segundo a Wikipedia um linter √©:\n uma ferramenta de an√°lise est√°tica de c√≥digo usada para alertar erros de programa√ß√£o, bugs, erros estil√≠sticos e constru√ß√µes suspeitas.\n De maneira mais simples: √© uma ferramenta que vai an√°lisar o seu c√≥digo em busca de problemas e vai te alertar sobre o que ele encontrar.\nUm contexto pessoal O shellcheck √© mais uma daquelas ferramentas que mudam a vida das pessoas. Mudou a minha vida e caso voc√™ programe em shell, tenho certeza que mudar√° a sua tamb√©m.\nEu sei que isso soa muito sensacionalista e exagerado\u0026hellip; mas √© s√©rio, n√£o consigo descrever o shellcheck de outra forma. Vou explicar o motivo falando um pouco do meu trabalho\nParte do meu dia a dia √© escrevendo/mantendo esteiras de integra√ß√£o cont√≠nua escritas em bash. O ciclo escrever-salvar-testar n√£o √© t√£o simples quanto \u0026ldquo;salvar o arquivo, ir no terminal e executar o script\u0026rdquo;. No meu caso esse ciclo geralmente envolve:\n escrever e salvar minhas altera√ß√µes fazer o commit das minhas altera√ß√µes para um reposit√≥rio git ir em outro reposit√≥rio disparar a pipeline que vai executar o meu c√≥digo esperar a vez do job onde o meu script ser√° executado esperar o container ser instanciado finalmente meu c√≥digo ser√° executado e eu poderei olhar o log em busca de problemas.  Imagina fazer todo esse processo pra no final das contas chegar a conclus√£o que voc√™ cometeu um erro de digita√ß√£o num nome de vari√°vel\u0026hellip; ü§¶\nDe t√£o deprimente as vezes d√° vontade de ficar trancado no banheiro, chorando encolhido e ouvindo Linkin Park.\nEspero que essa historinha sirva pra explicar o motivo de tantos artigos deste blog come√ßarem com esse discurso de \u0026ldquo;isso mudou minha vida\u0026rdquo; e de \u0026ldquo;antecipe os problemas antes de colocar seu c√≥digo em produ√ß√£o\u0026rdquo;.\nAcredite em mim, n√£o √© sensacionalismo. üòá\nConhecendo o shellcheck Voc√™ pode ver o shellcheck em a√ß√£o agora mesmo!\nObserve o c√≥digo abaixo e observe que √© um c√≥digo perfeitamente v√°lido. Mesmo que voc√™ observe um errinho de l√≥gica, vai notar que n√£o tem erro de sintaxe algum (o bash n√£o vai se recusar a executar este c√≥digo):\nhello() {  echo Hello $name }  hello $@ Agora copie esse c√≥digo e cole nesse site: https://www.shellcheck.net/\nVoc√™ ver√° na parte de baixo da tela algo assim:\nObserve que mesmo sendo um c√≥digo perfeitamente v√°lido, o shellcheck est√° nos apontando v√°rios problemas:\n Linha 1:  n√£o atribu√≠mos um shebang ao nosso script (num artigo anterior aprendemos por que isso nunca deve acontecer no seu script)   Linha 2:  a vari√°vel $name est√° sendo referenciada mas n√£o foi atribu√≠do valor algum a ela. em volta de vari√°veis devemos usar aspas duplas sempre   Linha 5:  mais uma vez esquecemos das aspas\u0026hellip;    Obviamente que quando voc√™ estiver codando, n√£o vai ficar copiando e colando seu c√≥digo numa p√°gina da web o tempo todo. Portanto vamos instalar o shellcheck na nossa m√°quina.\nInstala√ß√£o Se voc√™ est√° usando uma distro baseada no Debian:\nsudo apt-get install shellcheck Outros m√©todos tamb√©m podem ser encontrados no README do projeto (eu particularmente instalei com o asdf-vm)\nExecutando o shellcheck N√£o tem mist√©rio, basta fazer shellcheck script.sh.\nVamos ver com mais um script ilustrativo:\n#!/usr/bin/env bash # remove-spaces.sh # # SCRIPT MERAMENTE ILUSTRATIVO! # # remove espa√ßos do nome dos arquivos .mp3  directory=\u0026#34;$1\u0026#34;  for file in \u0026#34;$directory/*.mp3\u0026#34;; do  mv -v \u0026#34;${file}\u0026#34; \u0026#34;${file// /_}\u0026#34; done Mais uma vez, um script perfeitamente v√°lido. Vamos ent√£o executar o shellcheck e ver o que ele vai dizer:\n$ shellcheck remove-spaces.sh  In remove-spaces.sh line 6:  for file in \u0026#34;$directory/*.mp3\u0026#34;; do  ^----------------^ SC2066 (error): Since you double quoted this, it will not word split, and the loop will only run once.  For more information:  https://www.shellcheck.net/wiki/SC2066 -- Since you double quoted this, it ... Eita! Parece que exageramos no alcance das aspas duplas ali\u0026hellip;\nIndo direto ao ponto, o shellcheck est√° tentando nos dizer que como o * est√° dentro das aspas, aquele *.mp3 n√£o vai expandir para o nome dos arquivos .mp3 que temos naquele diret√≥rio. Ele tentar√° procurar um arquivo literalmente chamado *.mp3 (asterisco ponto mp3).\nNo README do shellcheck tem uma galeria de c√≥digo ruim, com uma lista de c√≥digos problem√°ticos que podem at√© ser constru√ß√µes v√°lidas para o shell, mas que n√£o √© exatamente o que voc√™ quer.\nShellCheck wiki Uma das coisas mais fant√°sticas do shellcheck n√£o √© nem o fato dele ficar jogando na nossa cara que nosso script est√° cheio de problemas. O mais legal √© que ele nos diz por que o c√≥digo √© problem√°tico e tamb√©m como melhorar.\nObserve a √∫ltima linha da sa√≠da do shellcheck que executamos anteriormente:\nFor more information:  https://www.shellcheck.net/wiki/SC2066 -- Since you double quoted this, it ... Se dermos uma olhadinha naquele link, veremos o motivo pelo qual essa constru√ß√£o √© problem√°tica e tamb√©m o que devemos fazer para obter o resultado que queremos com um c√≥digo mais robusto.\nNo nosso exemplo aqui, bastaria usar \u0026quot;$directory\u0026quot;/*.mp3 (fechar as aspas logo ap√≥s o nome da vari√°vel).\nAgora e gostaria muito de enfatizar que o wiki do shellcheck √© uma fonte valios√≠ssima de conhecimento sobre shell scripting. Principalmente sobre as principais armadilhas programa√ß√£o shell.\nFa√ßa esse teste: rode o shellcheck num script qualquer que voc√™ tem a√≠ √† m√£o e gaste um tempinho lendo os alertas e as p√°ginas que o shellcheck recomenda.\nTenho certeza que voc√™ vai, tipo ü§Ø \u0026ldquo;Wow! Nunca tinha parado pra pensar nisso!\u0026rdquo;\nBom\u0026hellip; pelo menos foi isso que aconteceu comigo.\nFazendo esse simples exerc√≠cio de rodar o shellcheck em alguns dos meus scripts eu aprendi coisas como:\n  Devemos sempre verificar se um cd terminou com sucesso (SC2164) - dica: deixar o seu bash mais rigoroso j√° resolve esse problema.\n  Em um rm, devemos tomar muito cuidado com vari√°veis que fazem refer√™ncia a um diret√≥rio, pois isso pode trazer consequ√™ncias catastr√≥ficas. Exemplo: em um rm -rf \u0026quot;$tmpdir\u0026quot;/*, se a vari√°vel $tmpdir estiver vazia, isso vai virar um rm -rf /*. Seguindo a orienta√ß√£o do shellcheck (SC2115), dever√≠amos usar ${tmpdir:?}, pois isso far√° o comando falhar se a vari√°vel estiver vazia.\n  Devemos sempre deixar expl√≠cito o caminho relativo quando queremos referenciar arquivos usando o * asterisco (SC2155). Assim evitamos que um nome de arquivo se torne uma op√ß√£o para o comando. Exemplo: imagine o transtorno causado por um arquivo chamado -rf quando voc√™ usando o comando rm *.\n  Estes üëÜ foram apenas alguns exemplos de coisas que aprendi rodando o shellcheck em scripts antigos. Gaste um tempinho fazendo isso e n√£o se arrepender√°.\nE se eu discordar do shellcheck? Podem haver situa√ß√µes onde n√£o concordamos com o diagn√≥stico do shellcheck e queremos ignorar certas coisas que ele considera problem√°tica.\nUm exemplo cl√°ssico pra mim √© essa estrat√©gia que eu sempre uso para saber em que diret√≥rio o meu script est√° armazenado:\n#!/usr/bin/env bash # example.sh  # maneira infal√≠vel de saber o diret√≥rio do seu script export SCRIPTS_DIR=\u0026#34;$(  cd \u0026#34;$(dirname -- \u0026#34;${BASH_SOURCE}\u0026#34;)\u0026#34; \u0026amp;\u0026amp; pwd )\u0026#34; Agora vejamos o que o shellcheck tem a nos dizer:\n$ shellcheck example.sh  In example.sh line 5: export SCRIPTS_DIR=\u0026#34;$(  ^---------^ SC2155 (warning): Declare and assign separately to avoid masking return values.   In example.sh line 6:  cd \u0026#34;$(dirname -- \u0026#34;${BASH_SOURCE}\u0026#34;)\u0026#34; \u0026amp;\u0026amp; pwd  ^------------^ SC2128 (warning): Expanding an array without an index only gives the first element.  For more information:  https://www.shellcheck.net/wiki/SC2128 -- Expanding an array without an ind...  https://www.shellcheck.net/wiki/SC2155 -- Declare and assign separately to ... No primeiro alerta ele est√° falando que eu deveria declarar SCRIPTS_DIR primeiro, e depois atribuir um valor.\nEste alerta serve para chamar a aten√ß√£o para situa√ß√µes como essa:\n$ export var=$(comando invalido) \u0026amp;\u0026amp; echo sucesso || echo falha comando: command not found sucesso $ $ # o export acima üëÜ finalizou com sucesso, $ # mesmo se o comando dentro do $() falhou. OK, isso realmente pode ser problem√°tico. Mas eu tenho certeza que no caso espec√≠fico daquele meu c√≥digo eu n√£o terei problemas. Portanto eu quero que o shellcheck ignore essa \u0026ldquo;regra\u0026rdquo;.\nComo podemos ver no output do shellcheck, a regra √© identificada pelo ID SC2155. Vamos ent√£o desabilit√°-la.\nUma maneira de fazer isso √© ir na linha acima do problema e adicionar um coment√°rio assim:\n# shellcheck disable=2155 Pronto! Agora se voc√™ rodar o shellcheck de novo ele n√£o vai mais reclamar disso.\nS√≥ que ainda temos o outro alerta, me avisando eu estou referenciando um array, ${BASH_SOURCE}, sem especificar o √≠ndice, e que isso vai me retornar apenas o primeiro elemento.\nEntendo que esse √© um alerta √∫til quando usamos arrays em constru√ß√µes do tipo for var in \u0026quot;${myArray}\u0026quot;, onde eu estou esperando obter todos os valores do array. Mas neste meu uso espec√≠fico aqui, eu tenho certeza que o primeiro elemento do ${BASH_SOURCE} √© exatamente o que eu quero.\nPortanto, vamos ignorar a regra SC2128, adicionando o n√∫mero dela naquele mesmo coment√°rio, separando com uma v√≠rgula.\n# shellcheck disable=2155,2128 export SCRIPTS_DIR=\u0026#34;$(  cd \u0026#34;$(dirname -- \u0026#34;${BASH_SOURCE}\u0026#34;)\u0026#34; \u0026amp;\u0026amp; pwd )\u0026#34; Pronto! Agora o shellcheck n√£o vai mais encrencar com esse macetinho bastante √∫til.\nExistem outras maneiras de ignorar estas regras. Esta p√°gina da documenta√ß√£o mostra v√°rias delas. Eu geralmente uso uma dessas aqui:\n criando um arquivo .shellcheckrc na raiz do projeto (requer shellcheck 0.7+) inserindo um coment√°rio pra desabilitar a regra no topo do arquivo (abaixo do shebang, claro!) inserindo um coment√°rio pra desabilitar a regra na linha acima do c√≥digo problem√°tico.  Indo al√©m Nesta se√ß√£o coloco um conte√∫do um pouquinho mais avan√ßado, mostrando v√°rias situa√ß√µes onde eu uso o shellcheck e como isso torna minha vida mais f√°cil. üôÇ\nSe voc√™ est√° apenas iniciando no shellscript, n√£o se preocupe se n√£o entender tudo\u0026hellip; S√≥ de voc√™ se preocupar em rodar um shellcheck nos seus scripts eu te garanto que voc√™ est√° no caminho correto!\nIntegre shellcheck com o seu editor J√° entendemos que o shellcheck √© bem bacana e nos ajuda a antecipar muitos problemas. Mas se nos atentarmos um pouquinho vamos perceber que mais uma vez acabaremos entrando na repeti√ß√£o do ciclo escrever-salvar-testar.\nMesmo que o relat√≥rio do shellcheck seja bem √∫til e isso v√° minimizar a quantidade de ciclos escrever-salvar-testar, ainda assim podemos melhorar. Podemos integrar o shellcheck no nosso editor de texto!\nO README do shellcheck lista links para v√°rias maneiras de fazer isso em diversos editores, vou mostrar aqui apenas 3 deles.\nPr√©-requisito: voc√™ precisa ter o shellcheck j√° devidamente instalado na sua m√°quina.\nVSCode N√£o tem complica√ß√£o alguma, simplesmente abra o VSCode, v√° na se√ß√£o de plugins, procure por ShellCheck, e instale (repito: voc√™ ainda precisa ter o shellcheck j√° instalado na sua m√°quina).\nE pronto! Agora voc√™ ser√° alertado sobre problemas no seu c√≥digo a medida que est√° escrevendo.\nvim / Syntastic OBS.: Se voc√™ n√£o usa vim, pode pular essa parte.\nEu sou um grande f√£ do vim (atualmente em processo de migra√ß√£o para o neovim), e frequentemente estou no terminal codando meus scripts nessa delicinha de software.\nApesar de existirem v√°rias maneiras de integrar shellcheck com o vim, vou focar aqui no uso do Syntastic, pois atualmente foi o que eu achei que fez mais sentido pra mim (pode ser que eu mude de ideia no futuro).\nEu costumo administrar os plugins do meu vim usando o vim-plug (explicar como instalar/utilizar o vim-plug est√° fora do escopo desse texto, confira a documenta√ß√£o).\nInstalando o Syntastic no meu ~/.vimrc:\n\u0026#34; isso s√≥ vai funcionar se voc√™ tiver\u0026#34; o vim-plug devidamente instaladocall plug#begin()\u0026#34; syntastic para integrar vim com shellcheckPlug \u0026#39;vim-syntastic/syntastic\u0026#39;call plug#end()\u0026#34; configura√ß√µes recomendadas pelo Syntastic\u0026#34; https://github.com/vim-syntastic/syntastic#settingslet g:syntastic_always_populate_loc_list = 1let g:syntastic_auto_loc_list = 1let g:syntastic_check_on_open = 1let g:syntastic_check_on_wq = 0Depois de salvar o arquivo basta mandar um :PlugInstall (que √© um comando do vim-plug).\nEssa config vai ser suficiente para que quando voc√™ salvar o seu script, os erros j√° apare√ßam numa janelinha na parte de baixa da tela:\nPra voc√™ ir de uma mensagem de erro para a seguinte, use o comando :lnext, e pra voltar :lprevious.\nComo ficar digitando isso √© meio tedioso, eu criei um atalhozinho no meu ~/.vimrc\n\u0026#34; eu uso espa√ßo como meu \u0026#34;leaderkey\u0026#34;let mapleader = \u0026#34;\\\u0026lt;Space\u0026gt;\u0026#34;\u0026#34; pula para o erro seguinte/anterior\u0026#34; (√∫til para usar com syntastic/shellcheck)map \u0026lt;leader\u0026gt;ne :lnext\u0026lt;cr\u0026gt; \u0026#34; ne = Next Errormap \u0026lt;leader\u0026gt;pe :lprevious\u0026lt;cr\u0026gt; \u0026#34; pe = Previous ErrorAgora quando eu salvo o arquivo e shellcheck me mostra os erros, eu posso alterna entre eles usando \u0026lt;space\u0026gt;ne e \u0026lt;space\u0026gt;pe (eu memorizo como ne significando \u0026ldquo;Next Error\u0026rdquo;, e pe para \u0026ldquo;Previous Error\u0026rdquo;).\nComo eu disse, essas configura√ß√µes s√≥ fazem sentido para quem j√° est√° familiarizado com vim e gerenciamento de plugins.\nGeany O companheiro Blau Araujo me informou que o Geany j√° tem uma integra√ß√£o com o shellcheck e √© automaticamente dispon√≠vel se voc√™ abre um arquivo de shell script.\nPara fazer o Geany analisar seu script, basta ir no menu Construir -\u0026gt; Lint.\nUse um git hook para impedir commit de c√≥digo problem√°tico Se voc√™ trabalha sozinho num projeto, integrar o shellcheck no seu editor pode ser suficiente. Mas se voc√™ trabalha com mais pessoas, precisamos tomar alguns cuidados adicionais.\nUma coisa que eu costumo fazer nos projetos que trabalho √© criar um scriptzinho pra rodar o shellcheck em todos os arquivos *.sh do reposit√≥rio. E a√≠ oriento o pessoal a utilizar esse script como um git hook de pre-commit.\nUm git hook de pre-commit nada mais √© que um script que ser√° executado imediatamente ap√≥s voc√™ enviar um comando git commit, por√©m antes desse commit ser efetivamente realizado. Se o script falhar, o commit n√£o √© realizado.\nNo diret√≥rio onde est√° o reposit√≥rio local do seu projeto, voc√™ tem um diret√≥rio chamado .git/. Dentro deste diret√≥rio tem um outro chamado hooks/. √â ali que ficam os git hooks.\nO script abaixo, deve ser colocado dentro do arquivo .git/hooks/pre-commit e deve ser execut√°vel:\n#!/usr/bin/env bash # git-hook-pre-commit.sh ######################## # # COMO UTILIZAR: # # $ cat git-hook-pre-commit.sh \u0026gt; .git/hooks/pre-commit # $ chmod a+x .git/hooks/pre-commit  main() {  git ls-files \\  --exclude=\u0026#39;*.sh\u0026#39; \\  --ignored \\  --cached \\  -z \\  | xargs -0r shellcheck }  main Pronto! Fazendo isso corretamente, o pr√≥prio git agora vai te informar se o seu c√≥digo est√° problem√°tico toda hora que voc√™ tentar fazer um git commit. E o que √© melhor, o commit n√£o ser√° realizado enquanto voc√™ n√£o tratar o problema.\nCrie uma pipeline para checagem de c√≥digo Imagine que voc√™ est√° trabalhando num projeto com outras pessoas.\nVoc√™ √© um cara que se importa com a qualidade do seu c√≥digo! Voc√™ instala shellcheck na sua m√°quina, integra com seu editor, usa um git hook de pre-commit pra n√£o enviar c√≥digo bugado pro reposit√≥rio\u0026hellip; Mas a√≠ pode acontecer um commit de um colaborador que est√° cagando pra tudo isso ainda n√£o aprendeu a import√¢ncia de mantermos um c√≥digo livre de bugs e potenciais problemas.\nPara que possamos ter esse controle no nosso reposit√≥rio tamb√©m, podemos criar uma pipeline que varre nosso c√≥digo em busca de problemas.\nNo wiki do shellcheck tem algumas dicas para integrar a ferramenta em v√°rias plataformas de integra√ß√£o cont√≠nua. Como eu trabalho com gitlab-ci, no meu caso ficaria um job assim:\nstages:  - shellcheck  # - outros est√°gios...  shellcheck:  image: koalaman/shellcheck-alpine:latest  stage: shellcheck  script:  - apk add --upgrade git  - git ls-files --exclude=\u0026#39;*.sh\u0026#39; --ignored -c -z | xargs -0r shellcheck E a√≠ coloco esse job para ser executado sempre que algu√©m commitar algo no reposit√≥rio.\nA√≠ agora quando entro na p√°gina principal projeto no gitlab, j√° bato o olho na bolinha que aparece ali pra mostrar o status da √∫ltima pipeline. A√≠ posso ver como que √© bom trabalhar com uma equipe que s√≥ tem fera:\nS√≥ que de vez em quando vejo situa√ß√µes como essa:\nComo eu disse, d√° pra integrar o shellcheck com outras plataformas de CI. Se voc√™ trabalha com outro tipo de esteira, vale a pena dar uma conferida na documenta√ß√£o do shellcheck\nConclus√£o Uau! Esse artigo ficou extenso! ü•µ\nVou terminar fazendo um apelo: PELAMORDEDEUS, use shellcheck.\nBenef√≠cios:\n voc√™ ser√° mais feliz seu time ser√° mais feliz ningu√©m vai te acordar de madrugada pra resolver pepinos causados pelos seus scripts bugados pessoas v√£o gostar do seu c√≥digo e v√£o contribuir com seus projetos open source seu reposit√≥rio vai ganhar mais estrelinhas o amor da sua vida vai voltar pra voc√™  S√≥ coisa boa! üôÇ\nCom este artigo aqui eu encerro a s√©rie \u0026ldquo;pr√°ticas de programa√ß√£o shell que mudar√£o sua vida\u0026rdquo;.\nS√≥ pra lembrar:\n deixe seu bash mais rigoroso use um trap para saber exatamente onde seu script quebrou use o shellcheck  Mano, se voc√™ seguir essas 3 pr√°ticas, te garanto que ser√° bem sucedido na sua carreira de programador shell.\n","permalink":"https://meleu.sh/shellcheck/","summary":"Este artigo √© parte da s√©rie \u0026ldquo;Pr√°ticas de programa√ß√£o shell que mudar√£o sua vida\u0026rdquo;\nOs artigos da s√©rie s√£o:\n deixe seu bash mais rigoroso use um trap para saber exatamente onde seu script quebrou use o shellcheck   N√≥s amamos programar, n√£o √© mesmo? (se voc√™ est√° lendo esse blog, eu imagino que sim). Mas convenhamos, quando chegamos naquele ponto onde fazer uma simples altera√ß√£o envolve ficar continuamente alternando entre escrever-salvar-testar\u0026hellip; Tem hora que enche o saco!","title":"Use shellcheck e livre-se dos bugs no seu c√≥digo antes mesmo de execut√°-lo"},{"content":"Neste artigo conheceremos uma maneira limpa de gerenciar seus dotfiles usando apenas o git.\nN√£o ser√° necess√°ria ferramenta adicional alguma, voc√™ n√£o precisar√° instalar nada, nem criar links simb√≥licose e nem escrever script algum. Tudo que precisamos √© pura e simplesmente o git.\nComo resultado da t√©cnica descrita aqui, voc√™ ter√° um reposit√≥rio dotfiles refletindo exatamente a estrutura de diret√≥rios e localiza√ß√£o dos arquivos que deve estar em seu homedir.\nN√£o quero ler isso tudo! Me diz logo o que tenho que fazer! Se voc√™ j√° tem s√≥lidos conhecimento sobre como o git funciona e n√£o quer ler todas as explica√ß√µes que dou, pode pular direto para o resumo.\nMotiva√ß√£o Armazenar seus dotfiles em um reposit√≥rio git (e deix√°-lo open source em um reposit√≥rio p√∫blico) proporciona as seguintes vantagens:\n backup \u0026ldquo;na nuvem\u0026rdquo;: Todas aquelas suas customiza√ß√µes minuciosas e caprichadas que voc√™ fez estaram facilmente acess√≠veis de outras m√°quinas que voc√™ for come√ßar usar. aprendizado: bisbilhotando üëÄ os dotfiles de outras pessoas voc√™ aprende v√°rios truquezinhos bacanas que facilitam sua vida. E se voc√™ deixa seus dotfiles open-source, a comunidade tamb√©m vai aprender quais s√£o os seus truques.  Caso queira bisbilhotar os meus dotfiles, aqui est√°: https://github.com/meleu/.dotfiles\n‚ö† ATEN√á√ÉO Se voc√™ salva qualquer tipo de informa√ß√£o sens√≠vel em seus dotfiles (ex.: senha, tokens, emails, etc.), tome cuidado para n√£o tornar essas informa√ß√µes p√∫blicas.\nSe por um acaso voc√™ acidentalmente commitou alguma informa√ß√£o sens√≠vel, recomendo uma lida nesse artigo do site do github: Remover dados confidenciais do reposit√≥rio.\nIniciando seu reposit√≥rio dotfiles Crie seu reposit√≥rio remoto O primeiro passo √© criar o seu reposit√≥rio remoto. Eu recomendo fortemente que voc√™ deixe seu reposit√≥rio p√∫blico. Desta forma voc√™ pode compartilhar seu conhecimento com a comunidade e com os seus colegas, pode ensinar e aprender muito.\nV√° no seu github, gitlab, ou seu webservice de git favorito e crie um reposit√≥rio chamado dotfiles.\nObserv√ß√£o: crie seu diret√≥rio completamente vazio (sem README, sem LICENSE, etc.)\nCrie seu reposit√≥rio local Neste exemplo vou considerar que voc√™ criou o reposit√≥rio no github. Portanto, se voc√™ est√° usando outros servi√ßos, fa√ßa as adapta√ß√µes necess√°rias nos comandos a seguir.\n# s√≥ pra garantir... username=\u0026#39;COLOQUE_SEU_USERNAME_AQUI\u0026#39;  # v√° para o home e crie o diret√≥rio \u0026#34;dotfiles\u0026#34; cd ~ mkdir dotfiles  # entre no diret√≥rio e inicie um reposit√≥rio git cd ~/dotfiles git init  # v√° no github e pegue o endere√ßo SSH do seu  # reposit√≥rio \u0026#39;dotfiles\u0026#39;. Copie aquele endere√ßo # e configure o seu repo local. git remote add origin git@github.com:${username}/dotfiles.git Segredo #1: customize seu worktree Esse √© o \u0026ldquo;pulo do gato\u0026rdquo; que vai tornar desnecess√°rio que voc√™ instale qualquer software, crie links simb√≥licos, ou escreva scripts\u0026hellip;\nO que vamos fazer aqui √© dizer para o nosso reposit√≥rio local, que o diret√≥rio que ele tem que monitorar est√° em outro lugar.\nVamos fazer isso da seguinte forma:\n# certifique-se que est√° no diret√≥rio do seu repo cd ~/dotfiles  # diga ao git pra monitorar os arquivos no seu homedir git config core.worktree \u0026#39;../../\u0026#39; Motivo pelo qual estamos usando ../../: pois esse caminho √© relativo ao diret√≥rio ~/dotfiles/.git. Portanto, se queremos apontar para o homedir, temos que subir dois n√≠veis.\nIsso far√° com que o seu repo dotfiles passe a monitorar TODOS os arquivos do seu homedir. üò±\nPara contornar isso, vamos para o segundo segredo\u0026hellip;\nSegredo #2: ignore tudo! Nosso arquivo .gitignore ter√° apenas um byte: *\n# ignore a p*rr@ toda echo \u0026#39;*\u0026#39; \u0026gt; ~/.gitignore Note que o .gitignore PRECISA estar no seu homedir.\nAgora que voc√™ est√° gitignorando tudo, basta voc√™ adicionar os arquivos que voc√™ quer usando a For√ßa Jedi com -f:\n# esses comandos precisam ser executados de # dentro do diret√≥rio ~/dotfiles/ cd ~/dotfiles  # observa√ß√µes: # - como estamos gitignorando tudo, use \u0026#39;-f\u0026#39; # - como estamos em ~/dotfiles, precisamos do \u0026#39;../\u0026#39; git add -f ../.bashrc git add -f ../.vimrc # etc...  # commit \u0026amp; push git commit -m \u0026#39;upando meus dotfiles\u0026#39; git push Lembre-se:\n para usar os comandos git no seu reposit√≥rio, voc√™ precisa estar dentro do ~/dotfiles/ para adicionar arquivos novos, voc√™ precisa usar git add -f voc√™ precisar√° referenciar os arquivos levando em considera√ß√£o que o worktree foi customizado. No nosso caso aqui, voc√™ ter√° que usar algo assim git add -f ../${arquivo} uma vez que o arquivo √© adicionado, voc√™ n√£o precisa mais usar o -f no git add futuramente.  E pronto! Seus dotfiles j√° est√£o num reposit√≥rio git!\nRecuperando seus dotfiles em uma outra m√°quina Para recuperar os nossos dotfiles de maneira limpa, vamos usar o terceiro segredo. Esse √© o segredinho que torna desnecess√°rias todas aquelas ferramentas de gerenciar links simb√≥licos ou escrita de scripts para colocar os dotfiles nos lugares corretos.\nSegredo #3: git clone sem checkout Por padr√£o, quando clonamos um reposit√≥rio remoto, o git automaticamente j√° faz checkout dos arquivos e coloca no diret√≥rio criado ao clonar o repo remoto.\nMas como n√≥s queremos fazer checkout dos arquivos diretamente no nosso homedir, vamos fazer o seguinte:\n# certifique-se que est√° no homedir cd ~  # use o --no-checkout para n√£o fazer checkout # dos arquivos dentro diret√≥rio que ser√° criado git clone --no-checkout git@github.com:${username}/dotfiles.git  # entre no reposit√≥rio rec√©m criado cd ~/dotfiles  # diga ao git pra monitorar os arquivos no seu homedir git config core.worktree \u0026#39;../../\u0026#39;  # agora fazemos o checkout dos arquivos # diretamente no nosso homedir # ‚ö† aten√ß√£o! ‚ö† arquivos locais ser√£o sobrescritos git reset --hard origin/master ATEN√á√ÉO: ao usar o git reset --hard, seus dotfiles locais da m√°quina ser√£o sobrescritos com o conte√∫do que est√° vindo do seu reposit√≥rio remoto. Geralmente √© exatamente isso que queremos, mas de qualquer forma achei por bem ressaltar. üòá\nE pronto! √â s√≥ isso! Agora voc√™ j√° pode compartilhar seus dotfiles com seus colegas, amigos e com a comunidade em geral.\nResumo # crie um repo remoto chamado \u0026#34;dotfiles\u0026#34; # (tanto faz se √© github, gitlab, etc.)  # s√≥ pra garantir... username=\u0026#39;COLOQUE_SEU_USERNAME_AQUI\u0026#39;  # v√° para o home e crie o diret√≥rio \u0026#34;dotfiles\u0026#34; cd ~ mkdir dotfiles  # entre no diret√≥rio e inicie um reposit√≥rio git cd ~/dotfiles git init  # v√° no github e pegue o endere√ßo SSH do seu  # reposit√≥rio \u0026#39;dotfiles\u0026#39;. Copie aquele endere√ßo # e configure o seu repo local. git remote add origin git@github.com:${username}/dotfiles.git  # diga ao git pra monitorar os arquivos no seu homedir git config core.worktree \u0026#39;../../\u0026#39;  # ignore a p*rr@ toda echo \u0026#39;*\u0026#39; \u0026gt; ~/.gitignore  # observa√ß√µes: # - como estamos gitignorando tudo, use \u0026#39;-f\u0026#39; # - como estamos em ~/dotfiles, precisamos do \u0026#39;../\u0026#39; git add -f ../.bashrc git add -f ../.vimrc # etc...  # commit \u0026amp; push git commit -m \u0026#39;upando meus dotfiles\u0026#39; git push Recuperando os arquivos em outra m√°quina:\n# certifique-se que est√° no homedir cd ~  # use o --no-checkout para n√£o fazer checkout # dos arquivos dentro diret√≥rio que ser√° criado git clone --no-checkout git@github.com:${username}/dotfiles.git  # entre no reposit√≥rio rec√©m criado cd ~/dotfiles  # diga ao git pra monitorar os arquivos no seu homedir git config core.worktree \u0026#39;../../\u0026#39;  # agora fazemos o checkout dos arquivos # diretamente no nosso homedir # ‚ö† aten√ß√£o! ‚ö† arquivos atuais ser√£o sobrescritos git reset --hard origin/master B√¥nus Se voc√™ quer uma maneira r√°pida de sincronizar seus dotfiles com o reposit√≥rio remoto, eis a fun√ß√£o que eu uso:\n# .files(): sincroniza seus dotfiles com o repo remoto. # OBS.: o uso de (par√™nteses) no lugar de {chaves} √©  # intencional e serve para que n√£o seja necess√°rio # fazer um `cd` pra voltar para o diret√≥rio anterior .files() (  local dotfilesDir=\u0026#34;${HOME}/dotfiles\u0026#34;  local gitStatus   cd \u0026#34;${dotfilesDir}\u0026#34;   gitStatus=\u0026#34;$(git status --porcelain)\u0026#34;   if [[ -z \u0026#34;${gitStatus}\u0026#34; ]]; then  warn \u0026#34;dotfiles: nothing to update\u0026#34;  return 0  fi   git add --all \\  \u0026amp;\u0026amp; git status \\  \u0026amp;\u0026amp; git commit -m \u0026#34;update $(date +\u0026#39;%Y-%m-%d %R\u0026#39;): ${gitStatus}\u0026#34; \\  \u0026amp;\u0026amp; git pull --rebase \\  \u0026amp;\u0026amp; git push ) Eu coloco essa fun√ß√£o no meu ~/.bash_functions, que √© chamado pelo meu ~/.bashrc. Desta forma, quando quero sincronizar com o repo remoto eu simplesmente executo .files (isso mesmo, \u0026ldquo;ponto faious\u0026rdquo;).\nSe quer mais inspira√ß√£o. Confira meus dotfiles: https://github.com/meleu/.dotfiles\nFontes  gitignore \u0026ldquo;a p*rr@ toda\u0026rdquo;: https://drewdevault.com/2019/12/30/dotfiles.html truquezinho do worktree: https://www.wangzerui.com/2017/03/06/using-git-to-manage-system-configuration-files/ v√°rios artigos sobre gerenciamento de dotfiles: https://dotfiles.github.io/ Documenta√ß√£o do github sobre como Remover dados confidenciais do reposit√≥rio  ","permalink":"https://meleu.sh/dotfiles/","summary":"Neste artigo conheceremos uma maneira limpa de gerenciar seus dotfiles usando apenas o git.\nN√£o ser√° necess√°ria ferramenta adicional alguma, voc√™ n√£o precisar√° instalar nada, nem criar links simb√≥licose e nem escrever script algum. Tudo que precisamos √© pura e simplesmente o git.\nComo resultado da t√©cnica descrita aqui, voc√™ ter√° um reposit√≥rio dotfiles refletindo exatamente a estrutura de diret√≥rios e localiza√ß√£o dos arquivos que deve estar em seu homedir.","title":"Uma maneira limpa e inteligente de gerenciar seus dotfiles em um reposit√≥rio git"},{"content":"Voc√™ √© programador, trabalha para mais de uma empresa e tamb√©m contribui com projetos open source no github, gitlab, codeberg, etc.\nCertamente voc√™ j√° passou por aquela situa√ß√£o de fazer um commit no reposit√≥rio do trabalho usando username/email que usa nos seus projetos pessoais ou open source. Ou o que √© mais delicado, voc√™ faz um commit num reposit√≥rio p√∫blico usando seu email da empresa. E agora o hist√≥rico de commit do seu projeto Open Source agora tem seu nome real e seu email da empresa\u0026hellip; üòì\nVoc√™ que j√° √© calejado com git j√° sabe que podemos mandar um git config user.name \u0026quot;MEU_USERNAME\u0026quot; e um git config user.email \u0026quot;MEU@EMAIL.COM\u0026quot; para cada projeto individualmente. Mas se voc√™ trabalha com v√°rios reposit√≥rios, isso vai se tornar uma tarefa tediosa e certamente vai chegar um momento que voc√™ vai esquecer de fazer isso.\nVamos ver nesse artigo uma maneira bem simples de evitar esses inconvenientes usando puramente alguns recursos do git.\nPasso a passo Resumidamente, vamos fazer isso aqui:\n ter um diret√≥rio espec√≠fico para cada organiza√ß√£o que voc√™ trabalha/contribui ter um gitconfig espec√≠fico para cada organiza√ß√£o. configurar seu .gitconfig global para que ele aplique o gitconfig espec√≠fico de cada organiza√ß√£o a todos os projetos armazenados dentro do diret√≥rio da respectiva organiza√ß√£o.  Agora vamos detalhar estes passos.\nPasso 1: crie um diret√≥rio espec√≠fico para cada organiza√ß√£o Para efeitos de ilustra√ß√£o vamos considerar que queremos configurar uma conta para o github e outra para gitlab.\nEu costumo guardar meus c√≥digos em ~/src/, portanto eu criaria um diret√≥rio para cada organiza√ß√£o da seguinte forma:\n# cria um diret√≥rio para cada organiza√ß√£o mkdir -p ~/src/github mkdir -p ~/src/gitlab Passo 2: crie um gitconfig para cada organiza√ß√£o Agora vamos criar um arquivo gitconfig dentro de cada um dos diret√≥rios que criamos anteriomente (eu prefiro deixar o arquivo vis√≠vel, se quiser ocultar basta nome√°-los como .gitconfig).\nPrimeiramente vamos criar ~/src/github/gitconfig com o seguinte conte√∫do:\n[user] email = SEU_EMAIL@EMPRESA.COM name = SEU_USERNAME Fa√ßa a mesma coisa para o arquivo ~/src/gitlab/gitconfig.\nPasso 3: customize seu .gitconfig global Agora que j√° temos um diret√≥rio para cada organiza√ß√£o e um gitconfig em cada um desses diret√≥rios, precisamos dizer ao nosso ~/.gitconfig global o que fazer com essas coisas.\nVamos portanto abrir o nosso ~/.gitconfig (se o arquivo n√£o existir, apenas crie-o) e adicionar o seguinte conte√∫do ao final do arquivo:\n# diret√≥rio onde ficar√£o os projetos # hospedados no github [includeIf \u0026#34;gitdir:~/src/github/**\u0026#34;] path = ~/src/github/gitconfig # projetos hospedados no gitlab [includeIf \u0026#34;gitdir:~/src/gitlab/**\u0026#34;] path = ~/src/gitlab/gitconfig Se tiv√©ssemos que traduzir aquela primeira configura√ß√£o para o portugu√™s, seria algo assim:\n Se o reposit√≥rio git local estiver em qualquer subdiret√≥rio de ~/src/github/, inclua as configura√ß√µes presentes em ~/src/github/gitconfig.\n E prontinho! √â s√≥ isso!\nAgora voc√™ s√≥ precisa se certificar de clonar os reposit√≥rios nos diret√≥rios corretos de cada organiza√ß√£o. E assim o problema estar√° resolvido.\nFontes  man git config na parte entitulada \u0026ldquo;Includes\u0026rdquo;  tamb√©m dispon√≠vel online: https://www.git-scm.com/docs/git-config#_includes    ","permalink":"https://meleu.sh/git-multiconfig/","summary":"Voc√™ √© programador, trabalha para mais de uma empresa e tamb√©m contribui com projetos open source no github, gitlab, codeberg, etc.\nCertamente voc√™ j√° passou por aquela situa√ß√£o de fazer um commit no reposit√≥rio do trabalho usando username/email que usa nos seus projetos pessoais ou open source. Ou o que √© mais delicado, voc√™ faz um commit num reposit√≥rio p√∫blico usando seu email da empresa. E agora o hist√≥rico de commit do seu projeto Open Source agora tem seu nome real e seu email da empresa\u0026hellip; üòì","title":"Chega de commitar no reposit√≥rio do trabalho com seus dados do github (e vice-versa)!"},{"content":" Este artigo √© parte da s√©rie \u0026ldquo;Pr√°ticas de programa√ß√£o shell que mudar√£o sua vida\u0026rdquo;\nOs artigos da s√©rie s√£o:\n deixe seu bash mais rigoroso use um trap para saber exatamente onde seu script quebrou use o shellcheck   No artigo anterior aprendemos como fazer o nosso script falhar o mais r√°pido poss√≠vel e entedemos qual √© a grande vantagem disso. Neste artigo veremos como obter uma indica√ß√£o bem direta e precisa de onde o nosso script falhou.\nDesde que comecei a usar isso nos meus scripts (principalmente nas minhas esteiras de Integra√ß√£o Cont√≠nua) minha vida √© muito mais feliz. Isso mudou minha vida e espero que mude a sua tamb√©m! üôè\nRecapitulando\u0026hellip; S√≥ pra lembrar, no artigo anterior entendemos que devemos iniciar nossos scripts com:\nset -euo pipefail Pois queremos que o script:\n set -e: seja interrompido assim que ele falhar set -u: n√£o tolere vari√°veis sem um valor explicitamente definido set -o pipefail: o \u0026ldquo;exit status\u0026rdquo; de uma pipeline seja o status do primeiro comando que falhar (ou sucesso)  A partir desse conhecimento vamos avan√ßar um pouco mais\u0026hellip;\nN√£o quero ler tudo isso! Me diz logo o que tenho que fazer! A partir de agora use isso no in√≠cio de todos os seus scripts:\nset -Eeuo pipefail  trap \u0026#39;echo \u0026#34;${BASH_SOURCE}:${LINENO}:${FUNCNAME:-}\u0026#34;\u0026#39; ERR O tempo que voc√™ vai economizar com isso voc√™ pode usar para ler os artigos deste site. üòá\nVari√°veis √∫teis definidas pelo bash O bash por padr√£o j√° define muitas vari√°veis com utilidades espec√≠ficas. Pro nosso prop√≥sito aqui iremos utilizar as seguintes:\n BASH_SOURCE: o nome do arquivo onde est√° o seu script (na verdade esta vari√°vel √© um array, mas aqui n√≥s vamos abstrair isso) LINENO: linha exata aonde esta vari√°vel est√° sendo referenciada. FUNCNAME: nome da fun√ß√£o onde esta vari√°vel est√° sendo referenciada.  Vamos a um script ilustrativo pra explicar melhor:\n#!/usr/bin/env bash # scriptinfo.sh  # falhe r√°pido: # https://meleu.sh/bash-rigoroso set -euo pipefail  echo \u0026#34;--\u0026gt; informa√ß√µes do script \u0026lt;--\u0026#34; echo \u0026#34;BASH_SOURCE=\u0026#39;${BASH_SOURCE}\u0026#39;\u0026#34; echo \u0026#34;LINENO=\u0026#39;${LINENO}\u0026#39;\u0026#34; echo \u0026#34;FUNCNAME=\u0026#39;${FUNCNAME}\u0026#39;\u0026#34; echo echo \u0026#34;fim!\u0026#34; Executando:\n$ ./scriptinfo.sh --\u0026gt; informa√ß√µes do script \u0026lt;-- BASH_SOURCE=\u0026#39;./scriptinfo.sh\u0026#39; LINENO=\u0026#39;10\u0026#39; ./scriptinfo.sh: line 11: FUNCNAME: unbound variable Oops!! üò≥\nOK, entendemos que BASH_SOURCE trouxe o nome do script, e que o LINENO trouxe o n√∫mero exato da linha do script onde ele foi referenciado. Mas e aquele erro ali na linha 11?\nEsse erro aconteceu porque l√° no come√ßo do script dissemos ao bash que queremos que ele quebre sempre que encontrar uma vari√°vel sem um valor definido (set -u, aprendemos essa t√©cnica no artigo anterior). E como estamos chamando a vari√°vel FUNCNAME fora de uma fun√ß√£o, ela est√° vazia.\nPara contornar isso atribuindo uma string vazia como valor default mas tamb√©m vamos adicionar uma fun√ß√£o ao script s√≥ pra ver a vari√°vel funcionando de verdade:\n#!/usr/bin/env bash # script2.info  # falhe r√°pido: # https://meleu.sh/bash-rigoroso set -euo pipefail  echo \u0026#34;--\u0026gt; informa√ß√µes de fora da fun√ß√£o \u0026lt;--\u0026#34; echo \u0026#34;BASH_SOURCE=\u0026#39;${BASH_SOURCE}\u0026#39;\u0026#34; echo \u0026#34;LINENO=\u0026#39;${LINENO}\u0026#39;\u0026#34; echo \u0026#34;FUNCNAME=\u0026#39;${FUNCNAME:-}\u0026#39;\u0026#34; echo  main() {  echo \u0026#34;--\u0026gt; informa√ß√µes de dentro da fun√ß√£o \u0026lt;--\u0026#34;  echo \u0026#34;BASH_SOURCE=\u0026#39;${BASH_SOURCE}\u0026#39;\u0026#34;  echo \u0026#34;LINENO=\u0026#39;${LINENO}\u0026#39;\u0026#34;  echo \u0026#34;FUNCNAME=\u0026#39;${FUNCNAME:-}\u0026#39;\u0026#34;  echo  echo \u0026#34;fim!\u0026#34; }  main \u0026#34;$@\u0026#34; Executando:\n$ ./scriptinfo2.sh --\u0026gt; informa√ß√µes de fora da fun√ß√£o \u0026lt;-- BASH_SOURCE=\u0026#39;./scriptinfo2.sh\u0026#39; LINENO=\u0026#39;10\u0026#39; FUNCNAME=\u0026#39;\u0026#39;  --\u0026gt; informa√ß√µes de dentro da fun√ß√£o \u0026lt;-- BASH_SOURCE=\u0026#39;./scriptinfo2.sh\u0026#39; LINENO=\u0026#39;17\u0026#39; FUNCNAME=\u0026#39;main\u0026#39;  fim! Bacana, n√£o √© mesmo?! ü§ì\nAgora que entendemos a utilidade dessas vari√°veis, vamos dar uma pausa pra falar do trap\u0026hellip;\nO comando trap O trap serve para \u0026ldquo;capturar\u0026rdquo; um sinal que o bash acabou de receber e executar algum comando quando esse sinal for capturado.\nA sintaxe dele √© assim:\ntrap COMANDO SINAL N√£o est√° no escopo desse artigo entrar no detalhe de como signal handling funciona, portanto vamos a uma breve explica√ß√£o com exemplos.\nLista de sinais Primeiro vamos ver a lista de sinais com o comando trap -l:\n$ trap -l  1) SIGHUP 2) SIGINT 3) SIGQUIT 4) SIGILL 5) SIGTRAP  6) SIGABRT 7) SIGBUS 8) SIGFPE 9) SIGKILL 10) SIGUSR1 11) SIGSEGV 12) SIGUSR2 13) SIGPIPE 14) SIGALRM 15) SIGTERM 16) SIGSTKFLT 17) SIGCHLD 18) SIGCONT 19) SIGSTOP 20) SIGTSTP 21) SIGTTIN 22) SIGTTOU 23) SIGURG 24) SIGXCPU 25) SIGXFSZ 26) SIGVTALRM 27) SIGPROF 28) SIGWINCH 29) SIGIO 30) SIGPWR 31) SIGSYS 34) SIGRTMIN 35) SIGRTMIN+1 36) SIGRTMIN+2 37) SIGRTMIN+3 38) SIGRTMIN+4 39) SIGRTMIN+5 40) SIGRTMIN+6 41) SIGRTMIN+7 42) SIGRTMIN+8 43) SIGRTMIN+9 44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13 48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12 53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9 56) SIGRTMAX-8 57) SIGRTMAX-7 58) SIGRTMAX-6 59) SIGRTMAX-5 60) SIGRTMAX-4 61) SIGRTMAX-3 62) SIGRTMAX-2 63) SIGRTMAX-1 64) SIGRTMAX Essa lista nos mostra o n√∫mero do sinal e o seu nome. Ao referenciarmos estes sinais no trap podemos usar o n√∫mero, o nome, ou o nome sem o prefixo SIG. Exemplo: 2, SIGINT e INT tem o mesmo significado.\nCapturando o Ctrl-c Quando voc√™ tecla Ctrl-c, por exemplo, pra cancelar a execu√ß√£o de um script, o bash recebe o sinal SIGINT.\nVejamos o seguinte script:\n#!/usr/bin/env bash # ctrlc.sh  # o trap vai \u0026#34;capturar\u0026#34; o SIGINT, e ao inv√©s de # interromper o script, vai executar um comando trap \u0026#39;echo \u0026#34;Voc√™ pressionou \u0026lt;Ctrl-c\u0026gt;!\u0026#34;\u0026#39; INT  echo \u0026#34;ü•± - Que soninho... Vou dormir por 10 minutos.\u0026#34; echo \u0026#34;Se precisar de mim, pressione \u0026lt;Ctrl-c\u0026gt;\u0026#34; echo \u0026#34;üò¥\u0026#34;  sleep 600  echo \u0026#34;ü•¥ - Acordei!\u0026#34; Executando:\n$ ./ctrlc.sh ü•± - Que soninho... Vou dormir por 10 minutos. Se precisar de mim, pressione \u0026lt;Ctrl-c\u0026gt; üò¥ ^CVoc√™ pressionou \u0026lt;Ctrl-c\u0026gt;! ü•¥ - Acordei! Observe que como o trap capturou o SIGINT gerado pelo Ctrl-c, executou um echo e o script prosseguiu. Ou seja, o Ctrl-c n√£o interrompeu a execu√ß√£o do script.\nPonto de aten√ß√£o Lembre-se da sintaxe do trap:\ntrap COMANDO SINAL O COMANDO pode ser qualquer comando v√°lido, mas ele precisa estar inteiro no primeiro argumento do trap.\nObserve com aten√ß√£o a linha do trap no script de exemplo:\ntrap \u0026#39;echo \u0026#34;Voc√™ pressionou \u0026lt;Ctrl-c\u0026gt;!\u0026#34;\u0026#39; SIGINT Veja como que o echo e todos os seus argumentos est√£o dentro de 'aspas simples'.\nComo sei que esse papo de aspas √© um assunto meio tortuoso pra quem n√£o usa o shell com frequ√™ncia, fica aqui o alerta.\nOs Segredos‚Ñ¢ Estou classificando o conhecimento que estou mostrando aqui como \u0026ldquo;segredo\u0026rdquo;, n√£o porque eles s√£o realmente secretos. Mas porque eles est√£o meio que espalhados pela documenta√ß√£o. E quando eu consegui \u0026ldquo;ligar os pontos\u0026rdquo; o sentimento de epifania foi grande!\nSegredo #1: set -e cria um novo sinal Essa informa√ß√£o meio que passa despercebida l√° no help do trap (aqui traduzida por mim e mostrando apenas a parte que nos interessa):\n$ help trap trap: trap [-lp] [[arg] signal_spec ...]   (...)  Um SIGNAL_SPEC de ERR significa que √© pra executar  ARG cada vez que uma falha de um comando fizer  o shell sair quando a op√ß√£o -e est√° ativa.  (...) Pois √©\u0026hellip; Est√° escrito de maneira meio confusa. E n√£o √© por conta da minha tradu√ß√£o ser prec√°ria. Est√° escrito de maneira esquisita no original tamb√©m\u0026hellip;\nO help est√° mencionando um sinal chamado ERR, mas se olharmos com aten√ß√£o a lista de sinais no output do trap -l n√£o tem nenhum SIGERR.\nPois √©! O lance √© que set -e faz o bash criar um sinal chamado ERR que ser√° lan√ßado quando o script encontrar algum comando que termine com um status diferente de zero.\nOu seja, o set -e faz o bash interromper o script assim encontra uma falha e em seguida lan√ßa o sinal ERR.\nExemplo bobo:\n#!/usr/bin/env bash  set -euo pipefail  trap \u0026#39;echo \u0026#34;Oops! Quebrei!\u0026#34;\u0026#39; ERR  comando invalido  echo \u0026#34;o script vai quebrar no comando inv√°lido acima\u0026#34; echo \u0026#34;portanto isso aqui n√£o ser√° executado\u0026#34; Executando:\n$ ./trap-bobo.sh ./trap-bobo.sh: line 7: comando: command not found Oops! Quebrei! Como eu disse, o set -e faz o bash (1) interromper o script e (2) lan√ßar o sinal ERR.\nSegredo #2: executando um comando na linha onde o ERR √© lan√ßado Esse segredo √© uma das chaves para alcan√ßar o objetivo que queremos. Continue comigo\u0026hellip;\nQuando temos uma situa√ß√£o do tipo:\n# requer \u0026#39;set -e\u0026#39; trap \u0026#39;echo \u0026#34;ERR capturado, abortando!\u0026#34;\u0026#39; ERR O sinal ERR ser√° lan√ßado quando qualquer comando do script terminar com uma falha (ou seja, status code diferente de zero).\nA grande sacada aqui √© que esse echo que estamos passando para o trap ser√° executado como se estivesse na linha onde o ERR foi capturado!\nAgora se voc√™ coloca nesse echo uma refer√™ncia a vari√°vel LINENO que mencionamos anteriormente\u0026hellip; ü§Ø\n# requer \u0026#39;set -e\u0026#39; trap \u0026#39;echo \u0026#34;ERR capturado na linha ${LINENO}!\u0026#34;\u0026#39; ERR √â s√©rio\u0026hellip; Quando eu percebi isso eu quase chorei de emo√ß√£o. ü•≤\nTentando juntar tudo isso Vamos juntar o conhecimento que adquirimos no artigo anterior com o que foi exposto aqui e vamos logo ao truque que vai mudar a sua vida:\n# OBS: isso s√≥ funciona se usarmos \u0026#39;set -e\u0026#39; trap \u0026#39;echo \u0026#34;${BASH_SOURCE}:${LINENO}:${FUNCNAME:-}\u0026#34;\u0026#39; ERR Vamos ver essa belezura em a√ß√£o com esse exemplo ilustrativo:\n#!/usr/bin/env bash # find-user.sh # Encontra um usu√°rio dentro do /etc/passwd # e imprime o nome em mai√∫sculo.  set -euo pipefail  trap \u0026#39;echo \u0026#34;ERRO EM: ${BASH_SOURCE}:${LINENO}:${FUNCNAME:-}\u0026#34;\u0026#39; ERR  # se n√£o passar um usu√°rio, use um default username=\u0026#34;${1:-usu√°rio inv√°lido}\u0026#34;  grep \u0026#34;${username}\u0026#34; /etc/passwd \\  | cut -d: -f1 \\  | tr [:lower:] [:upper:]  # pra fingir que aqui teria mais comando, # vamos colocar esse echo echo fim Executando:\n$ ./find-user.sh meleu MELEU fim  $ ./find-user.sh ERRO EM: ./find-user.sh:15: Bacana\u0026hellip; Recebemos o nome do script e a linha onde o erro ocorreu. A nome da fun√ß√£o veio em branco mas era de se esperar, pois o erro n√£o correu dentro de fun√ß√£o alguma.\nAcontece que eu sou um cara rigoroso com meu estilo de codifica√ß√£o. E uma das coisas que eu pratico nos meus c√≥digos da vida real √© colocar tudo dentro de uma fun√ß√£o. Portanto eu vou refatorar o exemplo acima pra ficar assim:\n#!/usr/bin/env bash # find-user.sh # Encontra um usu√°rio dentro do /etc/passwd # e imprime o nome em mai√∫sculo.  set -euo pipefail  trap \u0026#39;echo \u0026#34;ERRO EM: ${BASH_SOURCE}:${LINENO}:${FUNCNAME:-}\u0026#34;\u0026#39; ERR  main() {  # se n√£o passar um usu√°rio, use um default  local username=\u0026#34;${1:-usu√°rio inv√°lido}\u0026#34;   grep \u0026#34;${username}\u0026#34; /etc/passwd \\  | cut -d: -f1 \\  | tr [:lower:] [:upper:] }  main \u0026#34;$@\u0026#34; Agora vamos executar:\n$ ./find-user.sh meleu MELEU  $ ./find-user.sh  $ # üò≥ como assim?  $ ./find-user.sh UsuarioQualquer  $ # üòï cad√™ o trap em a√ß√£o?! Quebrei a cara! O trap n√£o fez o que eu esperava que ele fizesse\u0026hellip; üòî\nMas n√£o vamos nos abalar! Vamos conhecer mais um segredo\nSegredo #3: fazendo o trap ser herdado pelas fun√ß√µes Esse segredo est√° \u0026ldquo;escondido\u0026rdquo; no help set. L√° vemos o seguinte (tradu√ß√£o minha):\n-E Se ligado, o trap com ERR ser√° herdado pelas fun√ß√µes. Opa! Parece ser exatamente o que queremos! Agora sim vamos juntar os pontos.\nJuntando tudo Agora que j√° temos tudo que precisamos vamos refatorar meu script adicionando a op√ß√£o set -E:\n#!/usr/bin/env bash # find-user.sh # Encontra um usu√°rio dentro do /etc/passwd # e imprime o nome em mai√∫sculo.  set -Eeuo pipefail  trap \u0026#39;echo \u0026#34;ERRO EM: ${BASH_SOURCE}:${LINENO}:${FUNCNAME:-}\u0026#34;\u0026#39; ERR  main() {  # se n√£o passar um usu√°rio, use um default  local username=\u0026#34;${1:-usu√°rio inv√°lido}\u0026#34;   grep \u0026#34;${username}\u0026#34; /etc/passwd \\  | cut -d: -f1 \\  | tr [:lower:] [:upper:]   # pra fingir que aqui teria mais comando,  # vamos colocar esse echo  echo fim }  main \u0026#34;$@\u0026#34; Executando:\n$ ./find-user.sh meleu MELEU fim  $ ./find-user.sh ERRO EM: ./find-user.sh:16:main ü•≥üéâ Yeah!! √â exatamente isso que queremos!!!\nConclus√£o Juntando as pe√ßas desse quebra cabe√ßa envolvendo help trap, help set, trechos do man bash e experimenta√ß√µes, chegamos a seguinte conclus√£o:\n use set -euo pipefail pelos motivos explicados no artigo anterior. set -e faz o bash:  interromper execu√ß√£o do script quando qualquer comando terminar com status diferente de zero. lan√ßar o sinal ERR.   o trap pode ser usado para capturar esse ERR. quando o trap captura o ERR ele executa o comando que foi passado pra ele como se estivesse na linha onde o ERR foi lan√ßado. a vari√°vel LINENO mostra a linha do script onde ela est√° sendo invocada. consequ√™ncia de 4. e 5.:trap 'echo \u0026quot;${LINENO}\u0026quot;' ERR vai mostrar a n√∫mero da linha onde o ERR foi lan√ßado. use set -E para o que o trap 'comando...' ERR seja herdado pelas fun√ß√µes.  Convertendo isso em c√≥digo:\n# use isso nos seus scripts: set -Eeuo pipefail  trap \u0026#39;echo \u0026#34;ERRO EM: ${BASH_SOURCE}:${LINENO}:${FUNCNAME:-}\u0026#34;\u0026#39; ERR Obviamente que o echo pode ser incrementado. Por exemplo, colocando a mensagem em vermelho com caracteres de escape ANSI. Use sua criatividade! üòâ\nFontes  help set help trap man bash experimenta√ß√µes\u0026hellip; Eu tive a ideia de usar $BASH_SOURCE:$LINENO:$FUNCNAME quando eu estava lendo sobre debugging no BashGuide do Greg\u0026rsquo;s Wiki  ","permalink":"https://meleu.sh/trap-err/","summary":"Este artigo √© parte da s√©rie \u0026ldquo;Pr√°ticas de programa√ß√£o shell que mudar√£o sua vida\u0026rdquo;\nOs artigos da s√©rie s√£o:\n deixe seu bash mais rigoroso use um trap para saber exatamente onde seu script quebrou use o shellcheck   No artigo anterior aprendemos como fazer o nosso script falhar o mais r√°pido poss√≠vel e entedemos qual √© a grande vantagem disso. Neste artigo veremos como obter uma indica√ß√£o bem direta e precisa de onde o nosso script falhou.","title":"Como detectar precisamente onde seu script est√° quebrando"},{"content":" Este artigo √© parte da s√©rie \u0026ldquo;Pr√°ticas de programa√ß√£o shell que mudar√£o sua vida\u0026rdquo;\nOs artigos da s√©rie s√£o:\n deixe seu bash mais rigoroso use um trap para saber exatamente onde seu script quebrou use o shellcheck   No livro The Art of Unix Programming, o Eric S. Raymond diz o seguinte:\n Quando precisar falhar, falhe ruidosamente e o mais cedo poss√≠vel.\n Neste artigo eu vou tratar da situa√ß√£o de \u0026ldquo;falhar o mais cedo poss√≠vel\u0026rdquo;. Em um outro artigo eu vou falar sobre o \u0026ldquo;falhar ruidosamente\u0026rdquo;.\nü§î - \u0026ldquo;N√£o entendi\u0026hellip; E Qual √© a vantagem de falhar o mais cedo poss√≠vel?\u0026rdquo;\nExcelente pergunta! A vantagem √© que quanto mais cedo voc√™ visualizar um erro, mais r√°pido voc√™ ir√° corrig√≠-lo.\nImagine um erro que s√≥ aparece depois de 2 meses que voc√™ mexeu no c√≥digo\u0026hellip; Voc√™ ter√° que gastar um tempo at√© se contextualizar e ter clareza do que aquele c√≥digo faz.\nMotiva√ß√£o Um dos problemas que todo programador shell passa ou j√° passou √© perceber que seu script \u0026ldquo;bugou\u0026rdquo; em alguma parte mas a execu√ß√£o do script continuou.\nExemplo: voc√™ esperava que a sa√≠da de um grep fosse preencher o conte√∫do de uma certa vari√°vel mas a sa√≠da do grep veio vazia. O seu script continua executando (com sua vari√°vel vazia) e em algum outro ponto que voc√™ vai usar essa vari√°vel voc√™ percebe que ela est√° vazia.\nSe voc√™ programa em shell h√° algum tempo certamente j√° passou por situa√ß√µes como essa, certo?\nO que vamos ver nesse artigo vai fazer voc√™ nunca mais sofrer com isso.\nN√£o quero ler isso tudo! Me diz logo o que tenho que fazer! \u0026ldquo;Sempre\u0026rdquo; use isso no topo dos seus scripts:\nset -euo pipefail Observa√ß√£o: a op√ß√£o u tem algumas nuances que voc√™ precisa estar ciente. Se realmente n√£o quiser ler e nem arriscar, certifique-se de ao menos usar set -eo pipefail.\nOp√ß√µes do comando set O comando set permite que configuremos algumas op√ß√µes do bash. Neste artigo vamos focar em 3 op√ß√µes que voc√™ deve considerar sempre ativar em seus scripts.\nObserva√ß√£o: O set faz mais do que ligar/desligar op√ß√µes do bash. Para uma descri√ß√£o mais detalhada digite help set no seu prompt (ou veja a manpage do bash).\nSaia imediatamente ao falhar # vers√£o longa set -o errexit  # vers√£o curta set -e Veja o seguinte script:\n#!/usr/bin/env bash # set+e.sh  echo \u0026#34;O comando a seguir vai falhar...\u0026#34; cat /diretorio/arquivo-inexistente  echo \u0026#34;O comando falhou mas voc√™ est√° lendo essa mensagem... :(\u0026#34; Vamos execut√°-lo:\n$ bash set+e.sh O comando a seguir vai falhar... cat: /diretorio/arquivo-inexistente: No such file or directory O comando falhou mas voc√™ est√° lendo essa mensagem... :( Como percebemos, o cat falhou e o script continuou sua execu√ß√£o. Como n√£o queremos que isso aconte√ßa, vamos usar o set -e:\n#!/usr/bin/env bash # set-e.sh  set -e # exit on fail - saia ao falhar  echo \u0026#34;O comando a seguir vai falhar...\u0026#34;  cat /diretorio/arquivo-inexistente  echo \u0026#34;O comando falhou e essa mensagem nem ser√° impressa. :)\u0026#34; Executando:\n$ bash set-e.sh O comando a seguir vai falhar... cat: /diretorio/arquivo-inexistente: No such file or directory Uma coisa que vale a pena ressaltar, √© que em cl√°usulas condicionais (como if, while e ||) o erro no comando n√£o causa a interrup√ß√£o do programa.\nExemplo:\n#!/usr/bin/env bash # set-e.v2.sh  set -e #   arquivo=\u0026#39;/dir/arquivo-inexistente\u0026#39;  echo \u0026#34;--- inicio do arquivo ---\u0026#34;  if cat \u0026#34;${arquivo}\u0026#34;; then  echo \u0026#34;--- fim do arquivo ---\u0026#34; else  echo \u0026#34;--\u0026gt; Aqui deveria ter os comandos\u0026#34;  echo \u0026#34;--\u0026gt; a serem executados caso o comando\u0026#34;  echo \u0026#34;--\u0026gt; \u0026#39;cat\u0026#39; falhe...\u0026#34; fi  echo \u0026#34;A falha do \u0026#39;cat\u0026#39; foi \\\u0026#34;capturada\\\u0026#34; pelo \u0026#39;if\u0026#39;\u0026#34; echo \u0026#34;O programa continua...\u0026#34; Executando:\n$ bash set-e.v2.sh --- inicio do arquivo --- cat: /dir/arquivo-inexistente: No such file or directory --\u0026gt; Aqui deveria ter os comandos --\u0026gt; a serem executados caso o comando --\u0026gt; \u0026#39;cat\u0026#39; falhe... A falha do \u0026#39;cat\u0026#39; foi \u0026#34;capturada\u0026#34; pelo \u0026#39;if\u0026#39; O programa continua... Status code do primeiro comando que falhar numa pipeline # somente vers√£o longa set -o pipefail Quando voc√™ faz um encadeamento de comando usando o |, todos os comandos desse encadeamento s√£o executados e o valor de retorno ser√° o valor do √∫ltimo comando.\nNo exemplo a seguir, imagine que queremos procurar se um determinado usu√°rio est√° no arquivo /etc/passwd e queremos converter o nome todo para mai√∫sculo:\n#!/usr/bin/env bash # pipe-test.sh  grep UsuarioInvalido /etc/passwd \\  | cut -d: -f1 \\  | tr [:lower:] [:upper:] Executando e verificando se o script terminou com sucesso ou falha:\n$ bash pipe-test.sh \u0026amp;\u0026amp; echo sucesso || echo falha sucesso O QUE?! Como assim \u0026ldquo;sucesso\u0026rdquo;?! üò±\nPois √©\u0026hellip; Isso acontece porque o bash est√° retornando o status code do √∫ltimo comando da pipeline. Aquele tr n√£o fez nada, mas terminou com sucesso.\nAgora, ao habilitarmos o pipefail, o status code da pipeline ser√° o status do primeiro comando que falhar. Vamos fazer um teste:\n#!/usr/bin/env bash # pipe-test2.sh  set -o pipefail  grep UsuarioInvalido /etc/passwd \\  | cut -d: -f1 \\  | tr [:lower:] [:upper:] Executando e verificando se o status:\n$ bash pipe-test.sh \u0026amp;\u0026amp; echo sucesso || echo falha falha Agora sim! Isso faz mais sentido! üëç\nN√£o permita vari√°veis n√£o declaradas # vers√£o longa set -o nounset  # vers√£o curta set -u Essa op√ß√£o faz o bash falhar quando ele encontra uma expans√£o de vari√°vel que n√£o foi declarada.\nVamos testar com o famigerado \u0026ldquo;Hello World\u0026rdquo; com um nome:\n#!/usr/bin/env bash # hello.sh  set -u  echo \u0026#34;Hello, ${name}\u0026#34; echo \u0026#34;Seja bem vindo...\u0026#34; Executando:\n$ bash -u hello.sh hello.sh: line 6: name: unbound variable Muito frequentemente a op√ß√£o set -u nos ajuda a evitar problemas.\nLembra todo aquele tempo que voc√™ gastou tentando debugar seu script pra s√≥ depois de muita irrita√ß√£o voc√™ perceber que o problema foi apenas um erro de digita√ß√£o no nome da vari√°vel? Quem nunca?\nPonto de aten√ß√£o no set -u O set -u tem o seguinte efeito colateral: ele far√° o seu script falhar ao tentar expandir TODA E QUALQUER vari√°vel que n√£o teve o seu valor explicitamente declarado.\nVou mostrar um exemplo de quando isso pode ser incoveniente:\n#!/usr/bin/env bash # hello2.sh  set -u  if [[ -z \u0026#34;${name}\u0026#34; ]]; then  echo \u0026#34;Hello World\u0026#34; else  echo \u0026#34;Hello, ${name}\u0026#34; fi  echo \u0026#34;Seja bem vindo...\u0026#34; Executando:\n$ bash hello2.sh hello2.sh: line 6: name: unbound variable Mesmo que voc√™ pense \u0026ldquo;ah, eu j√° estou tomando cuidado de verificar se a vari√°vel est√° vazia\u0026rdquo;, ainda assim o bash vai parar o script ao encontrar aquela vari√°vel sem valor.\nPra resolver esse problema voc√™ precisa explicitamente dar algum valor para a vari√°vel name, podendo inclusive ser um valor vazio:\n#!/usr/bin/env bash # hello3.sh  set -u  # string vazia name=  if [[ -z \u0026#34;${name}\u0026#34; ]]; then  echo \u0026#34;Hello World\u0026#34; else  echo \u0026#34;Hello, ${name}\u0026#34; fi  echo \u0026#34;Seja bem vindo...\u0026#34; Executando:\n$ bash hello3.sh Hello World Seja bem vindo... OK, esse exemplo \u0026ldquo;Hello World\u0026rdquo; foi bem simpl√≥rio\u0026hellip; Vamos falar de algo mais concreto.\nNa \u0026ldquo;vida real\u0026rdquo; √© bastante comum usarmos o [[ -z \u0026quot;${VARIAVEL}\u0026quot; ]] para verificar se uma vari√°vel de ambiente est√° vazia ou n√£o. Exemplo hipot√©tico:\nif [[ -z \u0026#34;${ENV_VARIABLE}\u0026#34; ]]; then  echo \u0026#34;\u0026#39;ENV_VARIABLE\u0026#39; est√° vazia\u0026#34;  echo \u0026#34;vamos fazer algo quanto a isso...\u0026#34; fi Esse exemplo √© s√≥ pra mostrar que queremos que nosso script fa√ßa algo quando aquela vari√°vel estiver vazia. No entanto, com o set -u aquele if pode acabar quebrando antes mesmo da verifica√ß√£o de vari√°vel vazia.\nDando um exemplo mais \u0026ldquo;vida real\u0026rdquo; ainda (s√≥ vai fazer sentido se voc√™ entende de git):\nNo meu trabalho usamos GitLab CI para esteira de Integra√ß√£o Cont√≠nua. O GitLab automaticamente define algumas vari√°veis para voc√™ usar na sua esteira. Uma dessas vari√°veis √© o CI_COMMIT_BRANCH.\nEu j√° passei por um cen√°rio onde essa vari√°vel n√£o veio preenchida (quando a pipeline √© disparada por um Merge Request) e isso acabou quebrando meu script.\nPara contornar essa situa√ß√£o, tive que usar uma das t√©cnicas de expans√£o de par√¢metros, da seguinte forma:\nif [[ -z \u0026#34;${CI_COMMIT_BRANCH:-}\u0026#34; ]]; then  # ... fi Expans√£o de par√¢metros est√° fora do escopo desse artigo, mas pra resumir:\n# se $parametro for vazio, a expans√£o abaixo # vai gerar a string \u0026#34;valor default\u0026#34; ${parametro:-valor default} Como voc√™ pode ver, o que vem depois :- ser√° o valor default. E no exemplo que dei, ${CI_COMMIT_BRANCH:-}, o valor default √© uma string vazia.\nConclus√£o Neste artigo vimos como uma simples linha de c√≥digo no in√≠cio dos seus scripts vai te salvar de muitas dores de cabe√ßa e evitar que voc√™ desperdice tempo ca√ßando bugs perfeitamente evit√°veis.\nset -euo pipefail Fontes  help set man bash The Art of Unix Programming - Rule of Repair Use Bash Srict Mode (Unless You Love Debugging)  ","permalink":"https://meleu.sh/bash-rigoroso/","summary":"Este artigo √© parte da s√©rie \u0026ldquo;Pr√°ticas de programa√ß√£o shell que mudar√£o sua vida\u0026rdquo;\nOs artigos da s√©rie s√£o:\n deixe seu bash mais rigoroso use um trap para saber exatamente onde seu script quebrou use o shellcheck   No livro The Art of Unix Programming, o Eric S. Raymond diz o seguinte:\n Quando precisar falhar, falhe ruidosamente e o mais cedo poss√≠vel.\n Neste artigo eu vou tratar da situa√ß√£o de \u0026ldquo;falhar o mais cedo poss√≠vel\u0026rdquo;.","title":"Deixe o bash mais rigoroso com seu script e evite dores de cabe√ßa"},{"content":"Neste artigo veremos algumas configura√ß√µes interessantes para se fazer no seu ambiente de forma a melhorar o seu .bash_history e o output do comando history.\nMotiva√ß√£o Eu geralmente uso o tmux com v√°rias sess√µes de bash abertas, e como raramente eu desligo o computador, muitas vezes essas sess√µes duram dias. Normalmente o bash grava o hist√≥rico da sess√£o atual no .bash_history apenas ao final da sess√£o.\nO problema disso √© que muitas vezes eu quero consultar o hist√≥rico de comandos em busca de algo que fiz dias atr√°s, mas o como eu n√£o encerrei a sess√£o onde o comando foi executado, esse hist√≥rico ainda n√£o foi salvo no meu .bash_history.\nPois bem, resolvi investir um tempo estudando configs relacionadas ao bash history e nesse artigo mostro o resultado dos meus estudos.\n A prop√≥sito, caso queira bisbilhotar as configs que eu uso, d√™ uma conferida no meu .bashrc.\n Configura√ß√µes com vari√°veis de ambiente Vamos ver aqui as configura√ß√µes que s√£o feitas atrav√©s de vari√°veis de ambiente.\nHISTCONTROL Controla como os comandos ser√£o gravados no hist√≥rico.\nAs op√ß√µes s√£o as seguintes:\n ignorespace - ignora comandos come√ßando com espa√ßo ignoredups - ignora comandos duplicados (da sess√£o atual) ignoreboth - equivalente a usar as duas op√ß√µes acima erasedups - elimina entradas duplicadas de todo o hist√≥rico (n√£o apenas da sess√£o atual)  Caso queira usar mais de uma op√ß√£o no HISTCONTROL, elas devem ser separadas com : dois-pontos. Exemplo: HISTCONTROL='ignoreboth:erasedups'\nMinha prefer√™ncia:\nexport HISTCONTROL=\u0026#39;ignoreboth\u0026#39; Eu uso ignoreboth, que √© equivalente a ignorespace:ignoredups.\nDesta forma eu tenho as duas features:\n quando eu n√£o quero armazenar um comando no meu history (por exemplo quando tem alguma credencial) eu adiciono um espa√ßo em branco antes do comando. n√£o armazeno comandos repetidos que foram executados em uma mesma sess√£o.  Eu n√£o curto o erasedups pois em alguns momentos eu gosto de olhar no meu history algo que fiz no passado e ter o comando em ordem me ajuda a fazer uma \u0026ldquo;reconstitui√ß√£o dos fatos\u0026rdquo;. Com o erasedups, os comandos do passado iriam sumir caso eu os repetisse.\nHISTIGNORE Nesta vari√°vel podemos adicionar uma lista, separada por : dois-pontos, de comandos que n√£o queremos armazenar no nosso .bash_history.\nMinha prefer√™ncia:\nexport HISTIGNORE=\u0026#39;ls:ls -lah:history:pwd:htop:bg:fg:clear\u0026#39; HISTTIMEFORMAT Configura um timestamp para ser exibido quando vc usa o comando history.\nVeja este exemplo:\n$ history 3 2426 cat /etc/passwd 2427 vim ~/.bash_history 2428 history 3 $ export HISTTIMEFORMAT=\u0026#34;%F %T \u0026#34; $ history 3 2428 2022-03-29 17:32:25 history 3 2429 2022-03-29 17:32:36 export HISTTIMEFORMAT=\u0026#34;%F %T$ \u0026#34; 2430 2022-03-29 17:32:40 history 3 Voc√™ pode ver as op√ß√µes poss√≠veis no man strftime.\nMinha prefer√™ncia:\nexport HISTTIMEFORMAT=\u0026#34;%F %T$\u0026#34; Eu gosto de deixar esse $ ap√≥s o timestamp pois me ajuda na hora de mandar um history | grep something | cut -d$ -f2-.\nPROMPT_COMMAND Essa n√£o √© uma vari√°vel exclusiva de configura√ß√£o do history, mas vamos us√°-la para esse prop√≥sito aqui.\nO PROMPT_COMMAND nada mais √© do que um comando (ou lista de comandos) que s√£o executados antes do prompt ser exibido. E o que vamos fazer aqui √© executar o comando history -a para salvar o history atual em disco ap√≥s cada comando.\nMinha prefer√™ncia:\nexport PROMPT_COMMAND=\u0026#39;history -a\u0026#39; Observa√ß√£o: esta vari√°vel tamb√©m pode ser um array. Veja man bash para mais detalhes.\nHISTSIZE e HISTFILESIZE A manpage do bash n√£o deixa muito claro qual √© a diferen√ßa dessas duas vari√°veis, mas atrav√©s de experimenta√ß√µes aqui eu cheguei a conclus√£o que:\n HISTSIZE define quantos comandos estar√£o vis√≠veis no output do seu comando history. HISTFILESIZE define quantos comandos ser√£o armazenados no seu arquivo ~/.bash_history (removendo os mais antigos quando esse valor √© atingido).  Em qualquer uma dessas vari√°veis, um valor negativo significa \u0026ldquo;ilimitado\u0026rdquo;.\nMinha prefer√™ncia:\nexport HISTSIZE=10000 export HISTFILESIZE=20000 Pra ser sincero n√£o tenho nenhum dado concreto para justificar esses valores. Apenas uso e acho razo√°vel.\nConfigura√ß√µes com shopt Agora veremos duas op√ß√µes de shopt que est√£o relacionadas com o bash history.\nhistappend Faz o bash acrescentar o history da sess√£o atual ao ~/.bash_history. Se essa op√ß√£o estiver desativada, o arquivo ser√° sobrescrito (o conte√∫do anterior ser√° perdido).\nMinha prefer√™ncia:\nObviamente, eu deixo essa op√ß√£o habilitada.\nshopt -s histappend cmdhist Um comando com m√∫ltiplas linhas √© salvo como se fosse apenas um comando.\nVeja na pr√°tica:\n$ # habilitando o cmdhist $ shopt -s cmdhist $ echo meleu \\ \u0026gt; | tr [:lower:] [:upper:] MELEU $ history 3 2444 shopt -s cmdhist 2445 echo meleu | tr [:lower:] [:upper:] 2446 history 3 $ # üëÜ observe a linha 2445 acima $ # desabilitando o cmdhist $ shopt -u cmdhist $ echo meleu \\ \u0026gt; | tr [:lower:] [:upper:] MELEU $ history 5 2447 # desabilitando o cmdhist 2448 shopt -u cmdhist 2449 echo meleu \\ 2450 | tr [:lower:] [:upper:] 2451 history 5 $ # üëÜ observe as linhas 2449 e 2450 acima Minha prefer√™ncia:\nshopt -s cmdhist Configura√ß√£o pra colocar no seu .bashrc Se voc√™ curtiu as minhas prefer√™ncias listadas acima, basta colocar o seguinte conte√∫do no seu .bashrc:\n# History Options ################################# # explica√ß√£o destas op√ß√µes em # https://meleu.sh/bash-history  export HISTCONTROL=\u0026#39;ignoreboth\u0026#39; export HISTIGNORE=\u0026#39;ls:ls -lah:history:pwd:htop:bg:fg:clear\u0026#39; export HISTTIMEFORMAT=\u0026#34;%F %T$\u0026#34; export PROMPT_COMMAND=\u0026#39;history -a\u0026#39; export HISTSIZE=10000 export HISTFILESIZE=20000  shopt -s histappend shopt -s cmdhist Caso tenha curiosidade de saber como √© o meu .bashrc, d√™ uma olhada no meu dotfiles no github.\nFontes  man bash (procure por HISTCONTROL, HISTIGNORE, HISTTIMEFORMAT, etc.) https://linuxhint.com/bash_command_history_usage/ https://gist.github.com/ckabalan/7d374ceea8c2d9dd237d763d385cf2aa  ","permalink":"https://meleu.sh/bash-history/","summary":"Neste artigo veremos algumas configura√ß√µes interessantes para se fazer no seu ambiente de forma a melhorar o seu .bash_history e o output do comando history.\nMotiva√ß√£o Eu geralmente uso o tmux com v√°rias sess√µes de bash abertas, e como raramente eu desligo o computador, muitas vezes essas sess√µes duram dias. Normalmente o bash grava o hist√≥rico da sess√£o atual no .bash_history apenas ao final da sess√£o.\nO problema disso √© que muitas vezes eu quero consultar o hist√≥rico de comandos em busca de algo que fiz dias atr√°s, mas o como eu n√£o encerrei a sess√£o onde o comando foi executado, esse hist√≥rico ainda n√£o foi salvo no meu .","title":"Melhorando seu .bash_history"},{"content":"Recentemente descobri uma ferramenta bem bacaninha que serve para gerar simples e belos gr√°ficos de barra diretamente no terminal. A ferramenta se chama termgraph e seu reposit√≥rio no github √© https://github.com/mkaz/termgraph.\nE aproveitando a enorme oferta de dados dispon√≠vel na web sobre a epidemia do Coronav√≠rus, achei que esse seria um bom caso de uso para aprendermos a usar a ferramenta.\nVamos obter uma lista com as 10 na√ß√µes com maior n√∫mero de mortes por COVID-19 e gerar um gr√°fico de barras mostrando esse ranking.\nVamos nessa!\nPrimeiro passo: instalando e usando o termgraph Para instalar √© muito simples:\npip3 install termgraph E pronto. Agora digite um termgraph -h s√≥ para se certificar que a instala√ß√£o foi feita com sucesso.\nO formato dos dados a serem enviados ao termgraph pra ele gerar o gr√°fico de barras √© absurdamente simples. Trata-se apenas de um arquivo onde cada linha cont√©m um r√≥tulo, seguido de espa√ßo(s) (ou v√≠rgula), seguido do(s) n√∫mero(s) a serem usados como valores para criar o gr√°fico.\nVeja o exemplo abaixo:\n$ cat data/ex1.dat # Example Data Set 1 2007 183.32 2008 231.23 2009 16.43 2010 50.21 2011 508.97 2012 212.05 2014 1.0 $ # observe acima! cada linha come√ßa com o r√≥tulo $ # seguido do valor referente aquele r√≥tulo. $ # divinamente simples!! $ $ termgraph data/ex1.dat 2007: ‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá 183.32 2008: ‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá 231.23 2009: ‚ñá 16.43 2010: ‚ñá‚ñá‚ñá‚ñá 50.21 2011: ‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá 508.97 2012: ‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá 212.05 2014: ‚ñè 1.00 Bem legal, n√£o acha?!\nPois agora o que temos que fazer √© obter os dados que queremos para fazer o ranking.\nSegundo passo: obtendo os dados com curl Assim como no meu artigo anterior, mais uma vez vamos usar a API que √© documentada nesse reposit√≥rio: https://github.com/disease-sh/API\nL√° podemos ver que o endpoint a ser acessado para obtermos uma lista ordenada pelo n√∫mero de mortes √© https://disease.sh/v3/covid-19/countries?sort=deaths.\nSe voc√™ fizer o teste a√≠ no seu terminal, vai perceber que sua tela vai receber uma enxurrada de dados no formato JSON. Abaixo eu mostro apenas o in√≠cio dos dados:\n$ curl \u0026#39;https://disease.sh/v3/covid-19/countries?sort=deaths\u0026#39; [{\u0026#34;country\u0026#34;:\u0026#34;Italy\u0026#34;,\u0026#34;countryInfo\u0026#34;:{\u0026#34;_id\u0026#34;:380,\u0026#34;lat\u0026#34;:42.8333,... Para simplificar os nossos testes iniciais e evitar de ficar acessando a API desnecessariamente, vamos salvar esse JSON num arquivo:\n$ curl \u0026#39;https://disease.sh/v3/covid-19/countries?sort=deaths\u0026#39; \u0026gt; corona-deaths.json Agora esses dados JSON brutos, precisam ser lapidados. E mais uma vamos usar o jq para isso:\nTerceiro passo: garimpando dados com jq O jq uma ferramenta bem √∫til para tratar dados JSON diretamente pela linha de comando. Se n√£o tiver instalado na sua m√°quina, instale-o. Geralmente o gerenciador de pacotes oficial da sua distro (apt-get, pacman, etc.) j√° vai ter um pacote chamado jq, portanto creio que voc√™ n√£o ter√° problemas com isso.\nConforme tamb√©m vimos no meu artigo anterior, o jq d√° uma embelezada no JSON tornando-o mais leg√≠vel. No entanto se usarmos o tradicional jq '.' ser√£o tantas linhas exibidas na tela que dificilmente conseguiremos visualizar as primeiras entradas da lista.\nPortanto vamos come√ßar a fazer alguns truques para limpar esses dados. N√£o est√° no escopo desse texto, explicar cada op√ß√£o, irem apenas mostrar a \u0026ldquo;receitinha do bolo\u0026rdquo;. Mas na documenta√ß√£o oficial voc√™ pode consultar todas essas op√ß√µes.\n1. Pegar somente as 10 primeiras entradas Lembre-se, no passo anterior, usamos o curl para salvar os dados num arquivo chamado corona-deaths.json.\n$ jq \u0026#39;.[:10]\u0026#39; corona-deaths.json [  {  \u0026#34;country\u0026#34;: \u0026#34;Italy\u0026#34;,  \u0026#34;countryInfo\u0026#34;: {  \u0026#34;_id\u0026#34;: 380,  \u0026#34;lat\u0026#34;: 42.8333,  \u0026#34;long\u0026#34;: 12.8333,  \u0026#34;flag\u0026#34;: \u0026#34;https://disease.sh/assets/flags/it.png\u0026#34;,  \u0026#34;iso3\u0026#34;: \u0026#34;ITA\u0026#34;,  \u0026#34;iso2\u0026#34;: \u0026#34;IT\u0026#34;  },  \u0026#34;cases\u0026#34;: 80589,  \u0026#34;todayCases\u0026#34;: 0,  \u0026#34;deaths\u0026#34;: 8215,  \u0026#34;todayDeaths\u0026#34;: 0,  \u0026#34;recovered\u0026#34;: 10361,  \u0026#34;active\u0026#34;: 62013,  \u0026#34;critical\u0026#34;: 3612,  \u0026#34;casesPerOneMillion\u0026#34;: 1,  \u0026#34;deathsPerOneMillion\u0026#34;: 136  },  .  .  . ] $ # mostrando apenas a primeira entrada para $ # economizar esse espa√ßo... Como podemos ver, o JSON come√ßa com [ e termina com ]. Isso significa que os dados est√£o dentro de um array. Vamos agora pegar esses dados \u0026ldquo;individualmente\u0026rdquo;, sem estarem encapsulados num array.\n2. Pegando os dados de dentro do array $ jq \u0026#39;.[:10][]\u0026#39; corona-deaths.json {  \u0026#34;country\u0026#34;: \u0026#34;Italy\u0026#34;,  \u0026#34;countryInfo\u0026#34;: {  \u0026#34;_id\u0026#34;: 380,  \u0026#34;lat\u0026#34;: 42.8333,  \u0026#34;long\u0026#34;: 12.8333,  \u0026#34;flag\u0026#34;: \u0026#34;https://disease.sh/assets/flags/it.png\u0026#34;,  \u0026#34;iso3\u0026#34;: \u0026#34;ITA\u0026#34;,  \u0026#34;iso2\u0026#34;: \u0026#34;IT\u0026#34;  },  \u0026#34;cases\u0026#34;: 80589,  \u0026#34;todayCases\u0026#34;: 0,  \u0026#34;deaths\u0026#34;: 8215,  \u0026#34;todayDeaths\u0026#34;: 0,  \u0026#34;recovered\u0026#34;: 10361,  \u0026#34;active\u0026#34;: 62013,  \u0026#34;critical\u0026#34;: 3612,  \u0026#34;casesPerOneMillion\u0026#34;: 1,  \u0026#34;deathsPerOneMillion\u0026#34;: 136 }, . . . $ OK. S√≥ que ainda tem muitos dados que n√£o nos interessam ali.\n3. Pegando apenas as propriedades que nos interessam Aqui n√≥s vamos matar dois coelhos com uma cajadada s√≥.\nN√≥s precisamos apenas do nome do pa√≠s e do n√∫mero de mortes. Precisamos tamb√©m exibir essas informa√ß√µes naquele formato usado pelo termgraph: r√≥tulo n√∫mero.\nAlcan√ßamos esse objetivo usando o recurso de string interpolation do jq\n$ jq \u0026#39;.[:10][] | \u0026#34;\\(.country) \\(.deaths)\u0026#34;\u0026#39; corona-deaths.json \u0026#34;Italy 8215\u0026#34; \u0026#34;Spain 4858\u0026#34; \u0026#34;China 3292\u0026#34; \u0026#34;Iran, Islamic Republic of 2378\u0026#34; \u0026#34;France 1696\u0026#34; \u0026#34;USA 1307\u0026#34; \u0026#34;UK 759\u0026#34; \u0026#34;Netherlands 546\u0026#34; \u0026#34;Germany 304\u0026#34; \u0026#34;Belgium 289\u0026#34; Opa! Parece que deu certo, mas\u0026hellip; Aquela linha do Iran parece que vai ser problem√°tica\u0026hellip;\nComo a ocorr√™ncia de v√≠rgula e espa√ßos √© uma coisa que pode ocorrer no nome dos pa√≠ses, vamos usar um outro delimitador para separar r√≥tulos dos n√∫meros e depois a gente d√° um jeito de dizer ao termgraph que o delimitador √© diferente do default.\nPara o nosso prop√≥sito aqui, vamos usar o ; ponto-e-v√≠rgula (espero que n√£o apare√ßa pa√≠s algum com ponto-e-v√≠rgula no nome!):\n$ jq \u0026#39;.[:10][] | \u0026#34;\\(.country);\\(.deaths)\u0026#34;\u0026#39; corona-deaths.json \u0026#34;Italy;8215\u0026#34; \u0026#34;Spain;4858\u0026#34; \u0026#34;China;3292\u0026#34; \u0026#34;Iran, Islamic Republic of;2378\u0026#34; \u0026#34;France;1696\u0026#34; \u0026#34;USA;1307\u0026#34; \u0026#34;UK;759\u0026#34; \u0026#34;Netherlands;546\u0026#34; \u0026#34;Germany;304\u0026#34; \u0026#34;Belgium;289\u0026#34; Tem outro detalhezinho que precisamos ajeitar antes de mandar esses dados para o termgraph: as \u0026ldquo;aspas\u0026rdquo;.\nObserve que cada linha come√ßa e termina com aspas. O termgraph n√£o vai entender isso muito bem. Portanto precisamos remov√™-las, e vamos usar o tr para isso:\n$ jq \u0026#39;.[:10][] | \u0026#34;\\(.country);\\(.deaths)\u0026#34;\u0026#39; corona-deaths.json \\  | tr -d \\\u0026#34; Italy;8215 Spain;4858 China;3292 Iran, Islamic Republic of;2378 France;1696 USA;1307 UK;759 Netherlands;546 Germany;304 Belgium;289 Vamos salvar esse conte√∫do em um arquivo para mandar pro termgraph:\n$ jq \u0026#39;.[:10][] | \u0026#34;\\(.country);\\(.deaths)\u0026#34;\u0026#39; corona-deaths.json \\  | tr -d \\\u0026#34; \u0026gt; input.dat 4. Mandando os dados para o termgraph Vamos ver se esse gr√°fico vai ficar bonito mesmo.\nLembremos que optamos por usar o ; ponto-e-v√≠rgula como delimitador, portanto precisamos avisar ao termgraph sobre isso usando a op√ß√£o --delim:\n$ # OBSERVA√á√ÉO: o ponto-e-v√≠rgula precisa estar entre aspas $ # caso contr√°rio o shell vai achar que √© o fim de um comando $ termgraph --delim \u0026#39;;\u0026#39; input.dat Italy : ‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá 8215.00 Spain : ‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá 4858.00 China : ‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá 3292.00 Iran, Islamic Republic of: ‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá 2378.00 France : ‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá 1696.00 USA : ‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá 1307.00 UK : ‚ñá‚ñá‚ñá‚ñá 759.00 Netherlands : ‚ñá‚ñá‚ñá 546.00 Germany : ‚ñá 304.00 Belgium : ‚ñá 289.00 Epa! Bem legal, n√© n√£o?\nMas\u0026hellip; Pode parecer bobagem, mas aquele .00 no final est√° me incomodando\u0026hellip; O termgraph sempre considera que o n√∫mero √© um valor com casas decimais, mas como n√£o √© poss√≠vel que tenhamos, por exemplo 3.72 mortes, eu vou remover aquilo com o sed:\n$ termgraph --delim \u0026#39;;\u0026#39; input.dat | sed \u0026#39;s/\\.00$//\u0026#39; Italy : ‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá 8215 Spain : ‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá 4858 China : ‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá 3292 Iran, Islamic Republic of: ‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá 2378 France : ‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá 1696 USA : ‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá 1307 UK : ‚ñá‚ñá‚ñá‚ñá 759 Netherlands : ‚ñá‚ñá‚ñá 546 Germany : ‚ñá 304 Belgium : ‚ñá 289 Agora sim! Temos todo os insumos necess√°rios para montar o nosso script!\n√öltimo passo: o script #!/usr/bin/env bash # covid-ranking.sh ################## # # Exibe um gr√°fico de barras com o ranking dos pa√≠ses com # maior n√∫mero de mortes causadas pelo COVID-19 (Coronavirus). # readonly URL=\u0026#39;https://disease.sh/v3/covid-19/countries?sort=deaths\u0026#39; readonly DEPENDENCIES=(curl jq termgraph) checkDependencies() { local errorFound=0 for command in \u0026#34;${DEPENDENCIES[@]}\u0026#34;; do if ! which \u0026#34;$command\u0026#34; \u0026gt; /dev/null ; then echo \u0026#34;ERRO: n√£o encontrei o comando \u0026#39;$command\u0026#39;\u0026#34; \u0026gt;\u0026amp;2 errorFound=1 fi done if [[ \u0026#34;$errorFound\u0026#34; != \u0026#34;0\u0026#34; ]]; then echo \u0026#34;---IMPOSS√çVEL CONTINUAR---\u0026#34; echo \u0026#34;Esse script precisa dos comandos listados acima\u0026#34; \u0026gt;\u0026amp;2 echo \u0026#34;Instale-os e/ou verifique se est√£o no seu \\$PATH\u0026#34; \u0026gt;\u0026amp;2 exit 1 fi } main() { checkDependencies curl --silent \u0026#34;$URL\u0026#34; \\ | jq \u0026#39;.[:10][] | \u0026#34;\\(.country);\\(.deaths)\u0026#34;\u0026#39; \\ | tr -d \\\u0026#34; \\ | termgraph --delim \u0026#39;;\u0026#39; --title \u0026#39;Pa√≠ses com maior casos de mortes por COVID-19\u0026#39; \\ | sed \u0026#39;s/\\.00$//\u0026#39; } main \u0026#34;$@\u0026#34; Agora vejamos o script em a√ß√£o:\n$ chmod a+x covid-ranking.sh $ ./covid-ranking.sh # Pa√≠ses com maior casos de mortes por COVID-19 Italy : ‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá 8215 Spain : ‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá 4934 China : ‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá 3292 Iran : ‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá 2378 France : ‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá 1696 USA : ‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá‚ñá 1382 UK : ‚ñá‚ñá‚ñá‚ñá 759 Netherlands: ‚ñá‚ñá‚ñá 546 Germany : ‚ñá 304 Belgium : ‚ñá 289 CURIOSIDADE: nos testes finais antes da publica√ß√£o deste artigo eu observei que o nome do \u0026ldquo;Iran\u0026rdquo; n√£o est√° mais retornando com a v√≠rgula e aqueles outros dizeres. Observe isso na sa√≠da acima! Ainda bem que apareceu antes e pudemos contornar um poss√≠vel problema no c√≥digo que s√≥ apareceria no futuro! :)\nPasso(s) Extra(s): aprimore o script Sugest√µes de melhorias que voc√™ pode implementar nesse script como exerc√≠cio:\n Veja na documenta√ß√£o da API como obter os dados ordenados por outros crit√©rios (exemplo: cases, todayCases, recovered, etc.) Uma vez que tenha aprendido a ordenar por outros crit√©rios, gerar gr√°ficos do ranking dos pa√≠ses com mais casos, com mais casos registrados hoje, com mais casos recuperados. Voc√™ pode fazer isso por exemplo adicionando uma op√ß√£o de linha de comando chamada --sort-by Adicione a op√ß√£o da linha de comando --max, onde o usu√°rio poder√° especificar o n√∫mero de entradas no ranking (exemplo: apenas os top-5 ou os top-20). Use sua criatividade.  Fontes  https://github.com/disease-sh/api - reposit√≥rio com a descri√ß√£o de como usar a api rest. https://stedolan.github.io/jq/manual/ - manual do jq https://jqplay.org/ - √≥tima ferramenta para treinar jq e ajudar a montar seu comando/filtro.  ","permalink":"https://meleu.sh/coronavirus-ranking/","summary":"Recentemente descobri uma ferramenta bem bacaninha que serve para gerar simples e belos gr√°ficos de barra diretamente no terminal. A ferramenta se chama termgraph e seu reposit√≥rio no github √© https://github.com/mkaz/termgraph.\nE aproveitando a enorme oferta de dados dispon√≠vel na web sobre a epidemia do Coronav√≠rus, achei que esse seria um bom caso de uso para aprendermos a usar a ferramenta.\nVamos obter uma lista com as 10 na√ß√µes com maior n√∫mero de mortes por COVID-19 e gerar um gr√°fico de barras mostrando esse ranking.","title":"Como criar um gr√°fico de barras no terminal listando os pa√≠ses com mais ocorr√™ncias de morte pelo Coronavirus"},{"content":"O mundo est√° em p√¢nico! O tal do Coronavirus est√° se alastrando rapidamente pelo mundo. Mesmo que exista uma turma tentando minimizar o alarde e nos convencer que n√£o tem necessidade de tanto p√¢nico, dizendo que existem/existiram outras doen√ßas matando muito mais\u0026hellip; O melhor √© se prevenir!\nUma das recomenda√ß√µes que est√£o sendo dadas √© para que as pessoas n√£o saiam de casa. E j√° que vamos ficar em casa (stay at /home), que tal um pouco de nerdeza para distrair?\nNeste artigo vamos criar um script que consultar√° uma API REST para obter o n√∫mero de casos oficialmente reportados de COVID-19 (doen√ßa causada pelo Coronavirus).\nEis algums comandos/t√©cnicas que iremos usar:\n curl para obter os dados; jq para tratar o JSON; array associativo para armazenar as informa√ß√µes tratadas pelo jq; redirecionamento para while read para alimentar o array associativo.  Vamos come√ßar\u0026hellip;\nPrimeiro Passo: obtendo os dados com curl Eu conheci essa API l√° no github, o reposit√≥rio fica em https://github.com/disease-sh/API.\nO endpoint que iremos acessar √© o https://disease.sh/v3/covid-19/all para pegar um resumo dos dados globais. E tamb√©m usaremos o https://disease.sh/v3/covid-19/countries/[nome-do-pais] para consultas por pa√≠s.\nVamos usar o curl para ver o que esses endpoints nos retornam:\n$ curl --silent \u0026#39;https://disease.sh/v3/covid-19/all\u0026#39; {\u0026#34;cases\u0026#34;:186993,\u0026#34;deaths\u0026#34;:7477,\u0026#34;recovered\u0026#34;:80842,\u0026#34;updated\u0026#34;:1584448250501} $ $ curl --silent \u0026#39;https://disease.sh/v3/covid-19/countries/brazil\u0026#39; {\u0026#34;country\u0026#34;:\u0026#34;Brazil\u0026#34;,\u0026#34;cases\u0026#34;:234,\u0026#34;todayCases\u0026#34;:0,\u0026#34;deaths\u0026#34;:0,\u0026#34;todayDeaths\u0026#34;:0,\u0026#34;recovered\u0026#34;:2,\u0026#34;critical\u0026#34;:18} Legal, parecem ser informa√ß√µes √∫teis. Mas assim com esse JSON cru, todo coladinho fica meio ruim de visualizar\u0026hellip;\nSegundo Passo: consumindo o JSON com jq Um comando bem √∫til para tratar de dados JSON na linha de comando √© o jq (se n√£o tiver ele na sua m√°quina, trate de instalar, pois ele √© muito √∫til!).\nVejamos como ele pode \u0026ldquo;embelezar\u0026rdquo; aquele JSON e torn√°-lo mais leg√≠vel:\n$ curl --silent \u0026#39;https://disease.sh/v3/covid-19/all\u0026#39; | jq \u0026#39;.\u0026#39; {  \u0026#34;cases\u0026#34;: 186993,  \u0026#34;deaths\u0026#34;: 7477,  \u0026#34;recovered\u0026#34;: 80842,  \u0026#34;updated\u0026#34;: 1584448250501 } $ curl --silent \u0026#39;https://disease.sh/v3/covid-19/countries/brazil\u0026#39; | jq \u0026#39;.\u0026#39; {  \u0026#34;country\u0026#34;: \u0026#34;Brazil\u0026#34;,  \u0026#34;cases\u0026#34;: 234,  \u0026#34;todayCases\u0026#34;: 0,  \u0026#34;deaths\u0026#34;: 0,  \u0026#34;todayDeaths\u0026#34;: 0,  \u0026#34;recovered\u0026#34;: 2,  \u0026#34;critical\u0026#34;: 18 } Bem melhor, n√£o √© mesmo?\nNeste exemplo usamos apenas o '.', que √© uma maneira simples de dizer ao jq que voc√™ s√≥ quer embelezar a sa√≠da (pretty-print) de uma entrada JSON. Por√©m atrav√©s desse argumento, que precisa estar entre aspas, podemos fazer coisas muito mais poderosas com o jq.\nVamos aqui usar alguns comandos mais avan√ßados do jq para coletar os dados que nos interessam e posteriormente salv√°-los em um array\u0026hellip;\nPrimeiro vamos fazer com que cada propriedade do JSON seja convertido em um objeto com o par key-value (chave-valor). √â, isso parece meio confuso, mas com um exemplo tudo fica mais claro.\nO que n√≥s queremos √© que, por exemplo, \u0026quot;country\u0026quot;: \u0026quot;Brazil\u0026quot; vire isso:\n {  \u0026#34;key\u0026#34;: \u0026#34;country\u0026#34;,  \u0026#34;value\u0026#34;: \u0026#34;Brazil\u0026#34;  } E para alcan√ßar tal objetivo, vamos usar o to_entries do pr√≥prio jq.\n$ curl --silent \u0026#39;https://disease.sh/v3/covid-19/all\u0026#39; | jq \u0026#39;. | to_entries\u0026#39; [  {  \u0026#34;key\u0026#34;: \u0026#34;cases\u0026#34;,  \u0026#34;value\u0026#34;: 187332  },  {  \u0026#34;key\u0026#34;: \u0026#34;deaths\u0026#34;,  \u0026#34;value\u0026#34;: 7477  },  {  \u0026#34;key\u0026#34;: \u0026#34;recovered\u0026#34;,  \u0026#34;value\u0026#34;: 80843  },  {  \u0026#34;key\u0026#34;: \u0026#34;updated\u0026#34;,  \u0026#34;value\u0026#34;: 1584448850495  } ] Como voc√™ pode observar, o comando/filtro passado para o jq foi '. | to_entries'. √â importante que voc√™ observe duas coisas:\n O comando/filtro est√° entre \u0026lsquo;aspas simples\u0026rsquo;. Tem um | pipe dentro das aspas simples.  O jq permite que voc√™ envie a sa√≠da de um comando/filtro para outro usando | pipes, mas para isso √© importante que eles estejam dentro das aspas. Caso contr√°rio o shell vai interpretar que o | pipe est√° sendo enviado para ele (o shell).\nContinuando\u0026hellip;\nN√≥s queremos usar o par key-value para posteriormente salvar esse conte√∫do em um array. Vamos prosseguir (fique atento √†s explica√ß√µes nos coment√°rios entre os comandos abaixo):\n$ curl --silent \u0026#39;https://disease.sh/v3/covid-19/all\u0026#39; \\  | jq \u0026#39;. | to_entries\u0026#39; [  {  \u0026#34;key\u0026#34;: \u0026#34;cases\u0026#34;,  \u0026#34;value\u0026#34;: 187404  },  {  \u0026#34;key\u0026#34;: \u0026#34;deaths\u0026#34;,  \u0026#34;value\u0026#34;: 7478  },  {  \u0026#34;key\u0026#34;: \u0026#34;recovered\u0026#34;,  \u0026#34;value\u0026#34;: 80848  },  {  \u0026#34;key\u0026#34;: \u0026#34;updated\u0026#34;,  \u0026#34;value\u0026#34;: 1584450050381  } ] $ # to_entries retornou um array de objetos. $ # Vamos pegar s√≥ o que est√° dentro do array usando \u0026#39;.[]\u0026#39; $ curl --silent \u0026#39;https://disease.sh/v3/covid-19/all\u0026#39; \\  | jq \u0026#39;. | to_entries | .[]\u0026#39; {  \u0026#34;key\u0026#34;: \u0026#34;cases\u0026#34;,  \u0026#34;value\u0026#34;: 187404 } {  \u0026#34;key\u0026#34;: \u0026#34;deaths\u0026#34;,  \u0026#34;value\u0026#34;: 7478 } {  \u0026#34;key\u0026#34;: \u0026#34;recovered\u0026#34;,  \u0026#34;value\u0026#34;: 80848 } {  \u0026#34;key\u0026#34;: \u0026#34;updated\u0026#34;,  \u0026#34;value\u0026#34;: 1584450050381 } $ # agora vamos pegar somente o valor de cada $ # propriedade, coloc√°-las em apenas uma linha $ # e separar os valores com um \u0026#39;=\u0026#39; (igual) $ curl --silent \u0026#39;https://disease.sh/v3/covid-19/all\u0026#39; \\  | jq -r \u0026#39;. | to_entries | .[] | .key + \u0026#34;=\u0026#34; + .value\u0026#39; jq: error (at \u0026lt;stdin\u0026gt;:0): string (\u0026#34;cases \u0026#34;) and number (187404) cannot be added $ # Whooops! o sinal de + serve para concatenar strings, $ # mas se algum operando √© um n√∫mero, o + √© um operador aritm√©tico. $ # Portanto vamos converter esse n√∫mero para string. $ curl --silent \u0026#39;https://disease.sh/v3/covid-19/all\u0026#39; \\  | jq -r \u0026#39;. | to_entries | .[] | .key + \u0026#34;=\u0026#34; + (.value|tostring)\u0026#39; cases=188146 deaths=7497 recovered=80848 updated=1584450650499 Prontinho! Essa sa√≠da est√° perfeita para o nosso prop√≥sito!\nTerceiro Passo: salvando os dados em um array associativo Para armazenar as informa√ß√µes fornecidas pelo jq, vamos usar um array associativo.\nUm array associativo √© aquele que voc√™ acessa os elementos atrav√©s de um identificador, geralmente chamado de chave (ou key). Exemplo: se voc√™ atribui carro[cor]='prata', a partir da√≠ voc√™ pode fazer echo \u0026quot;${carro[cor]}\u0026quot; (voc√™ pode aprender mais sobre arrays de uma maneira geral neste artigo do amigo Blau Araujo.)\nPara alimentar o nosso array, vamos usar um redirecionamento para while read. O trecho de c√≥digo a seguir faz esse servi√ßo:\n# covid.sh - ainda um prot√≥tipo... # deixando claro que data √© um array associativo declare -A data json2array() { local jsonData=\u0026#34;$1\u0026#34; while IFS== read -r key value; do data[$key]=\u0026#34;$value\u0026#34; done \u0026lt; \u0026lt;(jq -r \u0026#39;. | to_entries | .[] | .key + \u0026#34;=\u0026#34; + (.value|tostring)\u0026#39; \u0026lt;\u0026lt;\u0026lt;\u0026#34;$jsonData\u0026#34;) } Em um outro artigo eu explico em detalhes essa t√©cnica de redirecionar conte√∫do para um while read. Aqui eu vou explicar de maneira breve:\n  IFS==: como vimos no t√≥pico acima, aquele comando jq vai me fornecer um conte√∫do parecido com isso: cases=188146. Portanto, se eu setar o IFS como = sinal de igual, ele vai separar cases e 188146 em dois argumentos.\n  read -r key value: como o read receber√° dois argumentos, o primeiro ser√° $key e o segundo ser√° $value.\n  data[$key]=\u0026quot;$value\u0026quot;: como data √© um array associativo, aqui teremos algo do tipo data[cases]=\u0026quot;188146\u0026quot;.\n  Vamos executar a fun√ß√£o acima de maneira interativa e ver se tudo est√° correto:\n$ # \u0026#34;carregando\u0026#34; a fun√ß√£o nessa inst√¢ncia do shell $ . covid.sh $ $ # vamos colocar o JSON em uma vari√°vel: $ myJson=\u0026#34;$(curl --silent \u0026#39;https://disease.sh/v3/covid-19/all\u0026#39;)\u0026#34; $ $ # agora sim vamos passar o JSON para alimentar o array: $ json2array \u0026#34;$myJson\u0026#34; $ $ # nada aconteceu... mas o array j√° est√° populado! :) $ echo \u0026#34;casos: ${data[cases]}\u0026#34; casos: 188433 $ echo \u0026#34;mortes: ${data[deaths]}\u0026#34; mortes: 7500 Massa! Agora temos o que precisamos para escrever um scriptzinho que ir√° nos mostrar os n√∫meros globais e do Brasil! :)\n√öltimo Passo: o script Nesse script n√≥s vamos consultar os n√∫meros referentes aos dados globais e do Brasil.\n#!/usr/bin/env bash # covid.sh ########## # # Imprime n√∫meros a respeito do COVID-19 (doen√ßa causada pelo Coronavirus). # readonly API_URL=\u0026#39;https://disease.sh/v3/covid-19\u0026#39; # deixando claro que data √© um array associativo declare -A data json2array() { local jsonData=\u0026#34;$1\u0026#34; # verificando se √© um JSON v√°lido jq empty \u0026lt;\u0026lt;\u0026lt;\u0026#34;$jsonData\u0026#34; 2\u0026gt;/dev/null || return 1 while IFS== read -r key value; do data[$key]=\u0026#34;$value\u0026#34; done \u0026lt; \u0026lt;(jq -r \u0026#39;. | to_entries | .[] | .key + \u0026#34;=\u0026#34; + (.value|tostring)\u0026#39; \u0026lt;\u0026lt;\u0026lt;\u0026#34;$jsonData\u0026#34;) } main() { local json # primeiro dados globais: json=\u0026#34;$(curl --silent \u0026#34;${API_URL}/all\u0026#34;)\u0026#34; if ! json2array \u0026#34;$json\u0026#34;; then echo \u0026#34;ERRO: falha ao obter os dados de $API_URL\u0026#34; \u0026gt;\u0026amp;2 exit 1 fi echo -n \u0026#34; ========================================= CASOS DE COVID-19 OFICIALMENTE REPORTADOS ========================================== √öltima atualiza√ß√£o: $( date -d @$((data[updated] / 1000)) ) Dados Globais ^^^^^^^^^^^^^ N√∫mero de casos..............: ${data[cases]} N√∫mero de mortes.............: ${data[deaths]} Pacientes curados............: ${data[recovered]} \u0026#34; # obtendo dados do Brasil json=\u0026#34;$(curl --silent \u0026#34;${API_URL}/countries/brazil\u0026#34;)\u0026#34; if ! json2array \u0026#34;$json\u0026#34;; then echo \u0026#34;ERRO: falha ao obter os dados de $API_URL\u0026#34; \u0026gt;\u0026amp;2 exit 1 fi echo -n \u0026#34; Dados Referentes ao Brasil ^^^^^^^^^^^^^^^^^^^^^^^^^^ N√∫mero de casos..............: ${data[cases]} Casos registrados hoje.......: ${data[todayCases]} N√∫mero de mortes.............: ${data[deaths]} Mortes registradas hoje......: ${data[todayDeaths]} Pacientes curados............: ${data[recovered]} Pacientes em situa√ß√£o cr√≠tica: ${data[critical]} \u0026#34; } main \u0026#34;$@\u0026#34; Agora vamos o script em a√ß√£o:\n$ ./covid.sh ========================================= CASOS DE COVID-19 OFICIALMENTE REPORTADOS ========================================== √öltima atualiza√ß√£o: Ter Mar 17 11:30:50 -03 2020 Dados Globais ^^^^^^^^^^^^^ N√∫mero de casos..............: 188623 N√∫mero de mortes.............: 7511 Pacientes curados............: 80874 Dados Referentes ao Brasil ^^^^^^^^^^^^^^^^^^^^^^^^^^ N√∫mero de casos..............: 301 Casos registrados hoje.......: 67 N√∫mero de mortes.............: 1 Mortes registradas hoje......: 1 Pacientes curados............: 2 Pacientes em situa√ß√£o cr√≠tica: 18 Passo Extra: aprimore o script! Sugest√µes de melhorias que voc√™ pode implementar neste script como exerc√≠cio:\n  Possibilidade de fornecer o nome do pa√≠s como par√¢metro na linha de comando, e ent√£o obter os dados referente ao pa√≠s informado.\n  Usar o printf para imprimir os n√∫meros de uma maneira mais \u0026ldquo;leg√≠vel\u0026rdquo;. Exemplo: 188.623 no lugar de 188623.\n  Acessar o endpoint https://disease.sh/v3/covid-19/countries e imprimir os 5 pa√≠ses com maior n√∫mero de casos/mortes.\n  Use sua criatividade\u0026hellip;\n  Fontes  https://github.com/disease-sh/API - reposit√≥rio com a descri√ß√£o de como usar a api rest. https://stedolan.github.io/jq/manual/ - manual do jq https://jqplay.org/ - √≥tima ferramenta para treinar jq e ajudar a montar seu comando/filtro. https://debxp.org/cbpb/aula-6-vetores/ - uma aula do amigo Blau Araujo sobre arrays no bash.  ","permalink":"https://meleu.sh/coronavirus/","summary":"O mundo est√° em p√¢nico! O tal do Coronavirus est√° se alastrando rapidamente pelo mundo. Mesmo que exista uma turma tentando minimizar o alarde e nos convencer que n√£o tem necessidade de tanto p√¢nico, dizendo que existem/existiram outras doen√ßas matando muito mais\u0026hellip; O melhor √© se prevenir!\nUma das recomenda√ß√µes que est√£o sendo dadas √© para que as pessoas n√£o saiam de casa. E j√° que vamos ficar em casa (stay at /home), que tal um pouco de nerdeza para distrair?","title":"Consulte os n√∫meros de casos e mortes causadas pelo Coronavirus diretamente do terminal"},{"content":"Um conhecido servi√ßo de \u0026ldquo;encurtamento de URL\u0026rdquo; que existe na web √© o https://bitly.com. Neste site podemos criar vers√µes mais curtas para URLs grandes. Se voc√™ j√° se deparou com links do tipo bit.ly/AlgumaCoisa, sabe do que estou falando, certo?\nNeste artigo vamos usar a API do bitly.com atrav√©s do curl e assim criar o nosso pr√≥prio \u0026ldquo;URL shortener\u0026rdquo; para usar direto da linha de comando.\nSe voc√™ n√£o conhece o curl, trata-se de um comando bastante poderoso e √∫til, que serve para transferir dados de/para servidores usando diversos protocolos (HTTP, HTTPS, FTP, TELNET, e muitos outros). Neste artigo veremos apenas uma pequena fra√ß√£o de todo o poder do curl.\nPrimeiro Passo: criar uma conta no bitly.com Para podermos usar a API do bitly.com, vamos precisar criar uma conta. O processo √© bastante simples e direto, v√° no site https://bitly.com e clique no link \u0026ldquo;Sign up\u0026rdquo; no canto superior direito.\nUma vez criada a conta e confirmado o seu registro via email, voc√™ poder√° acessar o seu \u0026ldquo;dashboard\u0026rdquo;. √â uma tela parecida com essa:\nSegundo Passo: obter um access token Ali no canto superior direito (onde na minha imagem est√° escrito \u0026ldquo;Meleu Zord\u0026rdquo;) voc√™ vai clicar e vai aparecer um menu. Escolha \u0026ldquo;Profile Settings\u0026rdquo; e em seguida escolha \u0026ldquo;Generic Access Token\u0026rdquo;. Voc√™ ver√° algo parecido com isso:\nDigite sua senha naquele campo onde est√° escrito \u0026ldquo;PASSWORD\u0026rdquo; e tecle enter. Voc√™ receber√° seu access token, que √© uma string bem loucona tipo isso: ac4b1cabb9264079c4e9f2532804f81364c09b12 (este √© um token inv√°lido e fict√≠cio).\nTerceiro Passo: acessando a API do bitly com o curl Lendo a documenta√ß√£o do bitly.com √© poss√≠vel entender como usar a API, mas aqui j√° vou te dar tudo mastigadinho.\nAutentica√ß√£o ao Portador A autentica√ß√£o feita na API do bitly.com √© atrav√©s de um m√©todo conhecido como \u0026ldquo;bearer authentication\u0026rdquo;. Trata-se de um esquema de autentica√ß√£o envolvendo tokens criptografados chamados de bearer tokens. Geralmente estes tokens s√£o gerados e fornecidos pelo servidor, e foi exatamente o que fizemos no segundo passo acima.\nA palavra inglesa bearer em portugu√™s significa \u0026ldquo;portador\u0026rdquo;, portanto podemos interpretar esse tal de bearer authentication como \u0026ldquo;d√™ acesso ao portador deste token\u0026rdquo;.\nPara usarmos esta metodologia de autentica√ß√£o atrav√©s do curl, fazemos da seguinte forma:\ncurl \\ --header \u0026#34;Authorization: Bearer ac4b1cabb9264079c4e9f2532804f81364c09b12\u0026#34; Essa linha de comando ainda n√£o est√° pronta\u0026hellip;\nPassando dados no formato JSON A vers√£o mais atual da API do bitly (vers√£o 4) espera receber dados no formato JSON. E neste JSON precisamos passar a propriedade long_url contendo a URL que queremos encurtar.\nNo exemplo abaixo vamos encurtar a URL https://meleu.sh/elemento-presente-no-array/ (muita aten√ß√£o nas aspas!):\ncurl \\ --header \u0026#34;Authorization: Bearer ac4b1cabb9264079c4e9f2532804f81364c09b12\u0026#34; \\ --header \u0026#34;Content-Type: application/json\u0026#34; \\ --data \u0026#39;{ \u0026#34;long_url\u0026#34;: \u0026#34;https://meleu.sh/elemento-presente-no-array/\u0026#34; }\u0026#39; Calma que o comando ainda n√£o est√° pronto! Precisamos dizer ao curl para onde vamos enviar estas informa√ß√µes\u0026hellip;\nAcessando o endpoint shorten O endpoint da API respons√°vel por encurtar URLs √© o shorten, e ele √© acessado atrav√©s desta URL: https://api-ssl.bitly.com/v4/shorten.\nPortanto o comando completo (e pronto para ser usado) vai ficar parecido com isso (lembre-se que o token abaixo √© inv√°lido, use o seu pr√≥prio token):\ncurl \\ --header \u0026#34;Authorization: Bearer ac4b1cabb9264079c4e9f2532804f81364c09b12\u0026#34; \\ --header \u0026#34;Content-Type: application/json\u0026#34; \\ --data \u0026#39;{ \u0026#34;long_url\u0026#34;: \u0026#34;https://meleu.sh/elemento-presente-no-array/\u0026#34; }\u0026#39; \\ https://api-ssl.bitly.com/v4/shorten Se tudo der certo com o comando acima, receberemos como resposta um JSON parecido com isso (se o seu der errado, lembre-se de reconferir o seu token):\n{\u0026#34;created_at\u0026#34;:\u0026#34;2020-02-16T01:16:54+0000\u0026#34;,\u0026#34;id\u0026#34;:\u0026#34;bit.ly/2StrCQC\u0026#34;,\u0026#34;link\u0026#34;:\u0026#34;http://bit.ly/2StrCQC\u0026#34;,\u0026#34;custom_bitlinks\u0026#34;:[],\u0026#34;long_url\u0026#34;:\u0026#34;https://meleu.sh/elemento-presente-no-array/\u0026#34;,\u0026#34;archived\u0026#34;:false,\u0026#34;tags\u0026#34;:[],\u0026#34;deeplinks\u0026#34;:[],\u0026#34;references\u0026#34;:{\u0026#34;group\u0026#34;:\u0026#34;https://api-ssl.bitly.com/v4/groups/bK311XKuDpS\u0026#34;}} Uma zona, n√£o √© mesmo? Vamos ajeitar esse output usando o jq.\nQuarto Passo: pegando somente o link curto O jq √© um comandinho que serve para processar dados no formato JSON.\nN√£o faz parte do escopo deste artigo explicar o que √© JSON nem os detalhes de como usar o jq (talvez num pr√≥ximo artigo). Ent√£o vou apenas mostrar aqui a \u0026ldquo;receitinha de bolo\u0026rdquo; de como obter o que queremos.\nPara tornar aquele \u0026ldquo;tijol√£o\u0026rdquo; de JSON que obtivemos como resposta, basta mandarmos esse conte√∫do para o jq da seguinte maneira:\ncurl \\ --header \u0026#34;Authorization: Bearer ac4b1cabb9264079c4e9f2532804f81364c09b12\u0026#34; \\ --header \u0026#34;Content-Type: application/json\u0026#34; \\ --data \u0026#39;{ \u0026#34;long_url\u0026#34;: \u0026#34;https://meleu.sh/elemento-presente-no-array/\u0026#34; }\u0026#39; \\ https://api-ssl.bitly.com/v4/shorten \\ | jq \u0026#39;.\u0026#39; Isso vai gerar uma sa√≠da mais leg√≠vel, desse tipo:\n{ \u0026#34;created_at\u0026#34;: \u0026#34;2020-02-16T01:16:54+0000\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;bit.ly/2StrCQC\u0026#34;, \u0026#34;link\u0026#34;: \u0026#34;http://bit.ly/2StrCQC\u0026#34;, \u0026#34;custom_bitlinks\u0026#34;: [], \u0026#34;long_url\u0026#34;: \u0026#34;https://meleu.sh/elemento-presente-no-array/\u0026#34;, \u0026#34;archived\u0026#34;: false, \u0026#34;tags\u0026#34;: [], \u0026#34;deeplinks\u0026#34;: [], \u0026#34;references\u0026#34;: { \u0026#34;group\u0026#34;: \u0026#34;https://api-ssl.bitly.com/v4/groups/bK311XKuDpS\u0026#34; } } Bem mais leg√≠vel, certo?\nComo podemos observar, a propriedade que nos interessa √© a link, portanto vamos pegar somente ela. Desta forma:\ncurl \\ --header \u0026#34;Authorization: Bearer ac4b1cabb9264079c4e9f2532804f81364c09b12\u0026#34; \\ --header \u0026#34;Content-Type: application/json\u0026#34; \\ --data \u0026#39;{ \u0026#34;long_url\u0026#34;: \u0026#34;https://meleu.sh/elemento-presente-no-array/\u0026#34; }\u0026#39; \\ https://api-ssl.bitly.com/v4/shorten \\ | jq \u0026#39;.link\u0026#39; Isso vai gerar simplesmente:\n\u0026#34;http://bit.ly/2StrCQC\u0026#34; Quinto Passo: lidando com URLs inv√°lidas E se o usu√°rio quiser encurtar uma URL inv√°lida?\nPoder√≠amos criar uma RegEx para verificar isso de antem√£o, mas vamos pensar melhor: com certeza um o a API do bitly.com sabe lidar com isso!\nVamos ver o que acontece se passarmos uma url inv√°lida:\ncurl \\ --header \u0026#34;Authorization: Bearer ac4b1cabb9264079c4e9f2532804f81364c09b12\u0026#34; \\ --header \u0026#34;Content-Type: application/json\u0026#34; \\ --data \u0026#39;{ \u0026#34;long_url\u0026#34;: \u0026#34;IssoN√£o√âUmaURL\u0026#34; }\u0026#39; \\ https://api-ssl.bitly.com/v4/shorten \\ | jq \u0026#39;.\u0026#39; Isso vai gerar essa sa√≠da:\n{ \u0026#34;message\u0026#34;: \u0026#34;INVALID_ARG_LONG_URL\u0026#34;, \u0026#34;resource\u0026#34;: \u0026#34;bitlinks\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;The value provided is invalid.\u0026#34;, \u0026#34;errors\u0026#34;: [ { \u0026#34;field\u0026#34;: \u0026#34;long_url\u0026#34;, \u0026#34;error_code\u0026#34;: \u0026#34;invalid\u0026#34; } ] } Neste JSON retornado, n√£o existe a propriedade link. Al√©m disso o conte√∫do da propriedade description parece bastante apropriado para mostrar ao usu√°rio quuando ele mandar uma URL inv√°lida.\nPortanto vamos usar o recurso if-then-else do jq e mostrar o link se estiver tudo certo, e mostrar description se tiver dado algum problema:\ncurl \\ --header \u0026#34;Authorization: Bearer ac4b1cabb9264079c4e9f2532804f81364c09b12\u0026#34; \\ --header \u0026#34;Content-Type: application/json\u0026#34; \\ --data \u0026#39;{ \u0026#34;long_url\u0026#34;: \u0026#34;IssoN√£o√âUmaURL\u0026#34; }\u0026#39; \\ https://api-ssl.bitly.com/v4/shorten \\ | jq \u0026#39;if .link == null then .description else .link end\u0026#39; Isso vai gerar:\nThe value provided is invalid. Perfeito! Acho que j√° temos tudo que precisamos para transformar isso num script!\nSexto Passo: transformando tudo isso num script #!/usr/bin/env bash # shortener.sh - encurtador de URLs # TODO: o token abaixo √© inv√°lido! use o seu token! readonly BITLY_TOKEN=\u0026#39;ac4b1cabb9264079c4e9f2532804f81364c09b12\u0026#39; readonly BITLY_ENDPOINT=\u0026#39;https://api-ssl.bitly.com/v4/shorten\u0026#39; shortener() { local long_url=\u0026#34;$1\u0026#34; while [[ -z \u0026#34;$long_url\u0026#34; ]]; do read -r -p \u0026#34;Digite a url: \u0026#34; long_url done curl -s \\ --header \u0026#34;Authorization: Bearer ${BITLY_TOKEN}\u0026#34; \\ --header \u0026#34;Content-Type: application/json\u0026#34; \\ --data \u0026#34;{\\\u0026#34;long_url\\\u0026#34;:\\\u0026#34;${long_url}\\\u0026#34;}\u0026#34; \\ \u0026#34;${BITLY_ENDPOINT}\u0026#34; \\ | jq -r \u0026#39;if .link == null then .description else .link end\u0026#39; } shortener \u0026#34;$@\u0026#34; Fontes  A mente brilhante por tr√°s dessa solu√ß√£o √© o colega Robson Alexandre, que agraciou os participantes do nosso grupo de telegram de shell script com uma vers√£o que usa a vers√£o 3 da API do bitly. Peguei o script dele como inspira√ß√£o e atualizei aqui para usar a vers√£o 4 da API. manpage do curl manpage do jq Usando if-then-else no jq: https://stedolan.github.io/jq/manual/v1.6/#ConditionalsandComparisons P√°gina para praticar jq: https://jqplay.org/  ","permalink":"https://meleu.sh/url-shortener/","summary":"Um conhecido servi√ßo de \u0026ldquo;encurtamento de URL\u0026rdquo; que existe na web √© o https://bitly.com. Neste site podemos criar vers√µes mais curtas para URLs grandes. Se voc√™ j√° se deparou com links do tipo bit.ly/AlgumaCoisa, sabe do que estou falando, certo?\nNeste artigo vamos usar a API do bitly.com atrav√©s do curl e assim criar o nosso pr√≥prio \u0026ldquo;URL shortener\u0026rdquo; para usar direto da linha de comando.\nSe voc√™ n√£o conhece o curl, trata-se de um comando bastante poderoso e √∫til, que serve para transferir dados de/para servidores usando diversos protocolos (HTTP, HTTPS, FTP, TELNET, e muitos outros).","title":"Como gerar uma URL curta no bitly direto da linha de comando"},{"content":"O shell script √© uma \u0026ldquo;linguagem\u0026rdquo; muito permissiva. N√£o √© necess√°rio muito conhecimento pra voc√™ come√ßar a fazer algumas coisas legais. Isso √© bom, fazer coisas legais √© divertido, mas tamb√©m tem um perigo embutido: voc√™ pode acabar ir levando adiante uma pr√°tica ruim que funciona em determinado cen√°rio mas que em outro pode trazer consequ√™ncias indesejadas (a n√£o utiliza√ß√£o de aspas duplas pra proteger suas vari√°veis √© um exemplo dessas pr√°ticas ruins).\nNuma tentativa de difundir essa cultura das boas pr√°ticas de programa√ß√£o em shell script, vou come√ßar a escrever tamb√©m artigos abordando os conceitos mais b√°sicos e fundamentais do shell script.\nPra come√ßar, hoje falarei sobre par√¢metros da linha de comando. Mesmo que voc√™ j√° conhe√ßa esse tema t√£o fundamental para o shell script, garanto que vai tirar algo de √∫til desse artigo. Pois vamos entender no detalhe a real diferen√ßa entre $* e $@, o que o $0 tem de t√£o peculiar, e tamb√©m veremos o comando shift e o set.\nPar√¢metros Um par√¢metro da linha de comando √© qualquer coisa vem ap√≥s o nome do comando. Exemplo:\n$ ls -l arquivo.txt Na linha de comando acima, o ls √© o comando, o -l √© o primeiro par√¢metro (as vezes chamado de argumento), e o arquivo.txt √© o segundo par√¢metro.\nSitua√ß√£o similar acontece quando algu√©m executa nosso script assim:\n$ ./meuscript.sh um dois tres Aqui ./meuscript.sh √© o comando, um √© o primeiro par√¢metro, dois √© o segundo, e tres √© o terceiro.\nN√≥s temos acesso a estes par√¢metros atrav√©s de algumas vari√°veis \u0026ldquo;especiais\u0026rdquo;. Digo especiais pois elas n√£o s√£o exatamente como as vari√°veis que normalmente usamos.\nPra come√ßar elas n√£o obedecem as regras de nomeclatura de vari√°veis, pois elas usam n√∫meros; e tamb√©m n√≥s n√£o podemos mudar o valor destas vari√°veis pelas vias \u0026ldquo;tradicionais\u0026rdquo; de atribui√ß√£o (s√≥ conseguimos alterar seus valores com a ajuda de comandos dedicados a isso, como o shift e o set, que veremos adiante).\nVeja esta rela√ß√£o:\n   par√¢metro significado     $0 SEMPRE ser√° o nome (ou o caminho) do scriptchamado na linha de comando (mais detalhes abaixo)   $1, $2, a $9 $1: 1¬∫ par√¢metro, $2: 2¬∫ par√¢metro, at√© o $9.Passados para o script ou fun√ß√£o.   ${10}, ${11}, \u0026hellip; quando o n√∫mero do par√¢metro possui maisde um d√≠gito √© necess√°rio o uso das chaves.   $* todos os par√¢metros passados para o script ou fun√ß√£oem uma √∫nica string (mais detalhes abaixo)   $@ todos os par√¢metros passados para o script ou fun√ß√£ocada um em strings separadas.   $# n√∫mero de par√¢metros (sem contar com o $0).    Pra ficar mais claro, nada melhor do que um exemplo:\n#!/usr/bin/env bash # parametros.sh echo \u0026#34;Nome do script: $0\u0026#34; echo \u0026#34;N√∫mero total de par√¢metros: $#\u0026#34; echo \u0026#34;Primeiro par√¢metro: $1\u0026#34; echo \u0026#34;Segundo par√¢metro: $2\u0026#34; echo \u0026#34;D√©cimo quinto par√¢metro: ${15}\u0026#34; echo \u0026#34;Todos os par√¢metros: $*\u0026#34; Vamos passar o alfabeto inteiro para esse script e dar uma olhada:\n$ ./parametros.sh a b c d e f g h i j k l m n o p q r s t u v w x y z Nome do script: ./parametros.sh N√∫mero total de par√¢metros: 26 Primeiro par√¢metro: a Segundo par√¢metro: b D√©cimo quinto par√¢metro: o Todos os par√¢metros: a b c d e f g h i j k l m n o p q r s t u v w x y z Par√¢metros para fun√ß√µes Os par√¢metros funcionam do mesmo jeito para fun√ß√µes. Por√©m com apenas uma nuance: $0 n√£o ser√° o nome da fun√ß√£o, e sim o nome do comando shell script (ou do shell, se estiver direto no prompt).\nVejamos um exemplo que deixa isso bastante claro:\n#!/usr/bin/env bash # parametroParaFuncao.sh minhaFuncao() { echo \u0026#34;---\u0026gt; argumento zero: $0\u0026#34; echo \u0026#34;---\u0026gt; 3¬∫ argumento (dentro de $FUNCNAME): $3\u0026#34; } echo \u0026#34;3¬∫ argumento (antes da fun√ß√£o): $3\u0026#34; minhaFuncao a b c d e f g h i j k l m n o ... echo \u0026#34;3¬∫ argumento (depois da fun√ß√£o): $3\u0026#34; Em execu√ß√£o:\n$ ./parametroFuncao.sh um dois tres 3¬∫ argumento (antes da fun√ß√£o): tres ---\u0026gt; argumento zero: ./parametroFuncao.sh ---\u0026gt; 3¬∫ argumento (dentro de minhaFuncao): c 3¬∫ argumento (depois da fun√ß√£o): tres Observe as duas linhas que come√ßam com ---\u0026gt;. Note como que dentro de minhaFuncao o $0 expandiu para o nome do script. E, na linha seguinte, como $3 expandiu para c, que foi o terceiro argumento passado para minhaFuncao (enquanto que o terceiro argumento passado para o script foi tres).\nObserve tamb√©m um easter egg que eu coloquei ali pra voc√™s: $FUNCNAME expande para o nome da fun√ß√£o que est√° sendo executada (na verdade FUNCNAME faz um pouco mais que isso, mas isso √© papo pra outro artigo).\nDiferen√ßa entre $* e $@ Conforme dito na tabela acima, o $* significa todos os par√¢metros em uma √∫nica string, e o $@ significa todos os par√¢metros, cada um em strings separadas.\nNo script a seguir veremos isso bem claramente:\n#!/usr/bin/env bash # testargs.sh # # Ao executar este script use alguns parametros. Ex.: # $ ./testargs.sh um dois tres quatro if [[ -z \u0026#34;$1\u0026#34; ]]; then echo \u0026#34;Uso: $0 argumento1 argumento2 etc\u0026#34; exit 1 fi echo \u0026#34;---\u0026gt; Listando argumentos com \\\u0026#34;\\$*\\\u0026#34;:\u0026#34; num=1 for arg in \u0026#34;$*\u0026#34;; do echo \u0026#34;argumento #$num = $arg\u0026#34; ((num++)) done # Conclus√£o: $* mostra todos os argumentos como uma √∫nica string echo \u0026#34;---\u0026gt; Listando argumentos com \\\u0026#34;\\$@\\\u0026#34;:\u0026#34; num=1 for arg in \u0026#34;$@\u0026#34;; do echo \u0026#34;argumento #$num = $arg\u0026#34; ((num++)) done # Conclus√£o: $@ mostra cada argumento em strings separadas Executando o script acima:\n$ ./testargs.sh um dois tres quatro ---\u0026gt; Listando argumentos com \u0026#34;$*\u0026#34;: argumento #1 = um dois tres quatro ---\u0026gt; Listando argumentos com \u0026#34;$@\u0026#34;: argumento #1 = um argumento #2 = dois argumento #3 = tres argumento #4 = quatro Acho que com o exemplo acima ficou claro, certo?\nAgora para entendermos no detalhe a real diferen√ßa entre o $* e o $@ √© necess√°rio conhecermos a vari√°vel $IFS.\nAs letras IFS s√£o uma sigla para Internal Field Separator, esta vari√°vel √© respons√°vel por \u0026ldquo;quebrar\u0026rdquo; o conte√∫do de uma linha de comando em argumentos separados. Geralmente o conte√∫do da $IFS √© espa√ßo, tabula√ß√£o e nova linha. Portanto quando o shell encontra esses caracteres ele os ignora e encara o que vem a seguir como um novo par√¢metro.\n(Se voc√™ n√£o tem a menor ideia do que estou falando, n√£o precisa se desesperar. Fica aqui meu compromisso de posteriormente escrever um artigo detalhando o $IFS de uma maneira que voc√™ nunca mais vai esquecer.)\nVoltando ao nosso tema: diferen√ßa entre o $* e o $@.\nQuando voc√™ usa a nota√ß√£o com asterisco \u0026quot;$*\u0026quot;, o bash vai expandir isso para uma √∫nica string com o valor de cada par√¢metro separado pelo primeiro caractere da vari√°vel IFS. Ou seja, se o primeiro caractere da vari√°vel IFS √© c, ent√£o um \u0026quot;$*\u0026quot; vai expandir para \u0026quot;$1c$2c$3c...\u0026quot; (uma √∫nica string com o valor de cada par√¢metro separado por c).\nComo normalmente o primeiro caractere da vari√°vel $IFS √© espa√ßo, na maioria das vezes o \u0026quot;$*\u0026quot; √© expandido para \u0026quot;$1 $2 $3 ...\u0026quot;.\nAgora no caso da nota√ß√£o com arroba \u0026quot;$@\u0026quot;, o bash vai expandir isso para cada par√¢metro entre aspas separados por um espa√ßo. Ou seja, um \u0026quot;$@\u0026quot; vai expandir para \u0026quot;$1\u0026quot; \u0026quot;$2\u0026quot; \u0026quot;$3\u0026quot; ... (cada par√¢metro entre aspas, separados por um espa√ßo).\nResumo\n @ arroba: expande separando com um espa√ßo. * asterisco: expande separando com o primeiro caractere do $IFS.  A prop√≥sito: se tem curiosidade de ver como essa \u0026ldquo;sintonia\u0026rdquo; do $* com o $IFS pode ser bem aproveitada, d√° uma olhada no artigo Como juntar elementos de um array separando-os com um caracter qualquer.\nO comando shift O bash possui um comando embutido para lidar com par√¢metros: o shift.\nPara entender o shift √© legal usarmos uma analogia de fila de supermercado. Imagine uma fila com 10 pessoas, quando o primeiro √© atendido, o segundo passa a ser o primeiro da fila, o terceiro ser√° o segundo e assim por diante. E a fila agora tem 9 pessoas.\nO shift √© um comando que faz \u0026ldquo;a fila andar\u0026rdquo;.\nQuando voc√™ usa o shift o primeiro par√¢metro da lista some e o segundo vai para $1, o terceiro vai para $2, e assim por diante.\nVoc√™ pode tamb√©m especificar quantas \u0026ldquo;pessoas da fila voc√™ vai atender\u0026rdquo; atrav√©s do comando shift N onde N √© o n√∫mero de \u0026ldquo;pessoas\u0026rdquo;.\nExemplo: se voc√™ usar shift 2, tanto o primeiro como o segundo par√¢metro somem e o $3 vira $1, o $4 vira $2 e assim por diante.\nOBSERVA√á√ÉO: se n for maior que o n√∫mero de par√¢metros o shift n√£o √© executado.\nVeja este exemplo:\n#!/bin/bash # shift-example.sh echo \u0026#34;$#: $*\u0026#34; echo -e \u0026#34;executando \\\u0026#34;shift\\\u0026#34;\u0026#34; shift echo \u0026#34;$#: $*\u0026#34; echo -e \u0026#34;executando \\\u0026#34;shift 5\\\u0026#34;\u0026#34; shift 5 echo \u0026#34;$#: $*\u0026#34; echo -e \u0026#34;executando \\\u0026#34;shift 7\\\u0026#34;\u0026#34; shift 7 echo \u0026#34;$#: $*\u0026#34; Em execu√ß√£o:\n$ ./shift-exemplo.sh 1 2 3 4 5 6 7 8 9 0 10: 1 2 3 4 5 6 7 8 9 0 executando \u0026#34;shift\u0026#34; 9: 2 3 4 5 6 7 8 9 0 executando \u0026#34;shift 5\u0026#34; 4: 7 8 9 0 executando \u0026#34;shift 7\u0026#34; 4: 7 8 9 0 Lembre-se: Os valores que saem s√£o perdidos. Se for precisar deles, salve-os em alguma vari√°vel.\nUma maneira muito √∫til de usar o shift √© para ir pegando op√ß√µes da linha de comando (--help, --verbose, etc.). Pretendo escrever um post sobre isso em breve, mas se voc√™ quiser pode ver diretamente na fonte de onde eu aprendi: Cap√≠tulo 4 do livro Shell Script Profissional do Aur√©lio.\nO comando set para editar par√¢metros O que vou passar neste t√≥pico n√£o √© sobre como usar \u0026ldquo;todo o poder do comando set\u0026rdquo;, e sim como usar set especificamente para editar par√¢metros. N√£o tem nenhum segredo! Veja este exemplo:\nset um dois tres Isso far√° com que $1 seja um, $2 seja dois, $3 seja tres e s√≥! Os valores anteriores, se existiam, ser√£o sobrescritos, e tamb√©m n√£o existir√° $4, $5, etc. mesmo que eles tenham existido antes do set.\nVeja um exemplo de script:\n#!/usr/bin/env bash # setparam.sh echo \u0026#34;--\u0026gt; Os $# par√¢metros passados inicialmente foram:\u0026#34; echo \u0026#34;$@\u0026#34; echo \u0026#34;--\u0026gt; Mas agora eu vou alter√°-los para \u0026#39;um\u0026#39;, \u0026#39;dois\u0026#39; e \u0026#39;tres\u0026#39;.\u0026#34; set um dois tres echo \u0026#34;--\u0026gt; Os $# novos par√¢metros agora s√£o: echo \u0026#34;$@\u0026#34; N√£o interessa quantos par√¢metros voc√™ passar para este script, no final voc√™ s√≥ ter√° $1, $2 e $3 valendo um, dois e tres, respectivamente.\n$ ./setparam.sh eu adoro programa√ß√£o shell --\u0026gt; Os 4 par√¢metros passados inicialmente foram: eu adoro programa√ß√£o shell --\u0026gt; Mas agora eu vou alter√°-los para \u0026#39;um\u0026#39;, \u0026#39;dois\u0026#39; e \u0026#39;tres\u0026#39;. --\u0026gt; Os 3 novos par√¢metros agora s√£o: um dois tres Um exemplo de uso engenhoso do set eu aprendi no \u0026ldquo;Phrack Extraction Utility\u0026rdquo; e reproduzi num script similar que escrevi e que pode ser visto nesse link.\nFontes  man bash na se√ß√£o de \u0026ldquo;Special Parameters\u0026rdquo; help shift help set https://mywiki.wooledge.org/BashGuide/Parameters livro: Shell Script Profissional, do Aur√©lio Jargas.  ","permalink":"https://meleu.sh/parametros/","summary":"O shell script √© uma \u0026ldquo;linguagem\u0026rdquo; muito permissiva. N√£o √© necess√°rio muito conhecimento pra voc√™ come√ßar a fazer algumas coisas legais. Isso √© bom, fazer coisas legais √© divertido, mas tamb√©m tem um perigo embutido: voc√™ pode acabar ir levando adiante uma pr√°tica ruim que funciona em determinado cen√°rio mas que em outro pode trazer consequ√™ncias indesejadas (a n√£o utiliza√ß√£o de aspas duplas pra proteger suas vari√°veis √© um exemplo dessas pr√°ticas ruins).","title":"Como lidar com par√¢metros passados na linha de comando em shell scripts"},{"content":"Esse post √© para tentar convenc√™-los de que suas vari√°veis devem ser protegidas com aspas duplas SEMPRE. E quando eu digo sempre, √© sempre mesmo. At√© mesmo em $(subshells).\nOK\u0026hellip; T√° bom. As vezes precisamos referenciar vari√°veis sem aspas, mas fa√ßa isso s√≥ quando for estritamente necess√°rio. E quando isso acontecer, deixe um coment√°rio falando sobre esta necessidade.\nInsisto: N√£o fique perdendo tempo pensando \u0026ldquo;Uhmm\u0026hellip; Ser√° que tem problema se eu deixar essa vari√°vel sem aspas?\u0026rdquo;. Simplesmente use-as. E quando precisar n√£o us√°-las, deixe isso claro atrav√©s de um coment√°rio.\nNOTA: lembrando que estou levando em considera√ß√£o o bash. Se voc√™ est√° usando outro shell o comportamento pode ser diferente, mas ainda assim eu recomendo seguir essa \u0026ldquo;regra\u0026rdquo;.\nMotivos Refer√™ncias a vari√°veis sem usar aspas ir√£o bugar seu script. Tenha essa certeza. Vamos ver alguns exemplos.\no shell vai pensar que tem mais par√¢metros do que voc√™ realmente est√° passando #!/usr/bin/env bash # fileInfo.sh # informa√ß√µes sobre o arquivo passado como par√¢metro arquivo=$1 file $arquivo $ # criando um arquivo cujo nome contem espa√ßos $ echo \u0026#34;dummy file\u0026#34; \u0026gt; \u0026#34;nome com espa√ßos\u0026#34; $ $ # veja o problema: $ ./fileInfo.sh \u0026#34;nome com espa√ßos\u0026#34; nome: cannot open `nome\u0026#39; (No such file or directory) com: cannot open `com\u0026#39; (No such file or directory) espa√ßos: cannot open `espa√ßos\u0026#39; (No such file or directory) $ Use aspas para expandir $@ ou ${array[@]} para um loop for:\n#!/usr/bin/env bash # forLoops.sh forSemAspas() { for word in $@; do echo word: $word done } forComAspas() { for word in \u0026#34;$@\u0026#34;; do echo \u0026#34;word: $word\u0026#34; done } $ . forLoops.sh $ forSemAspas um dois \u0026#34;dois e meio\u0026#34; tres word: um word: dois word: dois word: e word: meio word: tres $ forComAspas um dois \u0026#34;dois e meio\u0026#34; tres word: um word: dois word: dois e meio word: tres $ o shell vai pensar que tem menos par√¢metros do que voc√™ realmente est√° passando Problemas com o printf:\n$ arg1=\u0026#34;um\u0026#34; $ arg2=\u0026#34;dois\u0026#34; $ arg3=\u0026#34;tres\u0026#34; $ printf \u0026#34;1st: %s\\n2nd: %s\\n3rd: %s\\n\u0026#34; $arg1 $arg2 $arg3 1st: um 2nd: dois 3rd: tres $ $ # agora vamos deixar arg2 vazio $ arg2= $ $ printf \u0026#34;1st: %s\\n2nd: %s\\n3rd: %s\\n\u0026#34; $arg1 $arg2 $arg3 1st: um 2nd: tres 3rd: $ # arg3 virou o segundo argumento! :( $ $ # usando aspas, tudo fica deboas, veja: $ printf \u0026#34;1st: %s\\n2nd: %s\\n3rd: %s\\n\u0026#34; \u0026#34;$arg1\u0026#34; \u0026#34;$arg2\u0026#34; \u0026#34;$arg3\u0026#34; 1st: um 2nd: 3rd: tres $ exce√ß√µes Observe que as exce√ß√µes s√£o muito bem espec√≠ficas\u0026hellip;\nquando voc√™ realmente quer uma lista de palavras separadas por espa√ßos Algumas vezes queremos uma lista de palavras bem separadinhas por espa√ßos, por exemplo quando queremos que cada palavra seja um elemento distinto de um array:\narray=( $* ) # OBS: necess√°rio deixar sem aspas No meu artigo sobre case convertion voc√™ ver√° um exemplo de como precisei de uma lista de palavras individualmente separadas por espa√ßos para que cada uma fosse um elemento distinto de um array.\nquando estiver usando express√£o regular dentro de um [[ ... ]] N√£o use aspas quando sua vari√°vel for uma express√£o regular que voc√™ quer usar com o [[ e =~:\n$ string=\u0026#39;se curte shell, visite meleu.sh\u0026#39; $ regex=\u0026#39;meleu\\.sh$\u0026#39; $ # express√£o regular para: \u0026#34;meleu.sh\u0026#34; seguido de final da linha $ $ [[ \u0026#34;$string\u0026#34; =~ $regex ]] \u0026amp;\u0026amp; echo sim || echo nao sim $ [[ \u0026#34;$string\u0026#34; =~ \u0026#34;$regex\u0026#34; ]] \u0026amp;\u0026amp; echo sim || echo nao nao $ # express√£o regular entre aspas √© considerada uma string literal Palavras finais Observe que na se√ß√£o de motivos, eu elenquei casos de uso muito comuns de se ver em qualquer script. S√£o situa√ß√µes que acontecem com frequencia. Enquanto as excessoes acontecem com uma frequ√™ncia muito menor.\nPortanto vou insistir pela quarta ou quinta vez:\nRegra n¬∫ 1: SEMPRE USE ASPAS.\nRegra n¬∫ 2: se violar a regra n¬∫ 1 se for estritamente necess√°rio e mencione isso num coment√°rio.\nFontes  http://mywiki.wooledge.org/Quotes http://wiki.bash-hackers.org/syntax/quoting  ","permalink":"https://meleu.sh/aspas-sempre/","summary":"Esse post √© para tentar convenc√™-los de que suas vari√°veis devem ser protegidas com aspas duplas SEMPRE. E quando eu digo sempre, √© sempre mesmo. At√© mesmo em $(subshells).\nOK\u0026hellip; T√° bom. As vezes precisamos referenciar vari√°veis sem aspas, mas fa√ßa isso s√≥ quando for estritamente necess√°rio. E quando isso acontecer, deixe um coment√°rio falando sobre esta necessidade.\nInsisto: N√£o fique perdendo tempo pensando \u0026ldquo;Uhmm\u0026hellip; Ser√° que tem problema se eu deixar essa vari√°vel sem aspas?","title":"Por que voc√™ deve usar aspas SEMPRE"},{"content":"Desde a vers√£o 4.0 do bash (lan√ßada em 2009) n√≥s temos dispon√≠vel alguns operadores para lidar com case conversion.\nNos exemplos a seguir imagine que var cont√©m uma string:\n ${var,,}: conte√∫do de var todo em min√∫sculas ${var^^}: conte√∫do de var todo em mai√∫sculas ${var,}: primeira letra de var min√∫scula ${var^}: primeira letra de var mai√∫scula ${var~~}: inverte de mai√∫sculo para min√∫sculo, ou vice-versa, todo o conte√∫do de var ${var~}: inverte de mai√∫sculo para min√∫sculo, ou vice-versa, a primeira letra de var  Fun√ß√µes Para Case Conversion De posse desse conhecimento, vamos fazer nossas vers√µes bash de toLower() e toUpper() e, por que n√£o?, de camelCase().\n#!/usr/bin/env bash # lowUpCamel.sh toLower() { echo \u0026#34;${*,,}\u0026#34; } toUpper() { echo \u0026#34;${*^^}\u0026#34; } camelCase() { local array=( ${*,,} ) # 1. tudo min√∫sculo. OBS: sem \u0026#34;aspas\u0026#34; local string=\u0026#34;${array[*]^}\u0026#34; # 2. primeiras letras mai√∫sculas echo \u0026#34;${string// /}\u0026#34; # 3. remove espa√ßos } Tanto em toLower() quanto em toUpper() estamos pegando todos os argumentos usando o $*, s√≥ que j√° aproveitamos para fazer a convers√£o usando os operadores que aprendemos aqui neste artigo.\nAgora analisemos a fun√ß√£o camelCase().\nPrimeiramente pegamos todos os argumentos (vindo de $*) e armazenamos em array j√° convertendo tudo para min√∫sculo. √â importante que a express√£o n√£o esteja entre aspas, para que cada string sem espa√ßos seja um elemento distinto no array.\nEm seguida armazenamos em string cada elemento de array j√° convertendo a primeira letra de cada elemento para mai√∫scula.\nE por √∫ltimo usamos um echo para mostrar na tela o conte√∫do de string s√≥ que removendo todos os espa√ßos.\nNota: se voc√™ √© do tipo preciosista e quer argumentar que num camel case \u0026ldquo;de verdade\u0026rdquo; a primeira letra tem que ser min√∫scula, fica ent√£o como um exerc√≠cio reescrever a fun√ß√£o camelCase() para lidar com isso. Aqui est√° uma dica de leitura para realizar essa tarefa. ;)\nAplica√ß√£o Pr√°tica: Renomeando arquivos Na minha opini√£o a op√ß√£o de converter tudo para min√∫sculo com ${var,,} √© especialmente √∫til. Isso pelo simples fato de ser comum querermos renomear arquivos para que seus nomes fiquem todos em min√∫sculo.\nImaginemos por exemplo aqueles arquivos de fotos tiradas pela m√°quina fotogr√°fica ou celular: IMG_20200125_102030.JPG.\nPara renomear todos os arquivos com nomes desse tipo para sua vers√£o min√∫scula, basta fazermos:\nfor arquivo in *.JPG; do mv \u0026#34;$arquivo\u0026#34; \u0026#34;${arquivo,,}\u0026#34; ; done Tamb√©m podemos criar um script mvlower.sh que simplesmente recebe uma lista de arquivos e renomeia cada um deles para sua vers√£o com letras min√∫sculas:\n#!/usr/bin/env bash # mvlower.sh mvLower() { local filepath local dirpath local filename for filepath in \u0026#34;$@\u0026#34;; do # OBS: temos que preservar o path do diret√≥rio! dirpath=$(dirname \u0026#34;$filepath\u0026#34;) filename=$(basename \u0026#34;$filepath\u0026#34;) mv \u0026#34;$filepath\u0026#34; \u0026#34;${dirpath}/${filename,,}\u0026#34; done } mvLower \u0026#34;$@\u0026#34; Fontes  release notes do bash 4.0: https://lists.gnu.org/archive/html/bug-bash/2009-02/msg00164.html compila√ß√£o das principais features adicionadas ao bash em cada vers√£o: https://mywiki.wooledge.org/BashFAQ/061 explica√ß√£o para a t√©cnica de remover espa√ßos usada na fun√ß√£o camelCase: https://www.tldp.org/LDP/abs/html/parameter-substitution.html#PSGLOB tive a ideia para esse post lendo o livro \u0026ldquo;bash Cookbook\u0026rdquo; de Carl Albing e JP Vossen.  ","permalink":"https://meleu.sh/tolower-toupper/","summary":"Desde a vers√£o 4.0 do bash (lan√ßada em 2009) n√≥s temos dispon√≠vel alguns operadores para lidar com case conversion.\nNos exemplos a seguir imagine que var cont√©m uma string:\n ${var,,}: conte√∫do de var todo em min√∫sculas ${var^^}: conte√∫do de var todo em mai√∫sculas ${var,}: primeira letra de var min√∫scula ${var^}: primeira letra de var mai√∫scula ${var~~}: inverte de mai√∫sculo para min√∫sculo, ou vice-versa, todo o conte√∫do de var ${var~}: inverte de mai√∫sculo para min√∫sculo, ou vice-versa, a primeira letra de var  Fun√ß√µes Para Case Conversion De posse desse conhecimento, vamos fazer nossas vers√µes bash de toLower() e toUpper() e, por que n√£o?","title":"Como converter de mai√∫sculas para min√∫sculas (e vice-versa) com bash"},{"content":"Uma das coisas que voc√™ certamente vai encarar um dia como um programador de shell scripts √© a necessidade de percorrer um arquivo inteiro lendo cada linha e fazer algo com este conte√∫do. Veremos neste artigo como fazer isso de maneira segura, robusta e evitando as poss√≠veis armadilhas que podem aparecer no caminho.\nPra adiantar seu lado, vou logo de cara lhe dar a solu√ß√£o que eu considero mais robusta. Em seguida explica cada detalhe dessa estrutura.\nwhile IFS= read -r linha || [[ -n \u0026#34;$linha\u0026#34; ]]; do echo \u0026#34;$linha\u0026#34; # fa√ßa algo mais interessante aqui... done \u0026lt; \u0026#34;$arquivo\u0026#34; Dei esse grande spoiler pois percebi que esse artigo ficou relativamente grande, e uma das coisas que mais valorizo aqui √© o seu tempo.\nSe voc√™ s√≥ quer a solu√ß√£o, ali est√° ela. Mas se quiser entender cada detalhezinho dessa estrutura, continue lendo.\nA minha explica√ß√£o vai partir da solu√ß√£o na√Øve (ou seja, a solu√ß√£o mais b√°sica e ing√™nua) de como percorrer cada linha de um arquivo. E a partir de cada problema que encontrarmos vamos adicionar uma maneira de contornar. No final de tudo teremos aquela estrutura que mostrei acima.\nSolu√ß√£o 1: read linha Para fins did√°ticos, imaginemos que queremos um script que simplesmente imprima na tela cada linha de um arquivo de maneira similar ao uso mais b√°sico do comando cat.\nVamos chamar esse script de mycat.sh, e usaremos redirecionamento para um loop while para alcan√ßar o nosso objetivo.\nA primeira vez que eu ouvi falar de redirecionamento de conte√∫do de um arquivo para um loop (h√° duas d√©cadas atr√°s), a primeira coisa que tentei foi o seguinte:\n#!/usr/bin/env bash # mycat.sh # # vers√£o 1: solu√ß√£o na√Øve arquivo=\u0026#34;$1\u0026#34; while read linha; do echo \u0026#34;$linha\u0026#34; done \u0026lt; \u0026#34;$arquivo\u0026#34; N√≥s vamos testando se o nosso mycat.sh est√° legal atrav√©s da compara√ß√£o com a sa√≠da do comando cat real.\n$ # primeiro com cat $ cat echo-e.txt Uma coisa interessante sobre o comando \u0026#39;echo\u0026#39; √© que quando usamos a op√ß√£o -e podemos usar algumas sequ√™ncias de caracteres com um significado especial. Por exemplo \\n significa uma nova linha, e \\t significa \u0026lt;TAB\u0026gt;. $ $ # depois com mycat.sh $ ./mycat.sh echo-e.txt Uma coisa interessante sobre o comando \u0026#39;echo\u0026#39; √© que quando usamos a op√ß√£o -e podemos usar algumas sequ√™ncias de caracteres com um significado especial. Por exemplo n significa uma nova linha, e t significa \u0026lt;TAB\u0026gt;. $ Aparentemente tudo bem. Mas ali na √∫ltima linha ao inv√©s de exibir \\n e \\t, o script mostrou apenas n e t. Ou seja, ele \u0026ldquo;engoliu\u0026rdquo; a contra-barra.\nMas n√≥s sabemos que o read √© cheio de op√ß√µes. Deve ter uma maneira de resolver isso.\nDando uma olhada no help read encontramos a op√ß√£o -r, que diz \u0026ldquo;do not allow backslashes to escape any characters\u0026rdquo;. Ou seja, n√£o permitir o contra-barra de \u0026ldquo;escapar\u0026rdquo; caracter algum.\nOK, hora de melhorar o nosso script\u0026hellip;\nSolu√ß√£o 2: read -r linha Direto ao c√≥digo:\n#!/usr/bin/env bash # mycat.sh # # vers√£o 1: solu√ß√£o na√Øve # vers√£o 2: lidando com \\contrabarras\\ arquivo=\u0026#34;$1\u0026#34; while read -r linha; do echo \u0026#34;$linha\u0026#34; done \u0026lt; \u0026#34;$arquivo\u0026#34; Vamos como o mycat.sh vai lidar com o echo-e.txt agora:\n$ ./mycat.sh echo-e.txt Uma coisa interessante sobre o comando \u0026#39;echo\u0026#39; √© que quando usamos a op√ß√£o -e podemos usar algumas sequ√™ncias de caracteres com um significado especial. Por exemplo \\n significa uma nova linha, e \\t significa \u0026lt;TAB\u0026gt;. $ Opa! Legal! Vamos testar agora com um arquivo simples.txt que possui um pouquinho mais de conte√∫do:\n$ # primeiro com o cat $ cat simples.txt Este √© um arquivo texto muito simples =====================================  Este √© o primeiro par√°grafo.  Aqui no segundo par√°grafo vamos colocar alguns caracteres com \\contrabarra\\, como por exemplo o \\n e o \\t, s√≥ para testes...  Acho que est√° tudo bem. Vamos terminando aqui no terceiro par√°grafo. At√© pr√≥xima! $ $ # agora com o mycat.sh $ ./mycat.sh simples.txt Este √© um arquivo texto muito simples ===================================== Este √© o primeiro par√°grafo. Aqui no segundo par√°grafo vamos colocar alguns caracteres com \\contrabarra\\, como por exemplo o \\n e o \\t, s√≥ para testes... Acho que est√° tudo bem. Vamos terminando aqui no terceiro par√°grafo. At√© pr√≥xima! $ As contra-barras, OK. Mas agora tem uma outra inconsist√™ncia ali: os espa√ßos no in√≠cio de cada par√°grafo foram omitidos. :(\nIsso est√° acontecendo porque usamos o read para atribuir um valor a uma vari√°vel, ele automaticamente ignora os espa√ßos que ficam tanto no come√ßo como no final do conte√∫do que voc√™ informar como entrada.\nNa verdade isso acontece devido a vari√°vel de ambiente $IFS. As letras IFS s√£o um acr√¥nimo para Internal Field Separator, esta vari√°vel √© respons√°vel por \u0026ldquo;quebrar\u0026rdquo; o conte√∫do de uma linha de comando em argumentos separados.\nGeralmente o conte√∫do do IFS √© espa√ßo, tabula√ß√£o e nova linha. Portanto quando o shell encontra esses caracteres ele os ignora e encara o que vem a seguir como um novo par√¢metro.\n(Se voc√™ n√£o tem a menor ideia do que estou falando, n√£o precisa se desesperar. Fica aqui meu compromisso de posteriormente escrever um artigo detalhando o $IFS de uma maneira que voc√™ nunca mais vai esquecer.)\nPara contornar esse problema do script ficar \u0026ldquo;engolindo\u0026rdquo; os espa√ßos no come√ßo das linhas, vamos usar um $IFS vazio. Assim o read vai considerar que tudo que est√° vindo como entrada √© apenas um √∫nico argumento.\nSolu√ß√£o 3: IFS= read -r linha #!/usr/bin/env bash # mycat.sh # # vers√£o 1: solu√ß√£o na√Øve # vers√£o 2: lidando com \\contrabarras\\ # vers√£o 3: lidando com espa√ßos no in√≠cio/fim arquivo=\u0026#34;$1\u0026#34; while IFS= read -r linha; do echo \u0026#34;$linha\u0026#34; done \u0026lt; \u0026#34;$arquivo\u0026#34; Essa sintaxe que estamos usando IFS= read -r linha √© uma maneira de dizer ao shell que queremos alterar a vari√°vel de ambiente $IFS apenas para a execu√ß√£o do comando read que vem a seguir.\nEssa \u0026ldquo;t√©cnica\u0026rdquo; √© mencionada l√° na manpage do bash, na se√ß√£o que fala sobre ENVIRONMENT, num par√°grafo que diz o seguinte: (tradu√ß√£o livre):\n O ambiente para qualquer comando simples ou fun√ß√£o pode ser temporariamente alterado prefixando o comando/fun√ß√£o com atribui√ß√µes de par√¢metro (\u0026hellip;). Estas atribui√ß√µes afetam somente o ambiente visto por aquele comando.\n Portanto, IFS= read -r linha vai alterar o IFS somente durante a execu√ß√£o do read, depois disso ele volta ao normal.\nVamos testar:\n$ # primeiro com cat $ cat simples.txt Este √© um arquivo texto muito simples =====================================  Este √© o primeiro par√°grafo.  Aqui no segundo par√°grafo vamos colocar alguns caracteres com \\contrabarra\\, como por exemplo o \\n e o \\t, s√≥ para testes...  Acho que est√° tudo bem. Vamos terminando aqui no terceiro par√°grafo. At√© pr√≥xima! $ $ # agora com mycat.sh $ ./mycat.sh simples.txt Este √© um arquivo texto muito simples =====================================  Este √© o primeiro par√°grafo.  Aqui no segundo par√°grafo vamos colocar alguns caracteres com \\contrabarra\\, como por exemplo o \\n e o \\t, s√≥ para testes...  Acho que est√° tudo bem. Vamos terminando aqui no terceiro par√°grafo. At√© pr√≥xima! $ Agora sim! Tudo igualzinho ao cat!\nAparentemente j√° temos uma solu√ß√£o bastante robusta, n√£o √© mesmo?\nPor√©m na nossa vida acontecem coisas inesperadas\u0026hellip; Ao longo da sua vida de programador shell-script voc√™ vai se deparar com arquivos que n√£o foram gerados num ambiente UNIX-like. Podendo inclusive se deparar com um arquivo texto que n√£o terminha com um caractere nova linha.\nPara simular tal situa√ß√£o vamos utilizar o head com a op√ß√£o -c (note que nos exemplos a seguir algumas vezes o prompt aparece em lugares diferentes):\n$ # quero apenas 105 bytes de simples.txt $ head -c 105 simples.txt Este √© um arquivo texto muito simples =====================================  Este √© o primeiro par√°g$ $ # obs: prompt aqui ----^ $ $ # vamos jogar isso num arquivo $ head -c 105 simples.txt \u0026gt; atipico.txt $ $ # testando com cat $ cat atipico.txt Este √© um arquivo texto muito simples =====================================  Este √© o primeiro par√°g$ $ # obs: prompt aqui ----^ $ $ $ # agora vamos testar com mycat.sh $ ./mycat.sh atipico.txt Este √© um arquivo texto muito simples ===================================== $ Eita! No teste com mycat.sh a √∫ltima linha foi omitida!\n√â que no mundo UNIX o caractere nova linha √© realmente levado muito a s√©rio\u0026hellip;\nO problema do mycat.sh acontece porque quando o read n√£o encontra o caracter de nova linha ele \u0026ldquo;retorna falso\u0026rdquo; (ou seja, ao final da execu√ß√£o a vari√°vel $? √© diferente de zero).\nNo entanto uma coisa curiosa acontece: mesmo retornando falso, o valor da vari√°vel √© atualizado.\nObserve essa demonstra√ß√£o:\n$ # testando com var1 $ read var1 digitei isso e teclei \u0026lt;ENTER\u0026gt; $ echo \u0026#34;$?\u0026#34; 0 $ # esse zero significa que o read terminou com sucesso $ echo \u0026#34;$var1\u0026#34; digitei isso e teclei \u0026lt;ENTER\u0026gt; $ $ # vamos a outro teste, com var2 $ read var2 mandando um end-of-file com \u0026lt;CTRL+D\u0026gt;$ echo \u0026#34;$?\u0026#34; 1 $ # esse um significa que o read terminou com alguma falha $ echo \u0026#34;$var2\u0026#34; mandando um end-of-file com \u0026lt;CTRL+D\u0026gt; $ # no entanto o conte√∫do de var2 foi atualizado! Desta forma ficou claro que quando o read recebe alguns caracteres e encontra um end-of-file antes de encontrar um nova linha, acontecem duas coisas:\n O conte√∫do da vari√°vel √© atualizado. O read retorna com falha.  Vamos nos aproveitar destes dois fatos e tornar o nosso mycat.sh ainda mais robusto!\nSolu√ß√£o 4: IFS= read -r linha || [[ -n \u0026quot;$line\u0026quot; ]] #!/usr/bin/env bash # mycat.sh # # vers√£o 1: solu√ß√£o na√Øve # vers√£o 2: lidando com \\contrabarras\\ # vers√£o 3: lidando com espa√ßos no in√≠cio/fim # vers√£o 4: lidando com t√©rmino inesperado do input arquivo=\u0026#34;$1\u0026#34; while IFS= read -r linha || [[ -n \u0026#34;$linha\u0026#34; ]]; do echo \u0026#34;$linha\u0026#34; done \u0026lt; \u0026#34;$arquivo\u0026#34; A sintaxe || pode ser \u0026ldquo;traduzida\u0026rdquo; como \u0026ldquo;se, e somente se, o comando a esquerda do || falhar, execute o comando a direita\u0026rdquo;. Portanto, caso o read falhe o script testa se a vari√°vel $linha n√£o est√° vazia. Isso √© aproveitar aqueles fatos que mencionei acima (1. read falha; 2. vari√°vel √© atualizada).\nAgora, se o read falhar e tamb√©m o teste da vari√°vel $linha vazia falhar, a√≠ chegamos ao fim do while.\nVamos direto ao teste:\n$ # primeiro com cat $ cat atipico.txt Este √© um arquivo texto muito simples =====================================  Este √© o primeiro par√°g$ $ # prompt voltou aqui --^ $ $ # agora testando com mycat.sh $ ./mycat.sh atipico.txt Este √© um arquivo texto muito simples =====================================  Este √© o primeiro par√°g $ # \u0026lt;-- o prompt voltou aqui $ OK\u0026hellip; N√£o ficou 100% igual, pois com o cat o prompt retorna logo ap√≥s o final efetivo do arquivo.\nO mycat.sh imprime um nova linha ap√≥s o final do arquivo. No entanto isso n√£o √© um caracter nova linha que milagrosamente apareceu ao final de $linha, mas sim um nova linha impresso pelo echo. Portanto se voc√™ est√° usando essa estrutura para percorrer o arquivo linha por linha para fazer um processamento mais s√©rio do que simplesmente imprimir a linha, pode ficar tranquilo que os dados estar√£o √≠ntegros.\nUfa! Acabamos!\nFontes  https://mywiki.wooledge.org/BashFAQ/001 help read https://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html#Environment  ","permalink":"https://meleu.sh/percorrer-arquivo/","summary":"Uma das coisas que voc√™ certamente vai encarar um dia como um programador de shell scripts √© a necessidade de percorrer um arquivo inteiro lendo cada linha e fazer algo com este conte√∫do. Veremos neste artigo como fazer isso de maneira segura, robusta e evitando as poss√≠veis armadilhas que podem aparecer no caminho.\nPra adiantar seu lado, vou logo de cara lhe dar a solu√ß√£o que eu considero mais robusta. Em seguida explica cada detalhe dessa estrutura.","title":"Como ler o conte√∫do de um arquivo linha por linha em shell script"},{"content":"O que √© um here string? Um here string nada mais √© do que uma maneira de transformar uma string na entrada padr√£o (stdin) de um programa. Normalmente utilizamos essa t√©cnica pegando a string contida em uma vari√°vel.\nA sintaxe, pegando de uma vari√°vel, √© a seguinte:\nCOMMAND \u0026lt;\u0026lt;\u0026lt; \u0026#34;$VAR\u0026#34; Onde o conte√∫do vari√°vel $VAR ser√° colocado na entrada padr√£o do COMMAND.\nUsar a t√©cnica do here string evita o uso de estruturas como:\n# uso desnecess√°rio do echo echo \u0026#34;$var\u0026#34; | grep padrao Podemos obter o mesmo resultado usando a sintaxe do here string:\ngrep padrao \u0026lt;\u0026lt;\u0026lt; \u0026#34;$var\u0026#34; Na minha opini√£o, o c√≥digo fica mais limpo e leg√≠vel desta forma. Al√©m disso, tamb√©m temos um ganho de performance.\nA explica√ß√£o para isso est√° num trecho do manual do bash que fala de Pipelines (tradu√ß√£o livre):\n Cada comando em um pipeline √© executado em seu pr√≥prio subshell, o que √© um processo separado (\u0026hellip;)\n Ou seja, a cada pipe um subshell √© inicializado, e isso gera um custo de performance. Principalmente se voc√™ estiver fazendo isso dentro de um loop com dezenas/centenas de itera√ß√µes.\nEspero que estes dois fatores (1. c√≥digo limpo, 2. performance) sejam motivos suficientes para voc√™ come√ßar a usar o here string a partir de agora.\nQuando n√£o usar here strings Conforme podemos ver no pr√≥prio manual do bash (tradu√ß√£o livre):\n O resultado √© enviado √† entrada padr√£o do comando, como uma √∫nica string e com uma nova linha adicionada ao final\n Portanto, em casos onde esse caractere de nova linha n√£o √© desejado, n√£o podemos usar o here string. Estes casos s√£o bem raros, mas acontecem.\nEu me deparei com esse problema quando estava trabalhando numa aplica√ß√£o onde eu precisava calcular o checksum MD5 dos 8 primeiros bytes de um arquivo. Vou ilustrar o problema atrav√©s do exemplo a seguir:\n$ cat texto.txt conteudo do arquivo $ head -c8 texto.txt | md5sum b59853db2f3ef8f156a72e38c30ba7d2 - $ $ # armazenando o conte√∫do em uma variavel $ variavel=$(head -c8 texto.txt) $ md5sum \u0026lt;\u0026lt;\u0026lt; \u0026#34;$variavel\u0026#34; 746378123fbe2cbca33ed5d88f35c5bb - $ # u√©! era pra ser igual ao md5 l√° de cima! $ $ # vejamos com o \u0026#39;echo -n\u0026#39; (sem nova linha no final): $ echo -n \u0026#34;$variavel\u0026#34; | md5sum b59853db2f3ef8f156a72e38c30ba7d2 - $ # agora sim! o checksum √© igual! :) Conforme podemos ver, nas rar√≠ssimas situa√ß√µes onde o caracter de nova linha no final da string pode alterar o resultado desejado, o uso de here strings n√£o resolve.\nCuidado com o exagero Legal, voc√™ aprendeu que usando here strings voc√™ tem um ganho de performance, mas tamb√©m n√£o precisa ficar fissurado com isso e usar here strings em toda e qualquer oportunidade.\nEntenda que a fun√ß√£o dessa t√©cnica √© colocar uma string no arquivo de entrada padr√£o de um comando.\nEu j√° vi um caso onde a pessoa usou comando \u0026lt;\u0026lt;\u0026lt; $(\u0026lt; arquivo). Ou seja, atrav√©s do redirecionamento no $() ele colocou o conte√∫do de um arquivo numa string para logo em seguida mandar essa string para a entrada padr√£o do comando. Neste caso bastava usar simplesmente comando \u0026lt; arquivo.\nFontes  https://www.tldp.org/LDP/abs/html/x17837.html https://www.gnu.org/software/bash/manual/html_node/Redirections.html#Here-Strings https://www.gnu.org/software/bash/manual/html_node/Pipelines.html#Pipelines  ","permalink":"https://meleu.sh/here-strings/","summary":"O que √© um here string? Um here string nada mais √© do que uma maneira de transformar uma string na entrada padr√£o (stdin) de um programa. Normalmente utilizamos essa t√©cnica pegando a string contida em uma vari√°vel.\nA sintaxe, pegando de uma vari√°vel, √© a seguinte:\nCOMMAND \u0026lt;\u0026lt;\u0026lt; \u0026#34;$VAR\u0026#34; Onde o conte√∫do vari√°vel $VAR ser√° colocado na entrada padr√£o do COMMAND.\nUsar a t√©cnica do here string evita o uso de estruturas como:","title":"here string: evitando o uso desnecess√°rio do echo"},{"content":"Recentemente conheci mais um site que certamente √© muito √∫til para iniciantes e at√© mesmo para usu√°rios de linha de comando j√° iniciados: https://explainshell.com/\nconhe√ßa o https://explainshell.com Na p√°gina inicial deste site tem um campo de texto onde voc√™ pode digitar uma linha de comando inteira (incluindo at√© mesmo | pipes e \u0026lt;\u0026lt; redirecionamentos \u0026gt;) e obter uma explica√ß√£o do(s) comando(s) e de cada um dos argumentos utilizados.\nPor exemplo, clique neste link para ver a explica√ß√£o de find / -type d -name deleteme 2\u0026gt;/dev/null.\nAs informa√ß√µes dos comandos e suas respectivas op√ß√µes s√£o provenientes das manpages. Poder√≠amos consultar tudo isso diretamente no sistema, √© verdade. Mas ter uma explica√ß√£o breve somente das op√ß√µes que estamos usando √© uma comodidade atraente. Sem contar que ele tamb√©m explica, pipes, redirecionamentos, etc.\nexplainshell no terminal OK. Legal. Tudo muito bonitinho\u0026hellip; Mas s√≥ que para n√≥s, amantes da telinha preta, ter que abrir o browser, entrar na p√°gina e fazer uma consulta dessas n√£o tem muito cabimento, n√© mesmo?\nA primeira coisa que pensei quando vi explainshell foi \u0026ldquo;Cara! Seria muito massa se tivesse uma ferramenta dessas diretamente na linha de comando!\u0026rdquo;\nDando uma olhada no reposit√≥rio com o c√≥digo do explainshell.com, eu observei que v√°rias pessoas tamb√©m possuem este mesmo desejo de ter o explainshell diretamente na linha de comando. Mas infelizmente este recurso ainda n√£o existe.\nO mais pr√≥ximo a isso que eu vi, foi um pequeno script (basicamente um PoC - Proof of Concept) criado por um dos usu√°rios e compartilhado em um gist, onde ele pega a sa√≠da de um w3m -dump e usa o grep para dar uma limpeza.\nTomei a liberdade de expandir o script acrescentando um pouco mais de robustez e a op√ß√£o de ver a resposta no terminal ou abrir no browser.\no script explainshell Eis o meu c√≥digo:\n#!/usr/bin/env bash # explainshell - faz uma consulta a explainshell.com para # obter a explica√ß√£o da linha de comando. # # DEPEND√äNCIA: w3m, grep, xdg-open (se quiser abrir no browser) # # inspira√ß√£o: # https://gist.github.com/shivansh/a05e3b4152fa75f6f398d423c295edb5 readonly MAIN_URL=\u0026#39;https://explainshell.com/explain?cmd=\u0026#39; # se quiser abrir no browser, mude para USE_BROWSER=\u0026#39;true\u0026#39; readonly USE_BROWSER=\u0026#39;false\u0026#39; # explica√ß√£o desta fun√ß√£o em https://meleu.sh/urlencode/ urlencode() { local LC_ALL=C local string=\u0026#34;$*\u0026#34; local length=\u0026#34;${#string}\u0026#34; local char for (( i = 0; i \u0026lt; length; i++ )); do char=\u0026#34;${string:i:1}\u0026#34; if [[ \u0026#34;$char\u0026#34; == [a-zA-Z0-9.~_-] ]]; then printf \u0026#34;$char\u0026#34; else printf \u0026#39;%%%02X\u0026#39; \u0026#34;\u0026#39;$char\u0026#34; fi done printf \u0026#39;\\n\u0026#39; # opcional } main() { if [[ -z \u0026#34;$1\u0026#34; ]]; then echo \u0026#34; ERRO: falta argumento Uso: $0 \u0026#39;linha de comando\u0026#39;\u0026#34; \u0026gt;\u0026amp;2 exit 1 fi local url=\u0026#34;${MAIN_URL}$(urlencode \u0026#34;$*\u0026#34;)\u0026#34; if [[ \u0026#34;$USE_BROWSER\u0026#34; == \u0026#39;true\u0026#39; ]]; then xdg-open \u0026#34;$url\u0026#34; exit \u0026#34;$?\u0026#34; fi response=$(w3m -dump \u0026#34;$url\u0026#34;) cat -s \u0026lt;(grep -v -e explainshell -e ‚Ä¢ -e ‚ñ° -e \u0026#34;source manpages\u0026#34; \u0026lt;\u0026lt;\u0026lt; \u0026#34;$response\u0026#34;) } main \u0026#34;$@\u0026#34; explicando o c√≥digo O script come√ßa com duas vari√°veis globais. A MAIN_URL √© a URL que usaremos para fazer a pesquisa. E a USE_BROWSER √© para definir se voc√™ quer obter o resultado da pesquisa no browser ou direto no terminal. Deixei USE_BROWSER='false' como default, portanto se quiser abrir no browser, mude para true (se quiser exercitar um pouco, adicione uma op√ß√£o de invocar o script com --browser, por exemplo).\nEm seguida temos a fun√ß√£o urlencode(), que foi explicada em detalhes num post anterior.\nNa fun√ß√£o main() nos certificamos se o usu√°rio passou o comando que queremos pesquisar. Se tiver passado, vamos transformar a string em uma URL v√°lida chamando a fun√ß√£o urlencode.\nEm seguida verificamos se a prefer√™ncia √© abrir no browser. Em caso positivo, a consulta ser√° aberta direto no browser. Fazemos isso com o xdg-open, mas se voc√™ estiver no MacOS, mude para open. E se tiver no Windows/Cygwin, mude para cygstart (eu falo um pouco destes comandos num post anterior).\nSe USE_BROWSER n√£o for igual √† true, significa que a consulta ser√° feita direto no terminal utilizando o m√©todo exposto pelo usu√°rio @shivansh com o w3m (certifique-se que esse programa est√° instalado no seu sistema).\nA sa√≠da desse comando no terminal n√£o √© l√° t√£o boa, como podemos ver no exemplo a seguir para a explica√ß√£o de um simples ls -lah.\n$ ./explainshell ls -lah ls(1) -lah list directory contents -l use a long listing format -a, --all  do not ignore entries starting with . -h, --human-readable  with -l, print sizes in human readable format (e.g., 1K 234M 2G) Nota-se que a explica√ß√£o do ls fica distante do comando. E se o comando for grande, com pipes\u0026hellip; Essa confus√£o vai ficar ainda maior.\nPortanto utilizar para obter um resultado leg√≠vel com esse script, s√≥ se for uma de comando pequeno.\nPara comandos grandes, √© mais interassante visualizar no site mesmo.\nFontes  https://explainshell.com/ https://github.com/idank/explainshell https://gist.github.com/shivansh/a05e3b4152fa75f6f398d423c295edb5  ","permalink":"https://meleu.sh/explainshell/","summary":"Recentemente conheci mais um site que certamente √© muito √∫til para iniciantes e at√© mesmo para usu√°rios de linha de comando j√° iniciados: https://explainshell.com/\nconhe√ßa o https://explainshell.com Na p√°gina inicial deste site tem um campo de texto onde voc√™ pode digitar uma linha de comando inteira (incluindo at√© mesmo | pipes e \u0026lt;\u0026lt; redirecionamentos \u0026gt;) e obter uma explica√ß√£o do(s) comando(s) e de cada um dos argumentos utilizados.\nPor exemplo, clique neste link para ver a explica√ß√£o de find / -type d -name deleteme 2\u0026gt;/dev/null.","title":"explainshell: obtendo uma explica√ß√£o r√°pida de uma linha de comando e cada um dos seus argumentos"},{"content":"Quando estamos escrevendo um shell script √© muito comum precisarmos verificar se um teste resultar√° em verdadeiro ou falso. Fazer esses testes muitas vezes √© tedioso, principalmente quando o comando n√£o gera sa√≠da alguma (ou seja, n√£o imprime nada na tela).\nVeremos aqui como lidar com isso de maneira simples, f√°cil e muito pr√°tica.\nA origem da ideia Geralmente eu costumo fazer essa checagem, assim:\n$ comando \u0026amp;\u0026amp; echo verdadeiro || echo falso O comando no exemplo acima est√° representando o comando a ser executado. √â s√≥ uma abstra√ß√£o, OK?\nO s√≠mbolo \u0026amp;\u0026amp; √© uma maneira do bash dizer \u0026ldquo;se o comando for finalizado com sucesso, execute o comando a seguir\u0026rdquo;. Portanto isso aqui: comando \u0026amp;\u0026amp; echo verdadeiro, significa \u0026ldquo;execute o comando e se ele terminar com sucesso, escreva \u0026lsquo;verdadeiro\u0026rsquo; na tela\u0026rdquo;.\nTemos tamb√©m o s√≠mbolo ||, que significa \u0026ldquo;se o comando for finalizado sem sucesso, execute o comando a seguir\u0026rdquo;. Portanto isso aqui: comando || echo falso, significa \u0026ldquo;execute o comando e se ele falhar, escreva \u0026lsquo;falso\u0026rsquo; na tela\u0026rdquo;.\nUma vez que entendemos a finalidade destes s√≠mbolos, podemos utiliz√°-los para fazer testes r√°pidos, como nos exemplos a seguir:\n$ file=\u0026#39;arquivo.txt\u0026#39; $ [[ -f \u0026#34;$file\u0026#34; ]] \u0026amp;\u0026amp; echo verdadeiro || echo falso falso $ user=\u0026#39;meleu\u0026#39; $ grep -q \u0026#34;$user\u0026#34; /etc/passwd \u0026amp;\u0026amp; echo verdadeiro || echo falso verdadeiro Evidentemente que poder√≠amos alcan√ßar o mesmo resultado utilizando if-else, mas isso n√£o seria nada pr√°tico.\nAli√°s, sejamos honestos, escrever \u0026amp;\u0026amp; echo verdadeiro || echo falso toda hora tamb√©m n√£o √© l√° muito pr√°tico\u0026hellip;\nCriando um alias Para evitar a digita√ß√£o excessiva, podemos criar um alias. Um alias √© um \u0026ldquo;atalho\u0026rdquo; para um comando grande e/ou complexo.\nSe voc√™ n√£o conhece a t√©cnica do alias muito provavelmente voc√™ j√° a est√° usando e nem sabia. Digite alias no seu terminal e veja o resultado.\nEis um exemplo t√≠pico:\n$ alias alias egrep=\u0026#39;egrep --color=auto\u0026#39; alias fgrep=\u0026#39;fgrep --color=auto\u0026#39; alias grep=\u0026#39;grep --color=auto\u0026#39; alias l=\u0026#39;ls -CF\u0026#39; alias la=\u0026#39;ls -A\u0026#39; alias ll=\u0026#39;ls -alF\u0026#39; alias ls=\u0026#39;ls -F --color=auto\u0026#39; Vamos pegar a √∫ltima linha acima como exemplo.\nAquele alias nos diz que quando o usu√°rio executa um ls, ele n√£o est√° simplesmente executando o ls \u0026ldquo;puro\u0026rdquo;. Ele est√° tamb√©m visualizando a lista onde o nome dos arquivos aparecem coloridos (--color=auto) e com um caractere no final do nome (-F) que servem para ajudar a distinguir o tipo do arquivo (ex.: a cor azul e o caractere / significam diret√≥rio).\nUma vez entendido o que √© e pra que serve um alias, vamos criar um para nos ajudar nos testes que mencionamos anteriormente:\n$ alias result=\u0026#39;echo verdadeiro || echo falso\u0026#39; Pronto! Agora vamos ver como isso nos ajuda:\n$ file=\u0026#39;arquivo.txt\u0026#39; $ [[ -f \u0026#34;$file\u0026#34; ]] \u0026amp;\u0026amp; result falso $ user=\u0026#39;meleu\u0026#39; $ grep -q \u0026#34;$user\u0026#34; /etc/passwd \u0026amp;\u0026amp; result verdadeiro Como voc√™ deve ter observado, uma vez definido o alias, basta adicionar \u0026amp;\u0026amp; result ap√≥s o comando que voc√™ quer testar.\nAgora sim, bem pr√°tico, n√© n√£o?!\nS√≥ tem um por√©m: ap√≥s o logoff o seu alias √© esquecido. Para torn√°-lo \u0026ldquo;permanente\u0026rdquo; precisamos salv√°-lo no nosso .bashrc.\nSalvando o alias no seu .bashrc O arquivo .bashrc que fica localizado no seu diret√≥rio home, √© basicamente script que √© executado toda vez que voc√™ inicia o bash de maneira interativa. Portanto basta salvarmos nosso alias nesse arquivo que teremos ele a nossa disposi√ß√£o sempre que precisarmos.\nV√° no seu diret√≥rio home (/home/nome_do_usuario) e procure o arquivo .bashrc (se n√£o existir, basta cri√°-lo). Abra o arquivo no seu editor de texto de prefer√™ncia.\nProvavelmente j√° vai existir bastante coisa escrita nele. Se quiser tentar dar uma olhadela no conte√∫do do arquivo e tentar entender o que est√° acontecendo l√°, voc√™ pode acabar se deparando com algumas coisas legais e aprender coisa nova. Mas vamos concluir a nossa dica logo! V√° no final do arquivo e adicione a seguinte linha:\nalias result=\u0026#39;echo verdadeiro || echo falso\u0026#39; E pronto! Agora voc√™ j√° pode testar aquele one-liner maroto apenas adicionando \u0026amp;\u0026amp; result ao final da linha! ;)\n","permalink":"https://meleu.sh/dica-result/","summary":"Quando estamos escrevendo um shell script √© muito comum precisarmos verificar se um teste resultar√° em verdadeiro ou falso. Fazer esses testes muitas vezes √© tedioso, principalmente quando o comando n√£o gera sa√≠da alguma (ou seja, n√£o imprime nada na tela).\nVeremos aqui como lidar com isso de maneira simples, f√°cil e muito pr√°tica.\nA origem da ideia Geralmente eu costumo fazer essa checagem, assim:\n$ comando \u0026amp;\u0026amp; echo verdadeiro || echo falso O comando no exemplo acima est√° representando o comando a ser executado.","title":"Uma dica simples que vai fazer voc√™ ganhar muito tempo quando estiver escrevendo shell scripts"},{"content":"No ramo de TI as coisas mudam de uma maneira absurdamente r√°pida! Por mais que voc√™ tente se manter atualizado, as tecnologias da moda est√£o sempre mudando.\nSe voc√™ √© um aspirante a programador, provavelmente passa por aquela situa√ß√£o de indecis√£o paralisante. Fica naquele receio de despedi√ßar o seu tempo estudando tecnologias que sair√£o de moda e no final do dia acabou n√£o estudando coisa alguma.\nNa sua cabe√ßa rolam perguntas como:\n Qual tecnologia/linguagem vai bombar no pr√≥ximo ano? Qual tecnologia/linguagem que eu deveria estudar?  Eu n√£o tenho a resposta sobre qual ser√° a tecnologia que vai bombar no futuro pr√≥ximo, tamb√©m n√£o quero bancar o vision√°rio dizendo qual voc√™ deveria estudar.\nO que eu sei √© que o shell resistiu (e continua resistindo) ao teste do tempo. Portanto digo com seguran√ßa: estudar shell e se sentir confort√°vel na linha de comando com certeza vai lhe trazer benef√≠cios que continuar√£o a lhe servir por longos anos\nO Bourne Shell existe h√° mais de 40 anos (desde 1979) e o Bourne Again Shell (bash) h√° mais de 30 anos (desde 1989). Hoje o bash √© onipresente est√° presente em uma vasta gama de plataformas. √â o shell padr√£o na maioria (se n√£o todas) as distribui√ß√µes Linux e no MacOS, est√° dispon√≠vel para qualquer Unix e *BSDs, est√° dispon√≠vel at√© mesmo para Windows, smartphones e mais uma infinidade de dispositivos.\nN√£o importa qual tecnologia voc√™ vai trabalhar. Seja aplica√ß√µes PHP, JavaScript com Node, Python, Go, whatever\u0026hellip; A chance de sua aplica√ß√£o estar rodando em um servidor Unix-like √© muito grande. E certamente ter√° um bash dispon√≠vel l√°.\nQualquer que seja a sua posi√ß√£o no mundo de TI, seja um estudante, programador, administrador de sistemas, DevOps, Cientista de Dados, ou at√© mesmo aquele adolescente que sonha ser um super hack√£o e dominar o mundo\u0026hellip;\nTer flu√™ncia na linha de comando √© uma habilidade muitas vezes negligenciada ou considerada obscura, mas √© uma habilidade que vai aumentar sua produtividade e sua flexibilidade ao resolver diversos problemas. Portanto ser√° um √≥timo diferencial no seu skillset.\nSe voc√™ est√° indeciso se deveria dedicar o seu precioso tempo aprendendo sobre a linha de comando e shell script, n√£o tenha d√∫vida: seu tempo n√£o ser√° desperdi√ßado!\nAli√°s, respeito pelo seu tempo √© uma das premissas fundamentais deste site. √â um dos motivos pelos quais eu n√£o coloco propagandas para te distrair neste site.\nBons estudos! E n√£o esque√ßa de se divertir durante o processo!\n","permalink":"https://meleu.sh/por-que-shell/","summary":"No ramo de TI as coisas mudam de uma maneira absurdamente r√°pida! Por mais que voc√™ tente se manter atualizado, as tecnologias da moda est√£o sempre mudando.\nSe voc√™ √© um aspirante a programador, provavelmente passa por aquela situa√ß√£o de indecis√£o paralisante. Fica naquele receio de despedi√ßar o seu tempo estudando tecnologias que sair√£o de moda e no final do dia acabou n√£o estudando coisa alguma.\nNa sua cabe√ßa rolam perguntas como:","title":"Por que voc√™ deveria aprender sobre shell e linha de comando?"},{"content":"Um recurso que facilita muito a vida do usu√°rio quando usando um gerenciador de arquivos no ambiente gr√°fico √© o fato de poder dar um duplo clique no √≠cone e o sistema j√° saber qual programa utilizar para abr√≠-lo.\nConhecendo o xdg-open Quando estamos utilizando o terminal dentro de um ambiente gr√°fico podemos ter uma funcionalidade similar usando o comando xdg-open em sistemas Linux.\nEquivalentes ao comando xdg-open em outros ambientes:\n MacOS: open Windows/Cygwin: cygstart Android/termux: xdg-open.  Nos exemplos abaixo vou usar o xdg-open, mas se voc√™ estiver em outro ambiente, substitua-o pelo comando equivalente.\nSe tiver com uma janelinha do terminal aberta, basta usar xdg-open arquivo.ext que o seu ambiente desktop vai detectar qual √© o programa padr√£o para abrir o arquivo.ext.\nE uma coisa interessante √© que isso tamb√©m serve para URLs, fazendo com que o seu navegador padr√£o seja aberto tentando visitar a URL que passada como par√¢metro. Exemplo:\nxdg-open \u0026#39;https://meleu.sh/\u0026#39; Eis uma tradu√ß√£o livre da descri√ß√£o que vemos na pr√≥pria manpage do xdg-open:\n xdg-open abre um arquivo ou URL na aplica√ß√£o preferida do usu√°rio. Se uma URL for fornecida, a URL ser√° aberta no browser padr√£o. Se um arquivo for fornecido, o arquivo ser√° aberto na aplica√ß√£o padr√£o para arquivos daquele tipo.\n A disponibilidade deste comando vai depender do ambiente Desktop que voc√™ est√° utilizando e se ele segue os padr√µes do freedesktop.org.\nO freedesktop √© um projeto focado em criar especifica√ß√µes para facilitar a interoperabiliade e compartilhamento de tecnologia para sistemas gr√°ficos e de desktop de c√≥digo aberto.\nUma pequena (e incompleta) lista dos ambientes desktop que aderem aos padr√µes do freedesktop pode ser encontrada aqui: https://www.freedesktop.org/wiki/Desktops/\nMuitas das especifica√ß√µes produzidas pelo freedesktop recebem o nome XDG, uma sigla para Cross-Desktop Group. E muitos aplicativos feitos para implementar estas especifica√ß√µes come√ßam com o prefixo xdg-. Experimente ir no seu terminal e digitar xdg- e pressionar TAB TAB, que voc√™ ver√° uma lista de aplicativos dispon√≠veis.\nSe tiver mais interesse nesse assunto, siga os links da se√ß√£o Fontes.\nB√¥nus Vou aproveitar o tema e mostrar uma breve fun√ß√£o onde usamos a vari√°vel builtin $OSTYPE, espec√≠fica do bash, para detectar o Sistema Operacional. Outra op√ß√£o √© utilizar uname, mas eu gosto de usar solu√ß√µes em bash puro. :)\nQuando voc√™ chama a fun√ß√£o openFile, ela vai detectar em qual Sistema Operacional voc√™ est√° e executa o comando correspondente.\n√â um exemplo bem simples. Se precisar de algo mais robusto √© preciso trabalhar um pouco mais nesse c√≥digo.\n# $OSTYPE √© uma vari√°vel embutida do bash pode # ser uma maneira interessante de detectar o SO openFile() { local args=\u0026#34;$@\u0026#34; case \u0026#34;$OSTYPE\u0026#34; in \u0026#34;cygwin\u0026#34;*) cygstart \u0026#34;$args\u0026#34; ;; \u0026#34;darwin\u0026#34;*) # MacOS open \u0026#34;$args\u0026#34; ;; *) xdg-open \u0026#34;$args\u0026#34; ;; esac } Algumas op√ß√µes v√°lidas para $OSTYPE que vi em uma postagem no GitHub:\n   Sistema Operacional $OSTYPE     Linux linux-gnu   Cygwin cygwin   bash no Windows 10 linux-gnu   OpenBSD openbsd*   FreeBSD FreeBSD   NetBSD netbsd   Mac OS darwin*   iOS darwin9   Solaris solaris*   Android (termux) linux-android*   Android linux-gnu   Haiku OS haiku    Fontes  https://wiki.archlinux.org/index.php/Xdg-utils man xdg-open https://www.freedesktop.org/wiki/Specifications/ man bash, descri√ß√£o de OSTYPE https://stackoverflow.com/questions/394230/how-to-detect-the-os-from-a-bash-script  ","permalink":"https://meleu.sh/abrir-qualquer-arquivo/","summary":"Um recurso que facilita muito a vida do usu√°rio quando usando um gerenciador de arquivos no ambiente gr√°fico √© o fato de poder dar um duplo clique no √≠cone e o sistema j√° saber qual programa utilizar para abr√≠-lo.\nConhecendo o xdg-open Quando estamos utilizando o terminal dentro de um ambiente gr√°fico podemos ter uma funcionalidade similar usando o comando xdg-open em sistemas Linux.\nEquivalentes ao comando xdg-open em outros ambientes:","title":"Como abrir qualquer arquivo no programa correto a partir da linha de comando"},{"content":"Quando estamos trabalhando com URLs e/ou APIs REST, precisamos com frequ√™ncia converter uma string para um formato v√°lido de URL, conhecido como URL encoded. Se estivermos trabalhando com o curl √© tranquilo, j√° temos a nossa disposi√ß√£o a op√ß√£o --data-urlencode. Mas quando n√£o vamos usar o curl, podemos implementar nossa pr√≥pria solu√ß√£o usando bash puro.\nurlencode() Eis o c√≥digo:\n#!/usr/bin/env bash # # urlencode - codificando sua string para usar em URLs urlencode() { local LC_ALL=C local string=\u0026#34;$*\u0026#34; local length=\u0026#34;${#string}\u0026#34; local char for (( i = 0; i \u0026lt; length; i++ )); do char=\u0026#34;${string:i:1}\u0026#34; if [[ \u0026#34;$char\u0026#34; == [a-zA-Z0-9.~_-] ]]; then printf \u0026#34;$char\u0026#34; else printf \u0026#39;%%%02X\u0026#39; \u0026#34;\u0026#39;$char\u0026#34; fi done printf \u0026#39;\\n\u0026#39; # opcional } urlencode \u0026#34;$@\u0026#34; Exemplo de uso Vejamos o c√≥digo em a√ß√£o:\n$ ./urlencode isso √© s√≥ a minha codifica√ß√£o isso%20%C3%A9%20s%C3%B3%20a%20minha%20codifica%C3%A7%C3%A3o $ ./urlencode https://meleu.sh/ https%3A%2F%2Fmeleu.sh%2F Explicando o c√≥digo Vamos a uma explica√ß√£o detalhada do que est√° acontecendo em cada trecho da fun√ß√£o:\n local LC_ALL=C A vari√°vel de ambiente LC_ALL serve para for√ßar um comportamento \u0026ldquo;port√°vel\u0026rdquo; para todas as configura√ß√µes de localiza√ß√£o existentes. Usamos o modificador local para que a altera√ß√£o do LC_ALL seja feita apenas no escopo da fun√ß√£o, n√£o alterando seu comportamento globalmente. Ou seja, ao final da fun√ß√£o, o LC_ALL de quem chamou a fun√ß√£o urlencode n√£o ter√° sido alterado.\nAgora deixa eu tentar explicar pra que serve o LC_ALL.\nSe voc√™ for no seu terminal e digitar o comando locale, voc√™ ver√° uma lista de vari√°veis come√ßando com LC_. Elas definem alguns comportamentos do sistema no que se refere as especificidades de cada localiza√ß√£o.\nEste recurso t√™m por objetivo tornar o sistema mais familiar e amig√°vel √† linguagem do usu√°rio. E quando usamos LC_ALL=C √© como se estiv√©ssemos dizendo para o shell que queremos usar configura√ß√µes de Unix \u0026ldquo;original\u0026rdquo;.\nPor exemplo, aqui no Brasil n√≥s temos letras acentuadas, nosso separador de decimal √© , v√≠rgula, nossa moeda √© representada por R$, etc. Todas essas configura√ß√µes s√£o definidas nas vari√°vels LC_*, e a vari√°vel LC_ALL serve para impor seu valor sobre todas as outras vari√°veis LC_* (ex.: se voc√™ tem LC_NUMERIC=\u0026quot;pt_BR.UTF-8\u0026quot; e LC_ALL=\u0026quot;C\u0026quot;, seu sistema vai se comportar como se LC_NUMERIC=\u0026quot;C\u0026quot;).\nUm dos motivos de definirmos LC_ALL=C aqui, √© para que as nossas letras acentuadas n√£o \u0026ldquo;casem\u0026rdquo; com o padr√£o [a-zA-Z]. O exemplo a seguir mostra isso bem claramente:\n$ LC_ALL=\u0026#39;pt_BR.UTF-8\u0026#39; $ [[ √© = [a-z] ]] \u0026amp;\u0026amp; echo sim || echo nao sim $ # com \u0026#39;pt_BR.UTF-8\u0026#39;, o caracter \u0026#39;√©\u0026#39; est√° dentro do intervalo [a-z] $ LC_ALL=\u0026#39;C\u0026#39; $ [[ √© = [a-z] ]] \u0026amp;\u0026amp; echo sim || echo nao nao $ # com \u0026#39;C\u0026#39;, o mesmo caractere nao esta no intervalo [a-z] $ # (e eu tambem nao consigo escrever letras acentuadas normalmente) Espero ter ficado claro. Agora vamos prosseguir com o c√≥digo:\n local string=\u0026#34;$*\u0026#34; local length=\u0026#34;${#string}\u0026#34; local char Primeiro pegamos todos os argumentos e colocamos na vari√°vel string. Em seguida armazenamos em length o n√∫mero de caracteres presentes em string.\nA vari√°vel char ser√° usada para analisarmos cada caracter de string no loop que vem a seguir\n for (( i = 0; i \u0026lt; length; i++ )); do char=\u0026#34;${string:i:1}\u0026#34; if [[ \u0026#34;$char\u0026#34; == [a-zA-Z0-9.~_-] ]]; then printf \u0026#34;$char\u0026#34; else printf \u0026#39;%%%02X\u0026#39; \u0026#34;\u0026#39;$char\u0026#34; fi done Um loop for estilo C foi utilizado para facilitar a manipula√ß√£o do √≠ndice i.\nO que acontece em char=\u0026quot;${string:i:1}\u0026quot; √© atribuir √† char apenas o caractere presente na posi√ß√£o i da string. Aquela sintaxe significa algo assim: ${string:posicaoInicial:numeroDeCaracteres}. Portanto, a cada itera√ß√£o do loop estamos testando apenas um caractere da string.\nNo if checamos se o caracter √© v√°lido para URLs. Lembra daquele LC_ALL=C que usamos l√° no come√ßo da fun√ß√£o? Ele serve para nos ajudar aqui.\nA lista de caracteres v√°lidos para URL s√£o d√≠gitos de 0 a 9, letras mai√∫sculas e min√∫sculas de A a Z, tra√ßo -, ponto ., sublinhado _ e til ~. Escrevendo esse padr√£o para bash temos [a-zA-Z0-9.~_-]\nSe o caracter for v√°lido, simplesmente imprime. Mas se for inv√°lido (o else), executaremos um printf um pouco obscuro, e que precisa de uma explica√ß√£o mais detalhada:\n printf \u0026#39;%%%02X\u0026#39; \u0026#34;\u0026#39;$char\u0026#34; A sequ√™ncia %%%02X significa:\n %%: um % sinal de percentual literal %02X: formato hexadecimal, usando letras mai√∫sculas para A-F, com dois d√≠gitos e precedido de 0 zero se necess√°rio.  O argumento \u0026quot;'$char\u0026quot; tem uma pequena sutileza: aquela ' aspa simples √∫nica no come√ßo (observe que n√£o tem o \u0026ldquo;fechamento\u0026rdquo; dela no final). Essa aspa simples significa que voc√™ quer passar o valor ASCII num√©rico do caractere que vem a seguir.\nVeja esse exemplo pra ficar mais claro:\n$ printf \u0026#34;%d\\n\u0026#34; \u0026#34;a\u0026#34; -bash: printf: a: n√∫mero inv√°lido 0 $ # lembrando: \u0026#39;a\u0026#39; em decimal na tabela ASCII, √© 97 $ printf \u0026#34;%d\\n\u0026#34; \u0026#34;\u0026#39;a\u0026#34; 97 Pois √© amigos\u0026hellip; Esse macetinho obscuro est√° \u0026ldquo;escondido\u0026rdquo; l√° manpage do bash, na parte que explica sobre o printf. Ali no pen√∫ltimo par√°grafo, como quem n√£o quer nada, tem uma frasezinha dizendo (tradu√ß√£o livre):\n (\u0026hellip;) se o primeiro caractere √© uma aspa simples ou dupla, o valor ser√° o valor ASCII do caractere a seguir.\n Agora, lembra daquele LC_ALL=C l√° do in√≠cio da fun√ß√£o? Tamb√©m precisamos dele aqui para que esse printf gere a sa√≠da que precisamos. Veja s√≥ a diferen√ßa:\n$ LC_ALL=\u0026#39;pt_BR.UTF-8\u0026#39; $ printf \u0026#39;%d\\n\u0026#39; \u0026#34;\u0026#39;√°\u0026#34; 225 $ LC_ALL=C $ printf \u0026#39;%d\\n\u0026#39; \u0026#34;\u0026#39;√°\u0026#34; 195 E assim acabamos o loop.\nPor fim temos um opcional\n printf \u0026#39;\\n\u0026#39; # opcional Apenas para colocar uma nova linha no final da string.\nurldecode() Para decodificar √© um pouco mais simples:\n#!/usr/bin/env bash # # urldecode - decodificando de urlencoded para texto leg√≠vel urldecode() { local encoded=\u0026#34;${*//+/ }\u0026#34; printf \u0026#39;%b\\n\u0026#39; \u0026#34;${encoded//%/\\\\x}\u0026#34; # o \u0026#39;\\n\u0026#39; acima √© opcional } urldecode \u0026#34;$@\u0026#34; Exemplo de uso $ ./urldecode \u0026#39;https%3A%2F%2Fmeleu.sh%2F\u0026#39; https://meleu.sh/ Explicando o c√≥digo A primeira linha coloca em encoded todos os argumentos passados para a fun√ß√£o, substituindo + por   espa√ßo em branco.\nNa linha do printf, especificamente no trecho ${encoded//%/\\\\x} pegamos o encoded e substitu√≠mos todos os sinais de % porcentagem por \\x.\nDemonstra√ß√£o:\n$ encoded=\u0026#39;%3A\u0026#39; $ echo \u0026#34;${encoded//%/\\\\x}\u0026#34; \\x3A Uma vez que substitu√≠mos todos os % por \\x, o printf %b finaliza o servi√ßo, pois o formato %b serve exatamente para lidar com essas sequencias de escape com contrabarra.\nDemonstra√ß√£o:\n$ printf \u0026#39;%b\\n\u0026#39; \u0026#39;\\x3A\u0026#39; : Portanto, o resultado do printf j√° ser√° o conte√∫do de encoded com os c√≥digos hexadecimais j√° devidamente \u0026ldquo;traduzidos\u0026rdquo; para o caractere leg√≠vel correspondente.\nUfa! Por hoje √© \u0026ldquo;s√≥\u0026rdquo;\u0026hellip;\nFontes  https://github.com/dylanaraps/pure-bash-bible#percent-encode-a-string https://wiki.archlinux.org/index.php/locale#Variables https://wiki-dev.bash-hackers.org/commands/builtin/printf https://www.tldp.org/LDP/abs/html/parameter-substitution.html#EXPREPL1 man bash, explica√ß√£o sobre printf  ","permalink":"https://meleu.sh/urlencode/","summary":"Quando estamos trabalhando com URLs e/ou APIs REST, precisamos com frequ√™ncia converter uma string para um formato v√°lido de URL, conhecido como URL encoded. Se estivermos trabalhando com o curl √© tranquilo, j√° temos a nossa disposi√ß√£o a op√ß√£o --data-urlencode. Mas quando n√£o vamos usar o curl, podemos implementar nossa pr√≥pria solu√ß√£o usando bash puro.\nurlencode() Eis o c√≥digo:\n#!/usr/bin/env bash # # urlencode - codificando sua string para usar em URLs urlencode() { local LC_ALL=C local string=\u0026#34;$*\u0026#34; local length=\u0026#34;${#string}\u0026#34; local char for (( i = 0; i \u0026lt; length; i++ )); do char=\u0026#34;${string:i:1}\u0026#34; if [[ \u0026#34;$char\u0026#34; == [a-zA-Z0-9.","title":"Como fazer URL encode/decode com shell script"},{"content":"Quando estamos trabalhando com arrays em shell scripts √© comum termos situa√ß√µes onde queremos saber se um determinado elemento est√° presente no array.\nO bash n√£o tem um recurso espec√≠fico para isso, portanto temos que arrumar um outro jeito. Neste artigo estudaremos tr√™s maneiras de alcan√ßar esse objetivo.\nM√©todo 1: infal√≠vel, por√©m \u0026ldquo;custoso\u0026rdquo; A maneira que logo vem a mente √© percorrer todo o array atrav√©s de um loop e checar se o elemento est√° presente l√°. No c√≥digo a seguir veremos a fun√ß√£o elementInArray1:\n# uso: elementInArray1 elemento item1 item2 itemN elementInArray1() { local element=\u0026#34;$1\u0026#34; local array=(\u0026#34;${@:2}\u0026#34;) for temp in \u0026#34;${array[@]}\u0026#34;; do [[ \u0026#34;$temp\u0026#34; == \u0026#34;$element\u0026#34; ]] \u0026amp;\u0026amp; return 0 done return 1 } Essa fun√ß√£o considera que $1 (o primeiro argumento) √© o elemento que voc√™ quer checar se est√° no array, e que todos argumentos que v√™m depois ${@:2} (do segundo argumento em diante) s√£o os elementos do array.\nAtrav√©s do loop for vamos testando os elementos um por um, comparando com o valor que queremos encontrar. Caso ele encontre, j√° vai retornar o sucesso (return 0) interrompendo a checagem.\nSe chegar at√© o final do loop significa que n√£o encontrou o valor que queremos, portanto retorna insucesso (return 1).\nVejamos essa fun√ß√£o em a√ß√£o:\n$ # macete do alias: https://meleu.sh/dica-result $ alias result=\u0026#39;echo verdadeiro || echo falso\u0026#39; $ $ # a fun√ß√£o est√° salva no arquivo elementInArray.sh $ . elementInArray.sh $ term=\u0026#39;melancia\u0026#39; $ fruits=(pera uva ma√ß√£ laranja kiwi) $ elementInArray1 \u0026#34;$term\u0026#34; \u0026#34;${fruits[@]}\u0026#34; \u0026amp;\u0026amp; result falso $ $ term=\u0026#39;uva\u0026#39; $ elementInArray1 \u0026#34;$term\u0026#34; \u0026#34;${fruits[@]}\u0026#34; \u0026amp;\u0026amp; result verdadeiro $ $ term=\u0026#39;lar\u0026#39; $ elementInArray1 \u0026#34;$term\u0026#34; \u0026#34;${fruits[@]}\u0026#34; \u0026amp;\u0026amp; result falso M√©todo 2: mais eficiente, por√©m com uma limita√ß√£o Legal, mas acho que conseguimos fazer um m√©todo um pouco mais eficiente. Onde podemos nos aproveitar do globbing do bash e fazer essa checagem com apenas um teste.\nVamos come√ßar a fun√ß√£o elementInArray2 assim:\n# OBS: c√≥digo incompleto elementInArray2() { local element=\u0026#34;$1\u0026#34; local array=(\u0026#34;${@:2}\u0026#34;) [[ \u0026#34;${array[@]}\u0026#34; == *\u0026#34;$element\u0026#34;* ]] } O teste que est√° ocorrendo ali, pega todos os elementos do array e o transforma em uma s√≥ string e compara com $element sendo que aqueles * asteriscos dizem que ele pode ter qualquer coisa antes e depois.\nVamos dar uma olhada se ele vai funcionar legal:\n$ # macete do alias: https://meleu.sh/dica-result $ alias result=\u0026#39;echo verdadeiro || echo falso\u0026#39; $ $ # a fun√ß√£o est√° salva no arquivo elementInArray.sh $ . elementInArray.sh $ term=\u0026#39;melancia\u0026#39; $ fruits=(pera uva ma√ß√£ laranja kiwi) $ elementInArray2 \u0026#34;$term\u0026#34; \u0026#34;${fruits[@]}\u0026#34; \u0026amp;\u0026amp; result falso $ $ term=\u0026#39;uva\u0026#39; $ elementInArray2 \u0026#34;$term\u0026#34; \u0026#34;${fruits[@]}\u0026#34; \u0026amp;\u0026amp; result verdadeiro $ $ term=\u0026#39;lar\u0026#39; $ elementInArray2 \u0026#34;$term\u0026#34; \u0026#34;${fruits[@]}\u0026#34; \u0026amp;\u0026amp; result verdadeiro $ # OPA! ERRO! \u0026#39;lar\u0026#39; n√£o est√° presente no array! A princ√≠pio a fun√ß√£o funcionou de acordo com o esperado, no entanto no √∫ltimo exemplo gerou um falso positivo.\nA fun√ß√£o encontrou lar mesmo que o array n√£o tenha elemento algum com este valor. Como voc√™ j√° deve ter percebido, isso ocorreu por conta do valor laranja.\nVejamos uma maneira de contornar isso:\nelementInArray2() { local element=\u0026#34;$1\u0026#34; local array=(\u0026#34;${@:2}\u0026#34;) [[ \u0026#34;${array[@]}\u0026#34; == *\u0026#34; $element \u0026#34;* ]] } A √∫nica diferen√ßa aqui √© que o foi adicionado um espa√ßo antes e depois de $element. Vamos aos testes:\n$ # macete do alias: https://meleu.sh/dica-result $ alias result=\u0026#39;echo verdadeiro || echo falso\u0026#39; $ $ # a fun√ß√£o est√° salva no arquivo elementInArray.sh $ . elementInArray.sh $ term=\u0026#39;melancia\u0026#39; $ fruits=(pera uva ma√ß√£ laranja kiwi) $ elementInArray2 \u0026#34;$term\u0026#34; \u0026#34;${fruits[@]}\u0026#34; \u0026amp;\u0026amp; result falso $ $ term=\u0026#39;uva\u0026#39; $ elementInArray2 \u0026#34;$term\u0026#34; \u0026#34;${fruits[@]}\u0026#34; \u0026amp;\u0026amp; result verdadeiro $ $ term=\u0026#39;lar\u0026#39; $ elementInArray2 \u0026#34;$term\u0026#34; \u0026#34;${fruits[@]}\u0026#34; \u0026amp;\u0026amp; result falso $ $ fruits=(pera \u0026#39;uva passa\u0026#39; ma√ß√£ laranja kiwi) $ # removi \u0026#39;uva\u0026#39; substituindo por \u0026#39;uva passa\u0026#39; $ term=\u0026#39;uva\u0026#39; # vamos ver se \u0026#39;uva\u0026#39; ainda est√° no array $ elementInArray2 \u0026#34;$term\u0026#34; \u0026#34;${fruits[@]}\u0026#34; \u0026amp;\u0026amp; result verdadeiro $ # ERRO! Isso n√£o deveria ter ocorrido! :( A fun√ß√£o atendeu legal, por√©m mais uma vez gerando um falso positivo. Ela acusa que uva est√° presente no array mesmo quando n√£o h√° elemento algum contendo apenas uva. Obviamente isso ocorreu devido ao elemento uva passa.\nPoder√≠amos ir adicionando mais gambiarras para contornar este problema, mais sinceramente, eu n√£o gosto muito de gambiarras. Principalmente se for tornar o c√≥digo de dif√≠cil leitura.\nVou me dar por satisfeito com esta fun√ß√£o assim mesmo e tomar o cuidado de us√°-la somente com arrays cujos elementos n√£o contenham espa√ßos.\nO m√°ximo que eu faria √© remover a atribui√ß√£o das vari√°veis locais para deixar a fun√ß√£o com apenas uma linha (prejudica um pouco a legibilidade, mas\u0026hellip; p√¥! √© s√≥ uma √∫nica linha!).\nelementInArray2() { [[ \u0026#34;${@:2}\u0026#34; == *\u0026#34; $1 \u0026#34;* ]] } M√©todo 3: a solu√ß√£o \u0026ldquo;perfeita\u0026rdquo;, mas depende do extglob ativado Este m√©todo eu vi num grupo de telegram sobre shell script (postagem do SHAMAN e depois com um toque de requinte do Robson Alexandre) e achei muito eficiente. At√© agora n√£o consegui ver um cen√°rio onde esse m√©todo falha, mas como n√£o fiz testes ostensivos, digo que √© a solu√ß√£o \u0026ldquo;perfeita\u0026rdquo; entre aspas\nNeste m√©todo usaremos um recurso n√£o muito convencional do bash: extglob. Segundo o Greg\u0026rsquo;s Wiki (uma das minhas fontes de conhecimento sobre bash favoritas) esse recurso foi adicionado no bash 2.02, em 1998 (mais de 20 anos). Portanto, usar essa solu√ß√£o parece ser port√°vel o suficiente.\nPara utilizar extglob ele precisa estar habilitado. Se ele n√£o estiver habilitado por padr√£o, basta fazer um shopt -s extglob.\nUma vez habilitado, podemos (dentre outras coisas) buscar uma string dentro de uma lista onde cada elemento √© separado por um | pipe. Exemplo:\n[[ $element == @(element1|element2|elementN) ]] Um r√°pido exemplo pr√°tico:\n$ # macete do alias: https://meleu.sh/dica-result $ alias result=\u0026#39;echo verdadeiro || echo falso\u0026#39; $ $ [[ um == @(um|dois|tres) ]] \u0026amp;\u0026amp; result verdadeiro $ [[ quatro == @(um|dois|tres) ]] \u0026amp;\u0026amp; result falso Portanto, para aplicar essa t√©cnica no nosso prop√≥sito de checar se um elemento est√° presente no array, primeiro teremos que pegar os elementos do array e separ√°-los com um | pipe.\nPara isso vamos usar o joinBy() que mostrei e expliquei como funciona num outro post (e que repito a seguir).\nO c√≥digo fica assim:\njoinBy() { local IFS=\u0026#34;$1\u0026#34; echo \u0026#34;${*:2}\u0026#34; } # se extglob n√£o estiver habilitado, basta executar: # shopt -s extglob elementInArray3() { local element=\u0026#34;$1\u0026#34; local array=(\u0026#34;${@:2}\u0026#34;) [[ \u0026#34;$element\u0026#34; == @($(joinBy \u0026#39;|\u0026#39; \u0026#34;${array[@]//|/\\\\|}\u0026#34;)) ]] } Um trechinho que pode parecer confuso √© o ${array[@]//|/\\\\|}, mas eu explico.\nEstamos usando este esquema: ${variavel//padrao/substituto}.\nS√≥ que no nosso caso o padr√£o √© | e o substituto √© \\\\|. Portanto uma string como essa|aqui vai virar essa\\|aqui.\nFazemos isso para \u0026ldquo;escapar\u0026rdquo; o | pipe e fazer com o que ele n√£o seja considerado como um separador quando estivermos usando o esquema de @(...|...|...)\nAgora vejamos esse m√©todo em a√ß√£o:\n$ # macete do alias: https://meleu.sh/dica-result $ alias result=\u0026#39;echo verdadeiro || echo falso\u0026#39; $ $ # a fun√ß√£o est√° salva no arquivo elementInArray.sh $ . elementInArray.sh $ term=\u0026#39;melancia\u0026#39; $ fruits=(pera uva ma√ß√£ laranja kiwi) $ elementInArray3 \u0026#34;$term\u0026#34; \u0026#34;${fruits[@]}\u0026#34; \u0026amp;\u0026amp; result falso $ $ term=\u0026#39;uva\u0026#39; $ elementInArray3 \u0026#34;$term\u0026#34; \u0026#34;${fruits[@]}\u0026#34; \u0026amp;\u0026amp; result verdadeiro $ $ term=\u0026#39;lar\u0026#39; $ elementInArray3 \u0026#34;$term\u0026#34; \u0026#34;${fruits[@]}\u0026#34; \u0026amp;\u0026amp; result falso $ $ fruits=(pera \u0026#39;uva passa\u0026#39; ma√ß√£ laranja kiwi) $ # removi \u0026#39;uva\u0026#39; substituindo por \u0026#39;uva passa\u0026#39; $ term=\u0026#39;uva\u0026#39; # vamos ver se \u0026#39;uva\u0026#39; ainda est√° no array $ elementInArray3 \u0026#34;$term\u0026#34; \u0026#34;${fruits[@]}\u0026#34; \u0026amp;\u0026amp; result falso $ $ $ # agora testando com \u0026#39;|\u0026#39; pipes dentro do array $ array=(um dois \u0026#39;tres|quatro\u0026#39; \u0026#39;cinco seis\u0026#39;) $ elementInArray3 dois \u0026#34;${array[@]}\u0026#34; \u0026amp;\u0026amp; result verdadeiro $ $ elementInArray3 \u0026#39;tres\u0026#39; \u0026#34;${array[@]}\u0026#34; \u0026amp;\u0026amp; result falso $ $ elementInArray3 \u0026#39;tres|quatro\u0026#39; \u0026#34;${array[@]}\u0026#34; \u0026amp;\u0026amp; result verdadeiro $ $ elementInArray3 \u0026#39;cinco\u0026#39; \u0026#34;${array[@]}\u0026#34; \u0026amp;\u0026amp; result falso $ $ elementInArray3 \u0026#39;cinco seis\u0026#39; \u0026#34;${array[@]}\u0026#34; \u0026amp;\u0026amp; result verdadeiro Como podemos ver, √© um m√©todo bastante robusto.\nMais uma vez agrade√ßo aos companheiros SHAMAN e Robson Alexandre pelo conhecimento compartilhado.\nResumo  Se quer um m√©todo infal√≠vel, use a vers√£o com loop. Se tem certeza que seu array n√£o possui elementos contendo espa√ßo, use a vers√£o mais eficiente. Se n√£o v√™ problemas em habilitar extglob, use esta vers√£o! Agora a melhor recomenda√ß√£o: use o que foi mostrado aqui como inspira√ß√£o e crie sua pr√≥pria solu√ß√£o!  Fontes  https://github.com/dylanaraps/pure-bash-bible https://mywiki.wooledge.org/glob https://mywiki.wooledge.org/BashFAQ/061 https://www.tldp.org/LDP/abs/html/parameter-substitution.html#PSGLOB https://www.gnu.org/software/bash/manual/html_node/Pattern-Matching.html https://stackoverflow.com/a/15394738/6354514 https://stackoverflow.com/a/9429887/6354514 grupo de shell script do telegram man bash na se√ß√£o de \u0026ldquo;Pattern Matching\u0026rdquo;  ","permalink":"https://meleu.sh/elemento-presente-no-array/","summary":"Quando estamos trabalhando com arrays em shell scripts √© comum termos situa√ß√µes onde queremos saber se um determinado elemento est√° presente no array.\nO bash n√£o tem um recurso espec√≠fico para isso, portanto temos que arrumar um outro jeito. Neste artigo estudaremos tr√™s maneiras de alcan√ßar esse objetivo.\nM√©todo 1: infal√≠vel, por√©m \u0026ldquo;custoso\u0026rdquo; A maneira que logo vem a mente √© percorrer todo o array atrav√©s de um loop e checar se o elemento est√° presente l√°.","title":"Como checar se um array cont√©m um determinado elemento"},{"content":"Eu estava precisando juntar os elementos do array em uma s√≥ string usando um | como separador.\nEm linguagens como JavaScript e PHP isso √© obtido atrav√©s de fun√ß√µes/m√©todos nativos, tipo join() ou implode(). Em bash teremos que implementar n√≥s mesmos.\nC√≥digo Uma r√°pida googlada me levou a uma solu√ß√£o bem simples e bacana. Mostro aqui a minha vers√£o:\njoinBy() { local IFS=\u0026#34;$1\u0026#34; echo \u0026#34;${*:2}\u0026#34; } Agora vamos ver esse c√≥digo em a√ß√£o:\n$ . joinBy.sh $ joinBy , zacarias mussum \u0026#39;didi moc√≥\u0026#39; \u0026#39;ded√© santana\u0026#39; zacarias,mussum,didi moc√≥,ded√© santana $ joinBy | zacarias mussum \u0026#39;didi moc√≥\u0026#39; \u0026#39;ded√© santana\u0026#39; zacarias: command not found $ # Ooops! Precisamos proteger o pipe com \u0026#39;aspas\u0026#39; $ joinBy \u0026#39;|\u0026#39; zacarias mussum \u0026#39;didi moc√≥\u0026#39; \u0026#39;ded√© santana\u0026#39; zacarias|mussum|didi moc√≥|ded√© santana Explicando Checando a manpage do bash, na se√ß√£o de \u0026ldquo;Special Parameters\u0026rdquo;, conseguimos ver a resposta para isso. L√° vemos a explica√ß√£o do * asterisco e do @ arroba no contexto de par√¢metros da linha de comando ($1, $2, etc.), mas a mesma l√≥gica se aplica a expans√£o de arrays.\nEste √© um trecho da descri√ß√£o da expans√£o feita com * asterisco (tradu√ß√£o livre feita por mim):\n Quando a expans√£o ocorre entre aspas duplas, expande para uma √∫nica palavra com o valor de cada par√¢metro separado pelo primeiro caractere da vari√°vel especial IFS. Isto √©, \u0026quot;$*\u0026quot; √© equivalente a \u0026quot;$1c$2c...\u0026quot;, onde c √© o primeiro caractere da vari√°vel IFS.\n E a seguir um trecho da descri√ß√£o da expans√£o feita com @ arroba:\n Quando a expans√£o ocorre entre aspas duplas, cada par√¢metro expande para uma palavra separada [por um espa√ßo]. Isto √© \u0026quot;$@\u0026quot; √© equivalente a \u0026quot;$1\u0026quot; \u0026quot;$2\u0026quot; ...\n Resumo:\n @ arroba: expande separando com um espa√ßo. * asterisco: expande separando com o primeiro caractere do IFS.  Devido a esta propriedade, se tentarmos a fun√ß√£o joinBy() usando @ arroba no lugar de * asterisco (echo \u0026quot;${@:2}\u0026quot;), n√£o obteremos o resultado desejado.\n Atualiza√ß√£o\nO Blau Araujo fez um v√≠deo explicando no detalhe essas diferen√ßas entre o * e o @. Confira aqui: Bash: expans√µes dos par√¢metros @ e * - quais s√£o as diferen√ßas?\n Fontes  https://stackoverflow.com/a/9429887/6354514 man bash na se√ß√£o de \u0026ldquo;Special Parameters\u0026rdquo;  ","permalink":"https://meleu.sh/join-bash/","summary":"Eu estava precisando juntar os elementos do array em uma s√≥ string usando um | como separador.\nEm linguagens como JavaScript e PHP isso √© obtido atrav√©s de fun√ß√µes/m√©todos nativos, tipo join() ou implode(). Em bash teremos que implementar n√≥s mesmos.\nC√≥digo Uma r√°pida googlada me levou a uma solu√ß√£o bem simples e bacana. Mostro aqui a minha vers√£o:\njoinBy() { local IFS=\u0026#34;$1\u0026#34; echo \u0026#34;${*:2}\u0026#34; } Agora vamos ver esse c√≥digo em a√ß√£o:","title":"Como juntar elementos de um array separando-os com um caracter qualquer"},{"content":"Recentemente conheci um site muito maneiro para os amantes da linha de comando: https://cheat.sh\nE o que mais gostei dele √© que conseguimos ter uma intera√ß√£o prazeirosa simplesmente acessando via curl.\nAbra o seu terminal e experimente voc√™ mesmo com o seguinte comando:\ncurl cheat.sh Trata-se de um site com um reposit√≥rio com diversos macetes de comandos, linguagens de programa√ß√£o, algoritmos, etc.\nPor exemplo, imaginemos que queremos ver alguns macetes do comando sudo. Basta executarmos um curl cheat.sh/sudo. Veja s√≥:\n$ curl cheat.sh/sudo # sudo # Execute a command as another user. # List of an unreadable directory: sudo ls /usr/local/scrt # To edit a file as user www: sudo -u www vi /var/www/index.html # To shutdown the machine: sudo shutdown -h +10 \u0026#34;Cya soon!\u0026#34; # To repeat the last command as sudo: sudo !! # Save a file you edited in vim :w !sudo tee \u0026gt; /dev/null % # Make sudo forget password instantly sudo -K # List your sudo rights sudo -l # Add a line to a file using sudo echo \u0026#34;foo bar\u0026#34; | sudo tee -a /path/to/some/file # run root shell sudo -i # to disable password for sudo for user superuser add # superuser ALL=(ALL) NOPASSWD:ALL # in /etc/sudoers Se preferir, tamb√©m √© poss√≠vel ter a mesma informa√ß√£o acessando via browser. Veja voc√™ mesmo: https://cheat.sh/sudo\nVoc√™ pode tamb√©m instalar um script espec√≠fico para acessar o site. Veja as instru√ß√µes de instala√ß√£o diretamente no README do reposit√≥rio github dele.\nUma vez instalado o script (chamado de cht.sh), vc pode fazer consultas mais \u0026ldquo;inteligentes\u0026rdquo;.\nImaginemos que voc√™ quer lembrar como fazer um parse de JSON em JavaScript. Basta executar o comando a seguir que voc√™ ver√° algumas dicas:\ncht.sh js parse json Certamente uma ferramenta que qualquer CLI lover vai gostar de, no m√≠nimo, experimentar!\nFontes  https://cheat.sh/ https://github.com/chubin/cheat.sh  ","permalink":"https://meleu.sh/cheat-sh/","summary":"Recentemente conheci um site muito maneiro para os amantes da linha de comando: https://cheat.sh\nE o que mais gostei dele √© que conseguimos ter uma intera√ß√£o prazeirosa simplesmente acessando via curl.\nAbra o seu terminal e experimente voc√™ mesmo com o seguinte comando:\ncurl cheat.sh Trata-se de um site com um reposit√≥rio com diversos macetes de comandos, linguagens de programa√ß√£o, algoritmos, etc.\nPor exemplo, imaginemos que queremos ver alguns macetes do comando sudo.","title":"cheat.sh: obtendo exemplos e macetes dos mais diversos comandos"},{"content":"Para tornar o primeiro post deste blog bem simb√≥lico, vamos falar sobre a primeira coisa que devemos colocar em um shell script: o #! (vulgarmente chamado de shebang ou hashbang).\nComo o #! funciona? O #! shebang serve para dizer ao kernel qual ser√° o interpretador a ser utilizado para executar os comandos presentes no arquivo.\nQuando executamos um arquivo que come√ßa com #!, o kernel abre o arquivo e pega tudo que est√° escrito ap√≥s o shebang at√© o final da linha. Em seguida ele tenta executar um comando com o conte√∫do desta string adicionando como par√¢metro o nome do pr√≥prio arquivo.\nPortanto se voc√™ tem arquivo execut√°vel chamado meuscript.sh, contendo um shell-script e come√ßando com #!/bin/bash, quando voc√™ executa esse arquivo o kernel vai executar /bin/bash meuscript.sh.\nNos exemplos a seguir voc√™ ver√° isso muito claramente.\nVamos come√ßar com o cl√°ssico hello.sh:\n#!/bin/bash echo \u0026#34;Hello World!\u0026#34; Quando √© digitado no shell:\n$ ./hello.sh O kernel vai ver o #! e vai ler o que vem a seguir at√© o final da linha, neste caso /bin/bash. E ent√£o o que √© executado √© equivalente a voc√™ fazer isso no shell:\n$ /bin/bash hello.sh Demonstra√ß√µes com o cat Vejamos agora um exemplo usando #!/bin/cat. O nome do arquivo √© hashbangcat\n#!/bin/cat Todo o conte√∫do deste arquivo ser√° exibido quando ele for executado (inclusive o \u0026#39;#!/bin/cat\u0026#39;). O que √© lido ap√≥s o hashbang: /bin/cat Nome do arquivo: hashbangcat\nPortanto ser√° executado: /bin/cat hashbangcat\nVeja:\n$ ./hashbangcat #!/bin/cat Todo o conte√∫do deste arquivo ser√° exibido quando ele for executado (inclusive o \u0026#39;#!/bin/cat\u0026#39;). com o echo Agora um exemplo que deixa bastante claro que as coisas acontecem exatamente como estou dizendo. Vamos usar #!/usr/bin/echo. O seguinte arquivo se chama hashbangecho:\n#!/usr/bin/echo O conte√∫do deste arquivo *n√£o* ser√° exibido quando ele for executado. Agora vamos executar esse arquivo:\n$ ./hashbangecho ./hashbangecho A sa√≠da do comando foi o nome do arquivo pois o que realmente foi executado foi /usr/bin/echo ./hashbangecho.\nSe passarmos par√¢metros, eles tamb√©m ser√£o repassados. Conforme veremos no exemplo a seguir.\ncom o ls Este arquivo se chama hashbangls.sh:\n#!/bin/ls O conte√∫do aqui n√£o importa. Agora ele sendo executado:\n$ ./hashbangls.sh ./hashbangls.sh $ ./hashbangls.sh notfound /bin/ls: cannot access \u0026#39;notfound\u0026#39;: No such file or directory ./hashbangls.sh $ ./hashbangls.sh -l -rwxr-xr-x 1 meleu meleu 41 Dec 20 14:42 ./hashbangls.sh D√∫vidas Comuns Por que algumas pessoas usam #!/usr/bin/env bash? Provavelmente voc√™ j√° viu alguns scripts come√ßando com #!/usr/bin/env bash onde normalmente voc√™ costuma ver #!/bin/bash. O motivo disso √© que acredita-se que isso aumenta a portabilidade do seu script (mesmo que isso possa ser question√°vel).\nO comando env, se usado sem argumento algum, imprime uma (grande) lista com todas as vari√°veis de ambiente (environment variables). Mas se o env √© usado seguido de um comando, ele executa aquele comando em uma outra inst√¢ncia do shell.\nü§î - OK, mas como que isso influencia na portabilidade?!\nQuando voc√™ usa #!/bin/bash voc√™ est√° explicitamente dizendo que o execut√°vel bash est√° no diret√≥rio /bin/. Isso parece ser o padr√£o em todas as distribui√ß√µes Linux, mas existem outros \u0026ldquo;sabores\u0026rdquo; de Unix onde isso pode n√£o acontecer. Podem ocorrer casos, por exemplo, onde o bash pode estar presente em /usr/bin/. E nesse caso, se voc√™ tentar executar um script que tenha #!/bin/bash, o kernel n√£o encontraria o arquivo /bin/bash e voc√™ iria receber um erro do tipo: bad interpreter: No such file or directory.\nPor outro lado, se voc√™ executa run bash, o comando env vai procurar pelo bash em seu $PATH, e ent√£o vai executar o primeiro bash que encontrar nos diret√≥rios listados no $PATH. Normalmente o bash est√° em /bin/, mas tamb√©m pode haver um caso em que seu script est√° sendo executado em um sistema que tem o bash em outro diret√≥rio (como /usr/bin/ ou /home/user/bin/).\nPortanto, para que o seu script possa ser usado nos mais diversos ambientes, algumas pessoas recomendam usar a t√©cnica do #!/usr/bin/env bash.\nü§î - Mas espera a√≠! O que garante que o env sempre estar√° em /usr/bin/?\nA resposta √© simples: N√£o h√° garantia alguma! üòá\nA recomenda√ß√£o √© baseada no que √© comumente visto nos sistemas Unix. Mas ter o bash em /bin/ tamb√©m √© bastante comum.\nO importante de voc√™ entender aqui √©: as duas op√ß√µes funcionam na maioria dos casos por√©m nenhuma das duas √© uma bala de prata que vai resolver tudo.\nSe voc√™ quer minha opini√£o, a√≠ vai: as duas solu√ß√µes s√£o igualmente boas, escolha qualquer uma e seja feliz.\n Se √© um projetinho pessoal seu: use o jeito que mais te agrada. Se √© um projeto que j√° est√° em andamento: siga o que j√° √© praticado pelo projeto (sem nenhuma neura de n√£o ser o seu m√©todo favorito - lembre-se: as duas solu√ß√µes s√£o boas o suficiente).  ü§® - T√° bom meleu, mas qual das duas solu√ß√µes voc√™ usa?\nEu costumo usar o #!/usr/bin/env bash.\nPrincipal motivo: quando eu estava contribuindo com o projeto RetroPie, esse era o m√©todo utilizado l√°.\nPode ser que eu use #!/bin/bash aqui e acol√°\u0026hellip; J√° cheguei a conclus√£o que as duas solu√ß√µes s√£o igualmente boas. Mas eu tendo a preferir utilizar o m√©todo com o env.\nExiste ainda alguns casos especiais, que n√£o est√£o relacionados especificamente ao bash, onde o uso do #!/usr/bin/env √© uma op√ß√£o melhor: quando voc√™ quer executar um script Python ou usando NodeJS.\nVamos ver um exemplo bobo em NodeJS. Se eu quero executar um script simplesmente chamando o nome do arquivo, eu poderia criar um arquivo assim:\n#!/usr/bin/node console.log(\u0026#39;Hello World from NodeJS\u0026#39;); O problema aqui √© que eu estou partindo do princ√≠pio que o node est√° em /usr/bin/. Mas acontece que eu geralmente instalo o Node usando o Node Version Manager (ao inv√©s de usar o node disponibilizado pelos apt-get da vida). Portanto meu node fica nesse diret√≥rio aqui:\n$ which node /home/meleu/.nvm/versions/node/v14.15.1/bin/node Eu jamais iria iniciar o meu script com um shebang tipo #!/home/meleu/.nvm/versions/node/v14.15.1/bin/node!\nPortanto uma solu√ß√£o bem interessante √© usar #!/usr/bin/env node.\nE se eu n√£o usar #! algum? Recomendo fortemente que voc√™ nunca escreva/execute um script sem um shebang #!.\nComo eu disse, o shebang diz ao seu kernel qual interpretador √© para ser usado para executar os comandos presentes no arquivo. Se voc√™ executa um script sem especificar o interpretador, o shell vai disparar uma outra inst√¢ncia de si mesmo e tentar executar o script nessa nova inst√¢ncia. Isso significa que ele executar√° seja l√° o que for que estiver escrito no arquivo, mesmo se for um script feito para ksh, zsh, dash, fish, node, python ou qualquer outra linguagem\u0026hellip;\nPortanto sempre use um shebang nos seus scripts!.\nFontes  http://mywiki.wooledge.org/BashProgramming#Shebang https://wiki.bash-hackers.org/scripting/basics#the_shebang man env Aqui est√° um email de Dennis Ritchie de 1980, falando sobre esses \u0026ldquo;caracters m√°gicos\u0026rdquo;. Node.js shebang  ","permalink":"https://meleu.sh/shebang/","summary":"Para tornar o primeiro post deste blog bem simb√≥lico, vamos falar sobre a primeira coisa que devemos colocar em um shell script: o #! (vulgarmente chamado de shebang ou hashbang).\nComo o #! funciona? O #! shebang serve para dizer ao kernel qual ser√° o interpretador a ser utilizado para executar os comandos presentes no arquivo.\nQuando executamos um arquivo que come√ßa com #!, o kernel abre o arquivo e pega tudo que est√° escrito ap√≥s o shebang at√© o final da linha.","title":"O que o #! realmente faz?"},{"content":"Voc√™ adivinhou! O .sh no dom√≠nio desse site √© uma homenagem √† extens√£o normalmente usada para arquivos contendo shell script.\nQue assunto √© abordado aqui? Este site √© totalmente dedicado √† linha de comando e shell scripting (principalmente bash).\nPortanto mostro aqui diversos comandos e programas √∫teis que podem ser utilizados diretamente no console.\nTamb√©m mostro como combin√°-los, atrav√©s de shell scripts, para fazer tarefas maiores.\nUma das minhas premissas √© gerar conte√∫do que:\n seja √∫til para qualquer usu√°rio que gosta da linha de comando em ambientes Unix-like. permane√ßa relevante por v√°rios anos. ajude a difundir boas pr√°ticas de programa√ß√£o.  Que assunto N√ÉO √© abordado aqui? N√ÉO abordo peculiaridades/vantagens/desvantagens das infinitas distribui√ß√µes Linux, e nem configura√ß√µes/customiza√ß√µes de ambientes gr√°ficos.\nAli√°s, o conte√∫do aqui n√£o √© limitado somente ao Linux. O bash tamb√©m est√° dispon√≠vel para qualquer sistema Unix-like, o que inclui os *BSDs, e MacOS, est√° dispon√≠vel at√© mesmo para Windows, smartphones e mais uma infinidade de dispositivos.\nPortanto o foco aqui √© em uma coisa que √© comum √† todos estes sistemas: a linha de comando.\nPor que criei esse site? Meu objetivo √© conseguir difundir no mercado brasileiro a ado√ß√£o de boas pr√°ticas referentes a shell-script (principalmente bash). Deixar o c√≥digo mais leg√≠vel e de mais f√°cil manuten√ß√£o.\nSabemos bem que o shell-script √© muito permissivo e tolerante a \u0026ldquo;gambiarras\u0026rdquo;, (aqueles artif√≠cios que usamos pra resolver um problema r√°pido). Isso acaba gerando um c√≥digo confuso, onde uma simples corre√ß√£o pode tomar muito tempo do programador, at√© que ele ao menos descubra aonde ele precisa alterar o c√≥digo\u0026hellip;\nVoc√™ perceber√° que meus artigos s√£o muito focados em um c√≥digo limpo, f√°cil de ler, de entender e de dar manuten√ß√£o. Espero conseguir inspirar os leitores a ao menos se preocuparem com isso.\nLembre-se: Voc√™ l√™ c√≥digo muito mais do que escreve. Portanto fa√ßa o poss√≠vel para que essa leitura seja agrad√°vel e f√°cil de entender.\nSem distra√ß√µes! Fa√ßo quest√£o de prover esse conte√∫do num formato limpo, agrad√°vel de se ler, sem propagandas ou qualquer outro tipo de distra√ß√£o pra ficar atrapalhando sua leitura.\nApesar da propaganda ser um recurso que pode gerar alguns trocados e estimular a produ√ß√£o de conte√∫do (al√©m de me ajudar com os custos do dom√≠nio), o efeito colateral de ser uma grande distra√ß√£o para o leitor n√£o faz valer a pena.\nNo passado eu estava aceitando doa√ß√µes. Mas como atualmente os custos pra manter esse site n√£o causam um grande impacto no meu or√ßamento, resolvi deixar de lado.\nQuem mant√©m esse site? Me chamo meleu (mesmo que no meu RG esteja escrito Augusto).\nSou um amante do Linux, da linha de comando, de shell scripting e do movimento Open Source desde quando comprei meu primeiro computador em 1999. Atualmente trabalho como Engenheiro DevOps e uso scripts bash intensivamente no meu dia a dia de trabalho.\nSe quiser me contactar para assuntos profissionais, conecte-se comigo no meu perfil do LinkedIn.\n","permalink":"https://meleu.sh/sobre/","summary":"Voc√™ adivinhou! O .sh no dom√≠nio desse site √© uma homenagem √† extens√£o normalmente usada para arquivos contendo shell script.\nQue assunto √© abordado aqui? Este site √© totalmente dedicado √† linha de comando e shell scripting (principalmente bash).\nPortanto mostro aqui diversos comandos e programas √∫teis que podem ser utilizados diretamente no console.\nTamb√©m mostro como combin√°-los, atrav√©s de shell scripts, para fazer tarefas maiores.\nUma das minhas premissas √© gerar conte√∫do que:","title":"Sobre o meleu.sh"}]