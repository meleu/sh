<!DOCTYPE html>
<html lang="pt" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Como ler o conteúdo de um arquivo linha por linha em shell script | meleu.sh</title>
<meta name="keywords" content="boas-praticas, codigo">
<meta name="description" content="Veja uma maneira robusta de percorrer um arquivo linha por linha. E sem cair nas armadilhas sutis que nos trazem surpresas desagradáveis.
">
<meta name="author" content="meleu">
<link rel="canonical" href="https://meleu.sh/percorrer-arquivo/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css" integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://meleu.sh/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://meleu.sh/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://meleu.sh/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://meleu.sh/apple-touch-icon.png">
<link rel="mask-icon" href="https://meleu.sh/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript><meta property="og:title" content="Como ler o conteúdo de um arquivo linha por linha em shell script" />
<meta property="og:description" content="Veja uma maneira robusta de percorrer um arquivo linha por linha. E sem cair nas armadilhas sutis que nos trazem surpresas desagradáveis.
" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://meleu.sh/percorrer-arquivo/" />
<meta property="og:image" content="https://meleu.sh/img/percorrer-arquivo.png" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-01-21T16:00:42-03:00" />
<meta property="article:modified_time" content="2020-01-21T16:00:42-03:00" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://meleu.sh/img/percorrer-arquivo.png" />
<meta name="twitter:title" content="Como ler o conteúdo de um arquivo linha por linha em shell script"/>
<meta name="twitter:description" content="Veja uma maneira robusta de percorrer um arquivo linha por linha. E sem cair nas armadilhas sutis que nos trazem surpresas desagradáveis.
"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://meleu.sh/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Como ler o conteúdo de um arquivo linha por linha em shell script",
      "item": "https://meleu.sh/percorrer-arquivo/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Como ler o conteúdo de um arquivo linha por linha em shell script",
  "name": "Como ler o conteúdo de um arquivo linha por linha em shell script",
  "description": "Veja uma maneira robusta de percorrer um arquivo linha por linha. E sem cair nas armadilhas sutis que nos trazem surpresas desagradáveis.\n",
  "keywords": [
    "boas-praticas", "codigo"
  ],
  "articleBody": "Uma das coisas que você certamente vai encarar um dia como um programador de shell scripts é a necessidade de percorrer um arquivo inteiro lendo cada linha e fazer algo com este conteúdo. Veremos neste artigo como fazer isso de maneira segura, robusta e evitando as possíveis armadilhas que podem aparecer no caminho.\nPra adiantar seu lado, vou logo de cara lhe dar a solução que eu considero mais robusta. Em seguida explica cada detalhe dessa estrutura.\nwhile IFS= read -r linha || [[ -n \"$linha\" ]]; do echo \"$linha\" # faça algo mais interessante aqui... done Dei esse grande spoiler pois percebi que esse artigo ficou relativamente grande, e uma das coisas que mais valorizo aqui é o seu tempo.\nSe você só quer a solução, ali está ela. Mas se quiser entender cada detalhezinho dessa estrutura, continue lendo.\nA minha explicação vai partir da solução naïve (ou seja, a solução mais básica e ingênua) de como percorrer cada linha de um arquivo. E a partir de cada problema que encontrarmos vamos adicionar uma maneira de contornar. No final de tudo teremos aquela estrutura que mostrei acima.\nSolução 1: read linha Para fins didáticos, imaginemos que queremos um script que simplesmente imprima na tela cada linha de um arquivo de maneira similar ao uso mais básico do comando cat.\nVamos chamar esse script de mycat.sh, e usaremos redirecionamento para um loop while para alcançar o nosso objetivo.\nA primeira vez que eu ouvi falar de redirecionamento de conteúdo de um arquivo para um loop (há duas décadas atrás), a primeira coisa que tentei foi o seguinte:\n#!/usr/bin/env bash # mycat.sh # # versão 1: solução naïve arquivo=\"$1\" while read linha; do echo \"$linha\" done Nós vamos testando se o nosso mycat.sh está legal através da comparação com a saída do comando cat real.\n$ # primeiro com cat $ cat echo-e.txt Uma coisa interessante sobre o comando 'echo' é que quando usamos a opção -e podemos usar algumas sequências de caracteres com um significado especial. Por exemplo \\n significa uma nova linha, e \\t significa . $ $ # depois com mycat.sh $ ./mycat.sh echo-e.txt Uma coisa interessante sobre o comando 'echo' é que quando usamos a opção -e podemos usar algumas sequências de caracteres com um significado especial. Por exemplo n significa uma nova linha, e t significa . $ Aparentemente tudo bem. Mas ali na última linha ao invés de exibir \\n e \\t, o script mostrou apenas n e t. Ou seja, ele “engoliu” a contra-barra.\nMas nós sabemos que o read é cheio de opções. Deve ter uma maneira de resolver isso.\nDando uma olhada no help read encontramos a opção -r, que diz “do not allow backslashes to escape any characters”. Ou seja, não permitir o contra-barra de “escapar” caracter algum.\nOK, hora de melhorar o nosso script…\nSolução 2: read -r linha Direto ao código:\n#!/usr/bin/env bash # mycat.sh # # versão 1: solução naïve # versão 2: lidando com \\contrabarras\\ arquivo=\"$1\" while read -r linha; do echo \"$linha\" done Vamos como o mycat.sh vai lidar com o echo-e.txt agora:\n$ ./mycat.sh echo-e.txt Uma coisa interessante sobre o comando 'echo' é que quando usamos a opção -e podemos usar algumas sequências de caracteres com um significado especial. Por exemplo \\n significa uma nova linha, e \\t significa . $ Opa! Legal! Vamos testar agora com um arquivo simples.txt que possui um pouquinho mais de conteúdo:\n$ # primeiro com o cat $ cat simples.txt Este é um arquivo texto muito simples =====================================  Este é o primeiro parágrafo.  Aqui no segundo parágrafo vamos colocar alguns caracteres com \\contrabarra\\, como por exemplo o \\n e o \\t, só para testes...  Acho que está tudo bem. Vamos terminando aqui no terceiro parágrafo. Até próxima! $ $ # agora com o mycat.sh $ ./mycat.sh simples.txt Este é um arquivo texto muito simples ===================================== Este é o primeiro parágrafo. Aqui no segundo parágrafo vamos colocar alguns caracteres com \\contrabarra\\, como por exemplo o \\n e o \\t, só para testes... Acho que está tudo bem. Vamos terminando aqui no terceiro parágrafo. Até próxima! $ As contra-barras, OK. Mas agora tem uma outra inconsistência ali: os espaços no início de cada parágrafo foram omitidos. :(\nIsso está acontecendo porque usamos o read para atribuir um valor a uma variável, ele automaticamente ignora os espaços que ficam tanto no começo como no final do conteúdo que você informar como entrada.\nNa verdade isso acontece devido a variável de ambiente $IFS. As letras IFS são um acrônimo para Internal Field Separator, esta variável é responsável por “quebrar” o conteúdo de uma linha de comando em argumentos separados.\nGeralmente o conteúdo do IFS é espaço, tabulação e nova linha. Portanto quando o shell encontra esses caracteres ele os ignora e encara o que vem a seguir como um novo parâmetro.\n(Se você não tem a menor ideia do que estou falando, não precisa se desesperar. Fica aqui meu compromisso de posteriormente escrever um artigo detalhando o $IFS de uma maneira que você nunca mais vai esquecer.)\nPara contornar esse problema do script ficar “engolindo” os espaços no começo das linhas, vamos usar um $IFS vazio. Assim o read vai considerar que tudo que está vindo como entrada é apenas um único argumento.\nSolução 3: IFS= read -r linha #!/usr/bin/env bash # mycat.sh # # versão 1: solução naïve # versão 2: lidando com \\contrabarras\\ # versão 3: lidando com espaços no início/fim arquivo=\"$1\" while IFS= read -r linha; do echo \"$linha\" done Essa sintaxe que estamos usando IFS= read -r linha é uma maneira de dizer ao shell que queremos alterar a variável de ambiente $IFS apenas para a execução do comando read que vem a seguir.\nEssa “técnica” é mencionada lá na manpage do bash, na seção que fala sobre ENVIRONMENT, num parágrafo que diz o seguinte: (tradução livre):\n O ambiente para qualquer comando simples ou função pode ser temporariamente alterado prefixando o comando/função com atribuições de parâmetro (…). Estas atribuições afetam somente o ambiente visto por aquele comando.\n Portanto, IFS= read -r linha vai alterar o IFS somente durante a execução do read, depois disso ele volta ao normal.\nVamos testar:\n$ # primeiro com cat $ cat simples.txt Este é um arquivo texto muito simples =====================================  Este é o primeiro parágrafo.  Aqui no segundo parágrafo vamos colocar alguns caracteres com \\contrabarra\\, como por exemplo o \\n e o \\t, só para testes...  Acho que está tudo bem. Vamos terminando aqui no terceiro parágrafo. Até próxima! $ $ # agora com mycat.sh $ ./mycat.sh simples.txt Este é um arquivo texto muito simples =====================================  Este é o primeiro parágrafo.  Aqui no segundo parágrafo vamos colocar alguns caracteres com \\contrabarra\\, como por exemplo o \\n e o \\t, só para testes...  Acho que está tudo bem. Vamos terminando aqui no terceiro parágrafo. Até próxima! $ Agora sim! Tudo igualzinho ao cat!\nAparentemente já temos uma solução bastante robusta, não é mesmo?\nPorém na nossa vida acontecem coisas inesperadas… Ao longo da sua vida de programador shell-script você vai se deparar com arquivos que não foram gerados num ambiente UNIX-like. Podendo inclusive se deparar com um arquivo texto que não terminha com um caractere nova linha.\nPara simular tal situação vamos utilizar o head com a opção -c (note que nos exemplos a seguir algumas vezes o prompt aparece em lugares diferentes):\n$ # quero apenas 105 bytes de simples.txt $ head -c 105 simples.txt Este é um arquivo texto muito simples =====================================  Este é o primeiro parág$ $ # obs: prompt aqui ----^ $ $ # vamos jogar isso num arquivo $ head -c 105 simples.txt  atipico.txt $ $ # testando com cat $ cat atipico.txt Este é um arquivo texto muito simples =====================================  Este é o primeiro parág$ $ # obs: prompt aqui ----^ $ $ $ # agora vamos testar com mycat.sh $ ./mycat.sh atipico.txt Este é um arquivo texto muito simples ===================================== $ Eita! No teste com mycat.sh a última linha foi omitida!\nÉ que no mundo UNIX o caractere nova linha é realmente levado muito a sério…\nO problema do mycat.sh acontece porque quando o read não encontra o caracter de nova linha ele “retorna falso” (ou seja, ao final da execução a variável $? é diferente de zero).\nNo entanto uma coisa curiosa acontece: mesmo retornando falso, o valor da variável é atualizado.\nObserve essa demonstração:\n$ # testando com var1 $ read var1 digitei isso e teclei  $ echo \"$?\" 0 $ # esse zero significa que o read terminou com sucesso $ echo \"$var1\" digitei isso e teclei  $ $ # vamos a outro teste, com var2 $ read var2 mandando um end-of-file com $ echo \"$?\" 1 $ # esse um significa que o read terminou com alguma falha $ echo \"$var2\" mandando um end-of-file com  $ # no entanto o conteúdo de var2 foi atualizado! Desta forma ficou claro que quando o read recebe alguns caracteres e encontra um end-of-file antes de encontrar um nova linha, acontecem duas coisas:\n O conteúdo da variável é atualizado. O read retorna com falha.  Vamos nos aproveitar destes dois fatos e tornar o nosso mycat.sh ainda mais robusto!\nSolução 4: IFS= read -r linha || [[ -n \"$line\" ]] #!/usr/bin/env bash # mycat.sh # # versão 1: solução naïve # versão 2: lidando com \\contrabarras\\ # versão 3: lidando com espaços no início/fim # versão 4: lidando com término inesperado do input arquivo=\"$1\" while IFS= read -r linha || [[ -n \"$linha\" ]]; do echo \"$linha\" done A sintaxe || pode ser “traduzida” como “se, e somente se, o comando a esquerda do || falhar, execute o comando a direita”. Portanto, caso o read falhe o script testa se a variável $linha não está vazia. Isso é aproveitar aqueles fatos que mencionei acima (1. read falha; 2. variável é atualizada).\nAgora, se o read falhar e também o teste da variável $linha vazia falhar, aí chegamos ao fim do while.\nVamos direto ao teste:\n$ # primeiro com cat $ cat atipico.txt Este é um arquivo texto muito simples =====================================  Este é o primeiro parág$ $ # prompt voltou aqui --^ $ $ # agora testando com mycat.sh $ ./mycat.sh atipico.txt Este é um arquivo texto muito simples =====================================  Este é o primeiro parág $ # $ OK… Não ficou 100% igual, pois com o cat o prompt retorna logo após o final efetivo do arquivo.\nO mycat.sh imprime um nova linha após o final do arquivo. No entanto isso não é um caracter nova linha que milagrosamente apareceu ao final de $linha, mas sim um nova linha impresso pelo echo. Portanto se você está usando essa estrutura para percorrer o arquivo linha por linha para fazer um processamento mais sério do que simplesmente imprimir a linha, pode ficar tranquilo que os dados estarão íntegros.\nUfa! Acabamos!\nFontes  https://mywiki.wooledge.org/BashFAQ/001 help read https://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html#Environment  ",
  "wordCount" : "1834",
  "inLanguage": "pt",
  "image":"https://meleu.sh/img/percorrer-arquivo.png","datePublished": "2020-01-21T16:00:42-03:00",
  "dateModified": "2020-01-21T16:00:42-03:00",
  "author":{
    "@type": "Person",
    "name": "meleu"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://meleu.sh/percorrer-arquivo/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "meleu.sh",
    "logo": {
      "@type": "ImageObject",
      "url": "https://meleu.sh/favicon.ico"
    }
  }
}
</script>
</head>

<body class=" dark" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://meleu.sh/" accesskey="h" title="meleu.sh (Alt + H)">meleu.sh</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://meleu.sh/historico/" title="histórico">
                    <span>histórico</span>
                </a>
            </li>
            <li>
                <a href="https://meleu.sh/tags/" title="tags">
                    <span>tags</span>
                </a>
            </li>
            <li>
                <a href="https://meleu.sh/busca/" title="busca">
                    <span>busca</span>
                </a>
            </li>
            <li>
                <a href="https://meleu.sh/sobre/" title="sobre">
                    <span>sobre</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://meleu.sh/">Home</a>&nbsp;»&nbsp;<a href="https://meleu.sh/posts/">Posts</a></div>
    <h1 class="post-title">
      Como ler o conteúdo de um arquivo linha por linha em shell script
    </h1>
    <div class="post-description">
      Veja uma maneira robusta de percorrer um arquivo linha por linha. E sem cair nas armadilhas sutis que nos trazem surpresas desagradáveis.

    </div>
    <div class="post-meta"><span title='2020-01-21 16:00:42 -0300 -0300'>janeiro 21, 2020</span>&nbsp;·&nbsp;9 minutos&nbsp;·&nbsp;meleu&nbsp;|&nbsp;<a href="https://github.com/meleu/meleudotsh/edit/master/content/posts/percorrer-arquivo.md" rel="noopener noreferrer" target="_blank">✏️ Edite este artigo</a>

</div>
  </header> 
<figure class="entry-cover"><img loading="lazy" src="https://meleu.sh/img/percorrer-arquivo.png" alt="loop while para percorrer o arquivo linha a linha">
        
</figure><div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Conteúdo</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#solu%c3%a7%c3%a3o-1-read-linha" aria-label="Solução 1: read linha">Solução 1: <code>read linha</code></a></li>
                <li>
                    <a href="#solu%c3%a7%c3%a3o-2-read--r-linha" aria-label="Solução 2: read -r linha">Solução 2: <code>read -r linha</code></a></li>
                <li>
                    <a href="#solu%c3%a7%c3%a3o-3-ifs-read--r-linha" aria-label="Solução 3: IFS= read -r linha">Solução 3: <code>IFS= read -r linha</code></a></li>
                <li>
                    <a href="#solu%c3%a7%c3%a3o-4-ifs-read--r-linha----n-line-" aria-label="Solução 4: IFS= read -r linha || [[ -n &amp;quot;$line&amp;quot; ]]">Solução 4: <code>IFS= read -r linha || [[ -n &quot;$line&quot; ]]</code></a></li>
                <li>
                    <a href="#fontes" aria-label="Fontes">Fontes</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>Uma das coisas que você certamente vai encarar um dia como um programador de shell scripts é a necessidade de percorrer um arquivo inteiro lendo cada linha e fazer algo com este conteúdo. Veremos neste artigo como fazer isso de maneira segura, robusta e evitando as possíveis armadilhas que podem aparecer no caminho.</p>
<p>Pra adiantar seu lado, vou logo de cara lhe dar a solução que eu considero mais robusta. Em seguida explica cada detalhe dessa estrutura.</p>
<pre tabindex="0"><code>while IFS= read -r linha || [[ -n &#34;$linha&#34; ]]; do
  echo &#34;$linha&#34;
  # faça algo mais interessante aqui...
done &lt; &#34;$arquivo&#34;
</code></pre><p>Dei esse grande <em>spoiler</em> pois percebi que esse artigo ficou relativamente grande, e uma das coisas que mais valorizo aqui é o seu tempo.</p>
<p>Se você só quer a solução, ali está ela. Mas se quiser entender cada detalhezinho dessa estrutura, continue lendo.</p>
<p>A minha explicação vai partir da solução <a href="https://en.wikipedia.org/wiki/Naivety"><em>naïve</em></a> (ou seja, a solução mais básica e ingênua) de como percorrer cada linha de um arquivo. E a partir de cada problema que encontrarmos vamos adicionar uma maneira de contornar. No final de tudo teremos aquela estrutura que mostrei acima.</p>
<h2 id="solução-1-read-linha">Solução 1: <code>read linha</code><a hidden class="anchor" aria-hidden="true" href="#solução-1-read-linha">#</a></h2>
<p>Para fins didáticos, imaginemos que queremos um script que simplesmente imprima na tela cada linha de um arquivo de maneira similar ao uso mais básico do comando <code>cat</code>.</p>
<p>Vamos chamar esse script de <code>mycat.sh</code>, e usaremos redirecionamento para um loop <code>while</code> para alcançar o nosso objetivo.</p>
<p>A primeira vez que eu ouvi falar de redirecionamento de conteúdo de um arquivo para um loop (há duas décadas atrás), a primeira coisa que tentei foi o seguinte:</p>
<pre tabindex="0"><code>#!/usr/bin/env bash
# mycat.sh
#
# versão 1: solução naïve

arquivo=&#34;$1&#34;

while read linha; do
  echo &#34;$linha&#34;
done &lt; &#34;$arquivo&#34;
</code></pre><p>Nós vamos testando se o nosso <code>mycat.sh</code> está legal através da comparação com a saída do comando <code>cat</code> real.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell-session" data-lang="shell-session"><span style="display:flex;"><span>$ <span style="color:#75715e"># primeiro com cat</span>
</span></span><span style="display:flex;"><span>$ cat echo-e.txt 
</span></span><span style="display:flex;"><span>Uma coisa interessante sobre o comando &#39;echo&#39; é que quando
</span></span><span style="display:flex;"><span>usamos a opção -e podemos usar algumas sequências de caracteres
</span></span><span style="display:flex;"><span>com um significado especial.
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>Por exemplo \n significa uma nova linha, e \t significa &lt;TAB&gt;.
</span></span><span style="display:flex;"><span>$ 
</span></span><span style="display:flex;"><span>$ <span style="color:#75715e"># depois com mycat.sh</span>
</span></span><span style="display:flex;"><span>$ ./mycat.sh echo-e.txt 
</span></span><span style="display:flex;"><span>Uma coisa interessante sobre o comando &#39;echo&#39; é que quando
</span></span><span style="display:flex;"><span>usamos a opção -e podemos usar algumas sequências de caracteres
</span></span><span style="display:flex;"><span>com um significado especial.
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>Por exemplo n significa uma nova linha, e t significa &lt;TAB&gt;.
</span></span><span style="display:flex;"><span>$ 
</span></span></code></pre></div><p>Aparentemente tudo bem. Mas ali na última linha ao invés de exibir <code>\n</code> e <code>\t</code>, o script mostrou apenas <code>n</code> e <code>t</code>. Ou seja, ele &ldquo;engoliu&rdquo; a contra-barra.</p>
<p>Mas nós sabemos que o <code>read</code> é cheio de opções. Deve ter uma maneira de resolver isso.</p>
<p>Dando uma olhada no <code>help read</code> encontramos a opção <code>-r</code>, que diz &ldquo;<em>do not allow backslashes to escape any characters</em>&rdquo;. Ou seja, não permitir o contra-barra de &ldquo;escapar&rdquo; caracter algum.</p>
<p>OK, hora de melhorar o nosso script&hellip;</p>
<h2 id="solução-2-read--r-linha">Solução 2: <code>read -r linha</code><a hidden class="anchor" aria-hidden="true" href="#solução-2-read--r-linha">#</a></h2>
<p>Direto ao código:</p>
<pre tabindex="0"><code>#!/usr/bin/env bash
# mycat.sh
#
# versão 1: solução naïve
# versão 2: lidando com \contrabarras\

arquivo=&#34;$1&#34;

while read -r linha; do
  echo &#34;$linha&#34;
done &lt; &#34;$arquivo&#34;
</code></pre><p>Vamos como o <code>mycat.sh</code> vai lidar com o <code>echo-e.txt</code> agora:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell-session" data-lang="shell-session"><span style="display:flex;"><span>$ ./mycat.sh echo-e.txt 
</span></span><span style="display:flex;"><span>Uma coisa interessante sobre o comando &#39;echo&#39; é que quando
</span></span><span style="display:flex;"><span>usamos a opção -e podemos usar algumas sequências de caracteres
</span></span><span style="display:flex;"><span>com um significado especial.
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>Por exemplo \n significa uma nova linha, e \t significa &lt;TAB&gt;.
</span></span><span style="display:flex;"><span>$ 
</span></span></code></pre></div><p>Opa! Legal! Vamos testar agora com um arquivo <code>simples.txt</code> que possui um pouquinho mais de conteúdo:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell-session" data-lang="shell-session"><span style="display:flex;"><span>$ <span style="color:#75715e"># primeiro com o cat</span>
</span></span><span style="display:flex;"><span>$ cat simples.txt 
</span></span><span style="display:flex;"><span>Este é um arquivo texto muito simples
</span></span><span style="display:flex;"><span>=====================================
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>  Este é o primeiro parágrafo.
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>  Aqui no segundo parágrafo vamos colocar
</span></span><span style="display:flex;"><span>alguns caracteres com \contrabarra\, como por
</span></span><span style="display:flex;"><span>exemplo o \n e o \t, só para testes...
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>  Acho que está tudo bem. Vamos terminando
</span></span><span style="display:flex;"><span>aqui no terceiro parágrafo. Até próxima!
</span></span><span style="display:flex;"><span>$ 
</span></span><span style="display:flex;"><span>$ <span style="color:#75715e"># agora com o mycat.sh</span>
</span></span><span style="display:flex;"><span>$ ./mycat.sh simples.txt 
</span></span><span style="display:flex;"><span>Este é um arquivo texto muito simples
</span></span><span style="display:flex;"><span>=====================================
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>Este é o primeiro parágrafo.
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>Aqui no segundo parágrafo vamos colocar
</span></span><span style="display:flex;"><span>alguns caracteres com \contrabarra\, como por
</span></span><span style="display:flex;"><span>exemplo o \n e o \t, só para testes...
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>Acho que está tudo bem. Vamos terminando
</span></span><span style="display:flex;"><span>aqui no terceiro parágrafo. Até próxima!
</span></span><span style="display:flex;"><span>$ 
</span></span></code></pre></div><p>As contra-barras, OK. Mas agora tem uma outra inconsistência ali: os espaços no início de cada parágrafo foram omitidos. :(</p>
<p>Isso está acontecendo porque usamos o <code>read</code> para atribuir um valor a uma variável, ele automaticamente ignora os espaços que ficam tanto no começo como no final do conteúdo que você informar como entrada.</p>
<p>Na verdade isso acontece devido a variável de ambiente <code>$IFS</code>. As letras IFS são um acrônimo para <em>Internal Field Separator</em>, esta variável é responsável por &ldquo;quebrar&rdquo; o conteúdo de uma linha de comando em argumentos separados.</p>
<p>Geralmente o conteúdo do <code>IFS</code> é espaço, tabulação e nova linha. Portanto quando o shell encontra esses caracteres ele os ignora e encara o que vem a seguir como um novo parâmetro.</p>
<p>(Se você não tem a menor ideia do que estou falando, não precisa se desesperar. Fica aqui meu compromisso de posteriormente escrever um artigo detalhando o <code>$IFS</code> de uma maneira que você nunca mais vai esquecer.)</p>
<p>Para contornar esse problema do script ficar &ldquo;engolindo&rdquo; os espaços no começo das linhas, vamos usar um <code>$IFS</code> vazio. Assim o <code>read</code> vai considerar que tudo que está vindo como entrada é apenas um único argumento.</p>
<h2 id="solução-3-ifs-read--r-linha">Solução 3: <code>IFS= read -r linha</code><a hidden class="anchor" aria-hidden="true" href="#solução-3-ifs-read--r-linha">#</a></h2>
<pre tabindex="0"><code>#!/usr/bin/env bash
# mycat.sh
#
# versão 1: solução naïve
# versão 2: lidando com \contrabarras\
# versão 3: lidando com espaços no início/fim

arquivo=&#34;$1&#34;

while IFS= read -r linha; do
  echo &#34;$linha&#34;
done &lt; &#34;$arquivo&#34;
</code></pre><p>Essa sintaxe que estamos usando <code>IFS= read -r linha</code> é uma maneira de dizer ao shell que queremos alterar a variável de ambiente <code>$IFS</code> apenas para a execução do comando <code>read</code> que vem a seguir.</p>
<p>Essa &ldquo;técnica&rdquo; é mencionada lá na manpage do bash, na seção que fala sobre ENVIRONMENT, num parágrafo que diz o seguinte: (tradução livre):</p>
<blockquote>
<p>O ambiente para qualquer comando simples ou função pode ser temporariamente alterado prefixando o comando/função com atribuições de parâmetro (&hellip;). Estas atribuições afetam somente o ambiente visto por aquele comando.</p>
</blockquote>
<p>Portanto, <code>IFS= read -r linha</code> vai alterar o <code>IFS</code> somente durante a execução do <code>read</code>, depois disso ele volta ao normal.</p>
<p>Vamos testar:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell-session" data-lang="shell-session"><span style="display:flex;"><span>$ <span style="color:#75715e"># primeiro com cat</span>
</span></span><span style="display:flex;"><span>$ cat simples.txt 
</span></span><span style="display:flex;"><span>Este é um arquivo texto muito simples
</span></span><span style="display:flex;"><span>=====================================
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>  Este é o primeiro parágrafo.
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>  Aqui no segundo parágrafo vamos colocar
</span></span><span style="display:flex;"><span>alguns caracteres com \contrabarra\, como por
</span></span><span style="display:flex;"><span>exemplo o \n e o \t, só para testes...
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>  Acho que está tudo bem. Vamos terminando
</span></span><span style="display:flex;"><span>aqui no terceiro parágrafo. Até próxima!
</span></span><span style="display:flex;"><span>$ 
</span></span><span style="display:flex;"><span>$ <span style="color:#75715e"># agora com mycat.sh</span>
</span></span><span style="display:flex;"><span>$ ./mycat.sh simples.txt 
</span></span><span style="display:flex;"><span>Este é um arquivo texto muito simples
</span></span><span style="display:flex;"><span>=====================================
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>  Este é o primeiro parágrafo.
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>  Aqui no segundo parágrafo vamos colocar
</span></span><span style="display:flex;"><span>alguns caracteres com \contrabarra\, como por
</span></span><span style="display:flex;"><span>exemplo o \n e o \t, só para testes...
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>  Acho que está tudo bem. Vamos terminando
</span></span><span style="display:flex;"><span>aqui no terceiro parágrafo. Até próxima!
</span></span><span style="display:flex;"><span>$ 
</span></span></code></pre></div><p>Agora sim! Tudo igualzinho ao cat!</p>
<p>Aparentemente já temos uma solução bastante robusta, não é mesmo?</p>
<p>Porém na nossa vida acontecem coisas inesperadas&hellip; Ao longo da sua vida de programador shell-script você vai se deparar com arquivos que não foram gerados num ambiente UNIX-like. Podendo inclusive se deparar com um arquivo texto que não terminha com um caractere nova linha.</p>
<p>Para simular tal situação vamos utilizar o <code>head</code> com a opção <code>-c</code> (note que nos exemplos a seguir algumas vezes o prompt aparece em lugares diferentes):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell-session" data-lang="shell-session"><span style="display:flex;"><span>$ <span style="color:#75715e"># quero apenas 105 bytes de simples.txt</span>
</span></span><span style="display:flex;"><span>$ head -c <span style="color:#ae81ff">105</span> simples.txt 
</span></span><span style="display:flex;"><span>Este é um arquivo texto muito simples
</span></span><span style="display:flex;"><span>=====================================
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>  Este é o primeiro parág$
</span></span><span style="display:flex;"><span>$ <span style="color:#75715e"># obs: prompt aqui ----^</span>
</span></span><span style="display:flex;"><span>$ 
</span></span><span style="display:flex;"><span>$ <span style="color:#75715e"># vamos jogar isso num arquivo</span>
</span></span><span style="display:flex;"><span>$ head -c <span style="color:#ae81ff">105</span> simples.txt &gt; atipico.txt
</span></span><span style="display:flex;"><span>$ 
</span></span><span style="display:flex;"><span>$ <span style="color:#75715e"># testando com cat</span>
</span></span><span style="display:flex;"><span>$ cat atipico.txt 
</span></span><span style="display:flex;"><span>Este é um arquivo texto muito simples
</span></span><span style="display:flex;"><span>=====================================
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>  Este é o primeiro parág$
</span></span><span style="display:flex;"><span>$ <span style="color:#75715e"># obs: prompt aqui ----^</span>
</span></span><span style="display:flex;"><span>$ 
</span></span><span style="display:flex;"><span>$ 
</span></span><span style="display:flex;"><span>$ <span style="color:#75715e"># agora vamos testar com mycat.sh</span>
</span></span><span style="display:flex;"><span>$ ./mycat.sh atipico.txt 
</span></span><span style="display:flex;"><span>Este é um arquivo texto muito simples
</span></span><span style="display:flex;"><span>=====================================
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>$ 
</span></span></code></pre></div><p>Eita! No teste com <code>mycat.sh</code> a última linha foi omitida!</p>
<p>É que no mundo UNIX o caractere nova linha é realmente levado muito a sério&hellip;</p>
<p>O problema do <code>mycat.sh</code> acontece porque quando o <code>read</code> não encontra o caracter de nova linha ele &ldquo;retorna falso&rdquo; (ou seja, ao final da execução a variável <code>$?</code> é diferente de zero).</p>
<p>No entanto uma coisa curiosa acontece: mesmo retornando falso, <strong>o valor da variável é atualizado</strong>.</p>
<p>Observe essa demonstração:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell-session" data-lang="shell-session"><span style="display:flex;"><span>$ <span style="color:#75715e"># testando com var1</span>
</span></span><span style="display:flex;"><span>$ read var1
</span></span><span style="display:flex;"><span>digitei isso e teclei &lt;ENTER&gt;
</span></span><span style="display:flex;"><span>$ echo <span style="color:#e6db74">&#34;</span>$?<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>0
</span></span><span style="display:flex;"><span>$ <span style="color:#75715e"># esse zero significa que o read terminou com sucesso</span>
</span></span><span style="display:flex;"><span>$ echo <span style="color:#e6db74">&#34;</span>$var1<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>digitei isso e teclei &lt;ENTER&gt;
</span></span><span style="display:flex;"><span>$ 
</span></span><span style="display:flex;"><span>$ <span style="color:#75715e"># vamos a outro teste, com var2</span>
</span></span><span style="display:flex;"><span>$ read var2
</span></span><span style="display:flex;"><span>mandando um end-of-file com &lt;CTRL+D&gt;$ echo &#34;$?&#34;
</span></span><span style="display:flex;"><span>1
</span></span><span style="display:flex;"><span>$ <span style="color:#75715e"># esse um significa que o read terminou com alguma falha</span>
</span></span><span style="display:flex;"><span>$ echo <span style="color:#e6db74">&#34;</span>$var2<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>mandando um end-of-file com &lt;CTRL+D&gt;
</span></span><span style="display:flex;"><span>$ <span style="color:#75715e"># no entanto o conteúdo de var2 foi atualizado!</span>
</span></span></code></pre></div><p>Desta forma ficou claro que quando o <code>read</code> recebe alguns caracteres e encontra um <em>end-of-file</em> antes de encontrar um nova linha, acontecem duas coisas:</p>
<ol>
<li>O conteúdo da variável é atualizado.</li>
<li>O <code>read</code> retorna com falha.</li>
</ol>
<p>Vamos nos aproveitar destes dois fatos e tornar o nosso <code>mycat.sh</code> ainda mais robusto!</p>
<h2 id="solução-4-ifs-read--r-linha----n-line-">Solução 4: <code>IFS= read -r linha || [[ -n &quot;$line&quot; ]]</code><a hidden class="anchor" aria-hidden="true" href="#solução-4-ifs-read--r-linha----n-line-">#</a></h2>
<pre tabindex="0"><code>#!/usr/bin/env bash
# mycat.sh
#
# versão 1: solução naïve
# versão 2: lidando com \contrabarras\
# versão 3: lidando com espaços no início/fim
# versão 4: lidando com término inesperado do input

arquivo=&#34;$1&#34;

while IFS= read -r linha || [[ -n &#34;$linha&#34; ]]; do
  echo &#34;$linha&#34;
done &lt; &#34;$arquivo&#34;
</code></pre><p>A sintaxe <code>||</code> pode ser &ldquo;traduzida&rdquo; como &ldquo;se, e somente se, o comando a esquerda do <code>||</code> falhar, execute o comando a direita&rdquo;. Portanto, caso o <code>read</code> falhe o script testa se a variável <code>$linha</code> não está vazia. Isso é aproveitar aqueles fatos que mencionei acima (1. <code>read</code> falha; 2. variável é atualizada).</p>
<p>Agora, se o <code>read</code> falhar e também o teste da variável <code>$linha</code> vazia falhar, aí chegamos ao fim do <code>while</code>.</p>
<p>Vamos direto ao teste:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell-session" data-lang="shell-session"><span style="display:flex;"><span>$ <span style="color:#75715e"># primeiro com cat</span>
</span></span><span style="display:flex;"><span>$ cat atipico.txt 
</span></span><span style="display:flex;"><span>Este é um arquivo texto muito simples
</span></span><span style="display:flex;"><span>=====================================
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>  Este é o primeiro parág$ 
</span></span><span style="display:flex;"><span>$ <span style="color:#75715e"># prompt voltou aqui --^</span>
</span></span><span style="display:flex;"><span>$ 
</span></span><span style="display:flex;"><span>$ <span style="color:#75715e"># agora testando com mycat.sh</span>
</span></span><span style="display:flex;"><span>$ ./mycat.sh atipico.txt 
</span></span><span style="display:flex;"><span>Este é um arquivo texto muito simples
</span></span><span style="display:flex;"><span>=====================================
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>  Este é o primeiro parág
</span></span><span style="display:flex;"><span>$ <span style="color:#75715e"># &lt;-- o prompt voltou aqui</span>
</span></span><span style="display:flex;"><span>$ 
</span></span></code></pre></div><p>OK&hellip; Não ficou 100% igual, pois com o <code>cat</code> o prompt retorna logo após o final efetivo do arquivo.</p>
<p>O <code>mycat.sh</code> imprime um nova linha após o final do arquivo. No entanto isso não é um caracter nova linha que milagrosamente apareceu ao final de <code>$linha</code>, mas sim um nova linha impresso pelo <code>echo</code>. Portanto se você está usando essa estrutura para percorrer o arquivo linha por linha para fazer um processamento mais sério do que simplesmente imprimir a linha, pode ficar tranquilo que os dados estarão íntegros.</p>
<p>Ufa! Acabamos!</p>
<h2 id="fontes">Fontes<a hidden class="anchor" aria-hidden="true" href="#fontes">#</a></h2>
<ul>
<li><a href="https://mywiki.wooledge.org/BashFAQ/001">https://mywiki.wooledge.org/BashFAQ/001</a></li>
<li><code>help read</code></li>
<li><a href="https://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html#Environment">https://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html#Environment</a></li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://meleu.sh/tags/boas-praticas/">boas-praticas</a></li>
      <li><a href="https://meleu.sh/tags/codigo/">codigo</a></li>
    </ul>

<div class="share-buttons">
    <a target="_blank" rel="noopener noreferrer" aria-label="share Como ler o conteúdo de um arquivo linha por linha em shell script on twitter"
        href="https://twitter.com/intent/tweet/?text=Como%20ler%20o%20conte%c3%bado%20de%20um%20arquivo%20linha%20por%20linha%20em%20shell%20script&amp;url=https%3a%2f%2fmeleu.sh%2fpercorrer-arquivo%2f&amp;hashtags=boas-praticas%2ccodigo">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-253.927,424.544c135.939,0 210.268,-112.643 210.268,-210.268c0,-3.218 0,-6.437 -0.153,-9.502c14.406,-10.421 26.973,-23.448 36.935,-38.314c-13.18,5.824 -27.433,9.809 -42.452,11.648c15.326,-9.196 26.973,-23.602 32.49,-40.92c-14.252,8.429 -30.038,14.56 -46.896,17.931c-13.487,-14.406 -32.644,-23.295 -53.946,-23.295c-40.767,0 -73.87,33.104 -73.87,73.87c0,5.824 0.613,11.494 1.992,16.858c-61.456,-3.065 -115.862,-32.49 -152.337,-77.241c-6.284,10.881 -9.962,23.601 -9.962,37.088c0,25.594 13.027,48.276 32.95,61.456c-12.107,-0.307 -23.448,-3.678 -33.41,-9.196l0,0.92c0,35.862 25.441,65.594 59.311,72.49c-6.13,1.686 -12.72,2.606 -19.464,2.606c-4.751,0 -9.348,-0.46 -13.946,-1.38c9.349,29.426 36.628,50.728 68.965,51.341c-25.287,19.771 -57.164,31.571 -91.8,31.571c-5.977,0 -11.801,-0.306 -17.625,-1.073c32.337,21.15 71.264,33.41 112.95,33.41Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Como ler o conteúdo de um arquivo linha por linha em shell script on linkedin"
        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fmeleu.sh%2fpercorrer-arquivo%2f&amp;title=Como%20ler%20o%20conte%c3%bado%20de%20um%20arquivo%20linha%20por%20linha%20em%20shell%20script&amp;summary=Como%20ler%20o%20conte%c3%bado%20de%20um%20arquivo%20linha%20por%20linha%20em%20shell%20script&amp;source=https%3a%2f%2fmeleu.sh%2fpercorrer-arquivo%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Como ler o conteúdo de um arquivo linha por linha em shell script on reddit"
        href="https://reddit.com/submit?url=https%3a%2f%2fmeleu.sh%2fpercorrer-arquivo%2f&title=Como%20ler%20o%20conte%c3%bado%20de%20um%20arquivo%20linha%20por%20linha%20em%20shell%20script">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Como ler o conteúdo de um arquivo linha por linha em shell script on facebook"
        href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fmeleu.sh%2fpercorrer-arquivo%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Como ler o conteúdo de um arquivo linha por linha em shell script on whatsapp"
        href="https://api.whatsapp.com/send?text=Como%20ler%20o%20conte%c3%bado%20de%20um%20arquivo%20linha%20por%20linha%20em%20shell%20script%20-%20https%3a%2f%2fmeleu.sh%2fpercorrer-arquivo%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Como ler o conteúdo de um arquivo linha por linha em shell script on telegram"
        href="https://telegram.me/share/url?text=Como%20ler%20o%20conte%c3%bado%20de%20um%20arquivo%20linha%20por%20linha%20em%20shell%20script&amp;url=https%3a%2f%2fmeleu.sh%2fpercorrer-arquivo%2f">
        <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
            <path
                d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
        </svg>
    </a>
</div>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2022 <a href="https://meleu.sh/">meleu.sh</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
